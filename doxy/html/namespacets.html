<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: ts Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.2</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacets.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ts Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>TSDuck namespace, containing all TSDuck classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacets_1_1ecmgscs"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1ecmgscs.html">ecmgscs</a></td></tr>
<tr class="memdesc:namespacets_1_1ecmgscs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of the DVB SimulCrypt ECMG &lt;=&gt; SCS protocol. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1emmgmux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1emmgmux.html">emmgmux</a></td></tr>
<tr class="memdesc:namespacets_1_1emmgmux"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of the DVB SimulCrypt EMMG &lt;=&gt; MUX protocol. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1hexa"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1hexa.html">hexa</a></td></tr>
<tr class="memdesc:namespacets_1_1hexa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for the <a class="el" href="namespacets.html#a518c3129e643fa3c679f061fcfcf271f" title="Build a multi-line string containing the hexadecimal dump of a memory area. ">ts::Hexa()</a> family of functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1names"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1names.html">names</a></td></tr>
<tr class="memdesc:namespacets_1_1names"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for functions returning MPEG/DVB names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1pcsc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1pcsc.html">pcsc</a></td></tr>
<tr class="memdesc:namespacets_1_1pcsc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PC/SC smartcard API utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1tlv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1tlv.html">tlv</a></td></tr>
<tr class="memdesc:namespacets_1_1tlv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for TLV protocols (Tag / Length / Value) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1tsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1tsp.html">tsp</a></td></tr>
<tr class="memdesc:namespacets_1_1tsp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport Stream Processor (tsp) namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1_u_h_f"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1_u_h_f.html">UHF</a></td></tr>
<tr class="memdesc:namespacets_1_1_u_h_f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacets_1_1_u_h_f.html" title="UHF (Ultra High Frequecy) band. ">UHF</a> (Ultra High Frequecy) band. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacets_1_1_v_h_f"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets_1_1_v_h_f.html">VHF</a></td></tr>
<tr class="memdesc:namespacets_1_1_v_h_f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacets_1_1_v_h_f.html" title="VHF (Very High Frequency) band III. ">VHF</a> (Very High Frequency) band III. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_a_c_descriptor.html">AACDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an AAC_descriptor.  <a href="classts_1_1_a_a_c_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abort_interface.html">AbortInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to check for abort.  <a href="classts_1_1_abort_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_audio_video_attributes.html">AbstractAudioVideoAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for MPEG audio and video attributes.  <a href="classts_1_1_abstract_audio_video_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_a_v_c_access_unit.html">AbstractAVCAccessUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for AVC access units, aka NALunits.  <a href="classts_1_1_abstract_a_v_c_access_unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_a_v_c_data.html">AbstractAVCData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for AVC data, either access units or structures.  <a href="classts_1_1_abstract_a_v_c_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_a_v_c_structure.html">AbstractAVCStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for AVC sub-structures inside access units.  <a href="classts_1_1_abstract_a_v_c_structure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_c_a_s_date.html">AbstractCASDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representation of a CAS date.  <a href="classts_1_1_abstract_c_a_s_date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_delivery_system_descriptor.html">AbstractDeliverySystemDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for DVB delivery system descriptors.  <a href="classts_1_1_abstract_delivery_system_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_descrambler.html">AbstractDescrambler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for DVB descrambler plugins.  <a href="classts_1_1_abstract_descrambler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_descriptor.html">AbstractDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for MPEG PSI/SI descriptors.  <a href="classts_1_1_abstract_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_descriptors_table.html">AbstractDescriptorsTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for MPEG tables containing only a list of descriptors (eg.  <a href="classts_1_1_abstract_descriptors_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_long_table.html">AbstractLongTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for MPEG PSI/SI tables with long sections.  <a href="classts_1_1_abstract_long_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_table.html">AbstractTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for MPEG PSI/SI tables.  <a href="classts_1_1_abstract_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_abstract_transport_list_table.html">AbstractTransportListTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for tables containing a list of transport stream descriptions.  <a href="classts_1_1_abstract_transport_list_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_c3_attributes.html">AC3Attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AC-3 (DD) and Enhanced-AC-3 (DD+) audio attributes.  <a href="classts_1_1_a_c3_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_c3_descriptor.html">AC3Descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an AC-3_descriptor.  <a href="classts_1_1_a_c3_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_e_s.html">AES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">AES</a> block cipher.  <a href="classts_1_1_a_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_application_shared_library.html">ApplicationSharedLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an application shared library.  <a href="classts_1_1_application_shared_library.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_application_signalling_descriptor.html">ApplicationSignallingDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an application_signalling_descriptor.  <a href="classts_1_1_application_signalling_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_args.html">Args</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An encapsulation of command line syntax and analysis.  <a href="classts_1_1_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_async_report.html">AsyncReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous message report.  <a href="classts_1_1_async_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_audio_attributes.html">AudioAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio attributes for MPEG-1 / MPEG-2 audio.  <a href="classts_1_1_audio_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_audio_language_options.html">AudioLanguageOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to update the language of an audio stream in a <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>.  <a href="classts_1_1_audio_language_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_audio_language_options_vector.html">AudioLanguageOptionsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of audio language options.  <a href="classts_1_1_audio_language_options_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_v_c_attributes.html">AVCAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video attributes for Advanced Video Coding.  <a href="classts_1_1_a_v_c_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_v_c_h_r_d_parameters.html">AVCHRDParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVC HRD (Hypothetical Reference Decoder) parameters.  <a href="classts_1_1_a_v_c_h_r_d_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_v_c_parser.html">AVCParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser for Advanced Video Coding data.  <a href="classts_1_1_a_v_c_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_v_c_sequence_parameter_set.html">AVCSequenceParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an AVC sequence parameter set access unit.  <a href="classts_1_1_a_v_c_sequence_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_a_v_c_v_u_i_parameters.html">AVCVUIParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVC VUI (Video Usability Information) parameters.  <a href="classts_1_1_a_v_c_v_u_i_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_b_a_t.html">BAT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Bouquet Association Table (<a class="el" href="classts_1_1_b_a_t.html" title="Representation of a Bouquet Association Table (BAT). ">BAT</a>).  <a href="classts_1_1_b_a_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_binary_table.html">BinaryTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of MPEG PSI/SI tables in binary form (ie.  <a href="classts_1_1_binary_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_bit_stream.html">BitStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to analyze a bit-stream in memory.  <a href="classts_1_1_bit_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_block_cipher.html">BlockCipher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface of block ciphers.  <a href="classts_1_1_block_cipher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_bouquet_name_descriptor.html">BouquetNameDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a bouquet_name_descriptor.  <a href="classts_1_1_bouquet_name_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a generic block of bytes.  <a href="classts_1_1_byte_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cable_delivery_system_descriptor.html">CableDeliverySystemDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a cable_delivery_system_descriptor.  <a href="classts_1_1_cable_delivery_system_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_a_descriptor.html">CADescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a generic CA_descriptor.  <a href="classts_1_1_c_a_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_a_identifier_descriptor.html">CAIdentifierDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a CA_identifier_descriptor.  <a href="classts_1_1_c_a_identifier_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_a_s_mapper.html">CASMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class maps PID's with CA system ids.  <a href="classts_1_1_c_a_s_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_a_s_selection_args.html">CASSelectionArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line arguments for the class <a class="el" href="classts_1_1_p_s_i_logger.html" title="This class logs sections and tables. ">PSILogger</a>.  <a href="classts_1_1_c_a_s_selection_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_a_t.html">CAT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Conditional Access Table (<a class="el" href="classts_1_1_c_a_t.html" title="Representation of a Conditional Access Table (CAT). ">CAT</a>).  <a href="classts_1_1_c_a_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_b_c.html">CBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher Block Chaining (<a class="el" href="classts_1_1_c_b_c.html" title="Cipher Block Chaining (CBC) mode. ">CBC</a>) mode.  <a href="classts_1_1_c_b_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cerr_report.html">CerrReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singleton implementing <a class="el" href="classts_1_1_report_interface.html" title="Abstract interface for event reporting and monitoring. ">ReportInterface</a> on std::cerr without synchronization.  <a href="classts_1_1_cerr_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html">CipherChaining</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all cipher chaining modes.  <a href="classts_1_1_cipher_chaining.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining_template.html">CipherChainingTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all cipher chaining modes, template version.  <a href="classts_1_1_cipher_chaining_template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_o_m.html">COM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to encapsulate the initialization of Windows <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a>.  <a href="classts_1_1_c_o_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_component_descriptor.html">ComponentDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a component_descriptor.  <a href="classts_1_1_component_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_com_ptr.html">ComPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed pointers for <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects, auto-released (Windows-specific).  <a href="classts_1_1_com_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_condition.html">Condition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <em>synchronization</em> <em>condition</em> design pattern.  <a href="classts_1_1_condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_config_file.html">ConfigFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration files management.  <a href="classts_1_1_config_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_config_section.html">ConfigSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a "configuration section".  <a href="classts_1_1_config_section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_content_descriptor.html">ContentDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a content_descriptor.  <a href="classts_1_1_content_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_country_availability_descriptor.html">CountryAvailabilityDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a country_availability_descriptor.  <a href="classts_1_1_country_availability_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_r_c32.html">CRC32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclic Redundancy Check as used in MPEG sections.  <a href="classts_1_1_c_r_c32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_t_s1.html">CTS1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher text Stealing (CTS) mode, alternative 1.  <a href="classts_1_1_c_t_s1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_t_s2.html">CTS2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher text Stealing (CTS) mode, alternative 2.  <a href="classts_1_1_c_t_s2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_t_s3.html">CTS3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher text Stealing (CTS) mode, alternative 3.  <a href="classts_1_1_c_t_s3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_c_t_s4.html">CTS4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher text Stealing (CTS) mode, alternative 4.  <a href="classts_1_1_c_t_s4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cycling_packetizer.html">CyclingPacketizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclic packetization of MPEG sections into Transport Stream packets.  <a href="classts_1_1_cycling_packetizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_data_broadcast_descriptor.html">DataBroadcastDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a data_broadcast_descriptor.  <a href="classts_1_1_data_broadcast_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_data_broadcast_id_descriptor.html">DataBroadcastIdDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a generic data_broadcast_id_descriptor.  <a href="classts_1_1_data_broadcast_id_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_dektec_control.html">DektecControl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing the tsdektec control utility.  <a href="classts_1_1_dektec_control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_dektec_input_plugin.html">DektecInputPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dektec input plugin for <code>tsp</code>.  <a href="classts_1_1_dektec_input_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_dektec_output_plugin.html">DektecOutputPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dektec output plugin for <code>tsp</code>.  <a href="classts_1_1_dektec_output_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_e_s.html">DES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">DES</a> block cipher.  <a href="classts_1_1_d_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_descriptor.html">Descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a MPEG PSI/SI descriptors in binary format.  <a href="classts_1_1_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_descriptor_list.html">DescriptorList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of MPEG PSI/SI descriptors.  <a href="classts_1_1_descriptor_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_double_check_lock.html">DoubleCheckLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classts_1_1_double_check_lock.html" title="The class DoubleCheckLock implements the double check locking design pattern. ">DoubleCheckLock</a> implements the <em>double check locking</em> design pattern.  <a href="classts_1_1_double_check_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_t_s_descriptor.html">DTSDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a DTS_descriptor.  <a href="classts_1_1_d_t_s_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_t_v_properties.html">DTVProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of Linux DVB property lists.  <a href="classts_1_1_d_t_v_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html">DVS042</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVS 042 cipher block chaining mode.  <a href="classts_1_1_d_v_s042.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_eacem_preferred_name_identifier_descriptor.html">EacemPreferredNameIdentifierDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an eacem_preferred_name_identifier_descriptor.  <a href="classts_1_1_eacem_preferred_name_identifier_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_eacem_preferred_name_list_descriptor.html">EacemPreferredNameListDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an eacem_preferred_name_list_descriptor.  <a href="classts_1_1_eacem_preferred_name_list_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_eacem_stream_identifier_descriptor.html">EacemStreamIdentifierDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an eacem_stream_identifier_descriptor.  <a href="classts_1_1_eacem_stream_identifier_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_e_c_b.html">ECB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Electronic Code Book (<a class="el" href="classts_1_1_e_c_b.html" title="Electronic Code Book (ECB) mode. ">ECB</a>) mode.  <a href="classts_1_1_e_c_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_e_c_m_g_client.html">ECMGClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DVB-ECMG client which acts as a DVB-SCS.  <a href="classts_1_1_e_c_m_g_client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_e_c_m_g_client_handler_interface.html">ECMGClientHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for classes which need to be notified of asynchronous ECM generation using <a class="el" href="classts_1_1_e_c_m_g_client.html" title="A DVB-ECMG client which acts as a DVB-SCS. ">ECMGClient</a>.  <a href="classts_1_1_e_c_m_g_client_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_e_i_t.html">EIT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an <a class="el" href="classts_1_1_e_i_t_1_1_event.html" title="Description of an event. ">Event</a> Information Table (<a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a>)  <a href="classts_1_1_e_i_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_enhanced_a_c3_descriptor.html">EnhancedAC3Descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an enhanced_AC-3_descriptor.  <a href="classts_1_1_enhanced_a_c3_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_enumeration.html">Enumeration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> of int/string pairs.  <a href="classts_1_1_enumeration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_e_t_i_d.html">ETID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended MPEG table id.  <a href="classts_1_1_e_t_i_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_eutelsat_channel_number_descriptor.html">EutelsatChannelNumberDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an Eutelsat_channel_number_descriptor.  <a href="classts_1_1_eutelsat_channel_number_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions in TSDuck.  <a href="classts_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_extended_event_descriptor.html">ExtendedEventDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a extended_event_descriptor.  <a href="classts_1_1_extended_event_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_file_name_rate.html">FileNameRate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a file name and an associated repetition rate.  <a href="structts_1_1_file_name_rate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_fork_pipe.html">ForkPipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fork a process and create a pipe to its standard input.  <a href="classts_1_1_fork_pipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_gen_tab_plugin.html">GenTabPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class of all tsgentab plugins.  <a href="classts_1_1_gen_tab_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_guard.html">Guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic guard class for mutex (<a class="el" href="classts_1_1_mutex_interface.html" title="Interface class for mutex objects. ">ts::MutexInterface</a>).  <a href="classts_1_1_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_guard_condition.html">GuardCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic guard class for synchronization condition (<a class="el" href="classts_1_1_condition.html" title="Implementation of the synchronization condition design pattern. ">ts::Condition</a>).  <a href="classts_1_1_guard_condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_hash.html">Hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface of hash functions.  <a href="classts_1_1_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_h_d_simulcast_logical_channel_descriptor.html">HDSimulcastLogicalChannelDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a HD_simulcast_logical_channel_descriptor.  <a href="classts_1_1_h_d_simulcast_logical_channel_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_implementation_error.html">ImplementationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation error.  <a href="classts_1_1_implementation_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_input_plugin.html">InputPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input <code>tsp</code> plugin interface.  <a href="classts_1_1_input_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_input_redirector.html">InputRedirector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to redirect an input stream.  <a href="classts_1_1_input_redirector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_interrupt_handler.html">InterruptHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to be implemented by a class to handle user Ctrl-C interrupt.  <a href="classts_1_1_interrupt_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_invalid_value.html">InvalidValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_exception.html" title="Base class for all exceptions in TSDuck. ">Exception</a> for generic invalid value error.  <a href="classts_1_1_invalid_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_i_p_address.html">IPAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic representation of an IP v4 address.  <a href="classts_1_1_i_p_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_i_s_o639_language_descriptor.html">ISO639LanguageDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an ISO_639_language_descriptor.  <a href="classts_1_1_i_s_o639_language_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_linkage_descriptor.html">LinkageDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a generic linkage_descriptor.  <a href="classts_1_1_linkage_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_l_n_b.html">LNB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a Low-Noise Block (<a class="el" href="classts_1_1_l_n_b.html" title="Description of a Low-Noise Block (LNB) converter in a satellite dish. ">LNB</a>) converter in a satellite dish.  <a href="classts_1_1_l_n_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_local_time_offset_descriptor.html">LocalTimeOffsetDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a local_time_offset_descriptor.  <a href="classts_1_1_local_time_offset_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_logical_channel_number_descriptor.html">LogicalChannelNumberDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a logical_channel_number_descriptor.  <a href="classts_1_1_logical_channel_number_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_m_d5.html">MD5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD-5 hash.  <a href="classts_1_1_m_d5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_media_guard_date.html">MediaGuardDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a MediaGuard date.  <a href="classts_1_1_media_guard_date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_message_descriptor.html">MessageDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a message_descriptor.  <a href="classts_1_1_message_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_message_queue.html">MessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template message queue for inter-thread communication.  <a href="classts_1_1_message_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_monotonic.html">Monotonic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic monotonic clock &amp; timer.  <a href="classts_1_1_monotonic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex implementation which is compatible with the <a class="el" href="classts_1_1_thread.html" title="Base class for threads. ">ts::Thread</a> class.  <a href="classts_1_1_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_mutex_interface.html">MutexInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for mutex objects.  <a href="classts_1_1_mutex_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_network_name_descriptor.html">NetworkNameDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a network_name_descriptor.  <a href="classts_1_1_network_name_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_n_i_t.html">NIT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Network Information Table (<a class="el" href="classts_1_1_n_i_t.html" title="Representation of a Network Information Table (NIT) ">NIT</a>)  <a href="classts_1_1_n_i_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_null_mutex.html">NullMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty mutex implementation.  <a href="classts_1_1_null_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_null_report.html">NullReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singleton implementing <a class="el" href="classts_1_1_report_interface.html" title="Abstract interface for event reporting and monitoring. ">ReportInterface</a> which drops all messages.  <a href="classts_1_1_null_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for objects which can be stored in a repository.  <a href="classts_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_one_shot_packetizer.html">OneShotPacketizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packetization of MPEG sections into Transport Stream packets in one shot.  <a href="classts_1_1_one_shot_packetizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_output_plugin.html">OutputPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output <code>tsp</code> plugin interface.  <a href="classts_1_1_output_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_output_redirector.html">OutputRedirector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to redirect an output stream.  <a href="classts_1_1_output_redirector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_packetizer.html">Packetizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packetization of MPEG sections into Transport Stream packets.  <a href="classts_1_1_packetizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_parental_rating_descriptor.html">ParentalRatingDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an parental_rating_descriptor.  <a href="classts_1_1_parental_rating_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_a_t.html">PAT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Program Association Table (<a class="el" href="classts_1_1_p_a_t.html" title="Representation of a Program Association Table (PAT) ">PAT</a>)  <a href="classts_1_1_p_a_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_c_r_analyzer.html">PCRAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCR statistics analysis.  <a href="classts_1_1_p_c_r_analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_e_s_demux.html">PESDemux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class extracts PES packets from TS packets.  <a href="classts_1_1_p_e_s_demux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_e_s_handler_interface.html">PESHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to be notified of PES packets using a <a class="el" href="classts_1_1_p_e_s_demux.html" title="This class extracts PES packets from TS packets. ">PESDemux</a>.  <a href="classts_1_1_p_e_s_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_e_s_packet.html">PESPacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of MPEG PES packets.  <a href="classts_1_1_p_e_s_packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_p_i_d_operator.html">PIDOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Association of a PID and an <em>operator</em> id (CAS-specific).  <a href="structts_1_1_p_i_d_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_i_d_operator_set.html">PIDOperatorSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized set of <a class="el" href="structts_1_1_p_i_d_operator.html" title="Association of a PID and an operator id (CAS-specific). ">PIDOperator</a>.  <a href="classts_1_1_p_i_d_operator_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_plugin.html">Plugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all <code>tsp</code> plugins.  <a href="classts_1_1_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_plugin_shared_library.html">PluginSharedLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="classts_1_1_t_s_p.html" title="TSP callback for plugins. ">TSP</a> plugin shared library.  <a href="classts_1_1_plugin_shared_library.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_m_t.html">PMT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Program Map Table (<a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>)  <a href="classts_1_1_p_m_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_polled_file.html">PolledFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a polled file.  <a href="classts_1_1_polled_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_poll_files.html">PollFiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to poll files for modifications.  <a href="classts_1_1_poll_files.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_poll_files_listener.html">PollFilesListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for classes listening for file modification.  <a href="classts_1_1_poll_files_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_private_data_specifier_descriptor.html">PrivateDataSpecifierDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a private_data_specifier_descriptor.  <a href="classts_1_1_private_data_specifier_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_process_metrics.html">ProcessMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure contains metrics about a process.  <a href="structts_1_1_process_metrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_processor_plugin.html">ProcessorPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet processing <code>tsp</code> plugin interface.  <a href="classts_1_1_processor_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_s_i_logger.html">PSILogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class logs sections and tables.  <a href="classts_1_1_p_s_i_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_p_s_i_logger_args.html">PSILoggerArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line arguments for the class <a class="el" href="classts_1_1_p_s_i_logger.html" title="This class logs sections and tables. ">PSILogger</a>.  <a href="classts_1_1_p_s_i_logger_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_random_generator.html">RandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for PRNG's (pseudo-random numbers generators).  <a href="classts_1_1_random_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_report_buffer.html">ReportBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subclass of <a class="el" href="classts_1_1_report_interface.html" title="Abstract interface for event reporting and monitoring. ">ts::ReportInterface</a> which logs all messages in an internal buffer.  <a href="classts_1_1_report_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_report_file.html">ReportFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subclass of <a class="el" href="classts_1_1_report_interface.html" title="Abstract interface for event reporting and monitoring. ">ts::ReportInterface</a> which outputs messages in a text file.  <a href="classts_1_1_report_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_report_handler.html">ReportHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for handling report messages.  <a href="classts_1_1_report_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for event reporting and monitoring.  <a href="classts_1_1_report_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_resident_buffer.html">ResidentBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of memory buffer locked in physical memory.  <a href="classts_1_1_resident_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_ring_node.html">RingNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for objects being part of a ring, ie.  <a href="classts_1_1_ring_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_access_date.html">SafeAccessDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a SafeAccess date.  <a href="classts_1_1_safe_access_date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template safe pointer (reference-counted, auto-delete, thread-safe).  <a href="classts_1_1_safe_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_satellite_delivery_system_descriptor.html">SatelliteDeliverySystemDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a satellite_delivery_system_descriptor.  <a href="classts_1_1_satellite_delivery_system_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_scrambling.html">Scrambling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-CSA (Digital Video Broadcasting Common <a class="el" href="classts_1_1_scrambling.html" title="DVB-CSA (Digital Video Broadcasting Common Scrambling Algorithm). ">Scrambling</a> Algorithm).  <a href="classts_1_1_scrambling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_d_t.html">SDT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="classts_1_1_s_d_t_1_1_service.html" title="Description of a service. ">Service</a> Description Table (<a class="el" href="classts_1_1_s_d_t.html" title="Representation of a Service Description Table (SDT). ">SDT</a>).  <a href="classts_1_1_s_d_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_section.html">Section</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of MPEG PSI/SI sections.  <a href="classts_1_1_section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_section_demux.html">SectionDemux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class rebuilds MPEG tables and sections from TS packets.  <a href="classts_1_1_section_demux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_section_handler_interface.html">SectionHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to receive MPEG <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">Section</a> from a <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">SectionDemux</a>.  <a href="classts_1_1_section_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_section_provider_interface.html">SectionProviderInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for classes which provides MPEG <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">Section</a> into a <a class="el" href="classts_1_1_packetizer.html" title="Packetization of MPEG sections into Transport Stream packets. ">Packetizer</a>.  <a href="classts_1_1_section_provider_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_service.html">Service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe a DVB service.  <a href="classts_1_1_service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_service_descriptor.html">ServiceDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a service_descriptor.  <a href="classts_1_1_service_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_service_list_descriptor.html">ServiceListDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a service_list_descriptor.  <a href="classts_1_1_service_list_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_severity.html">Severity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message severity.  <a href="structts_1_1_severity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_h_a1.html">SHA1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-1 hash.  <a href="classts_1_1_s_h_a1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_h_a256.html">SHA256</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-256 hash.  <a href="classts_1_1_s_h_a256.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_h_a512.html">SHA512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-512 hash.  <a href="classts_1_1_s_h_a512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_shared_library.html">SharedLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared library handling (.so on UNIX, DLL on Windows).  <a href="classts_1_1_shared_library.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_short_event_descriptor.html">ShortEventDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an short_event_descriptor.  <a href="classts_1_1_short_event_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_signal_allocator.html">SignalAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate POSIX real-time signal numbers (Linux-specific).  <a href="classts_1_1_signal_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_simul_crypt_date.html">SimulCryptDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a date in DVB SimulCrypt protocols (ETSI TS 103 197).  <a href="classts_1_1_simul_crypt_date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_singleton_manager.html">SingletonManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for singleton definition.  <a href="classts_1_1_singleton_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_sink_enum_media_types.html">SinkEnumMediaTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_sink_enum_media_types.html" title="SinkEnumMediaTypes, enumerator returned by ::IPin::EnumMediaTypes (Windows-specific). ">SinkEnumMediaTypes</a>, enumerator returned by ::IPin::EnumMediaTypes (Windows-specific).  <a href="classts_1_1_sink_enum_media_types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_sink_enum_pins.html">SinkEnumPins</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_sink_enum_pins.html" title="SinkEnumPins, enumerator returned by ::IBaseFilter::EnumPins (Windows-specific). ">SinkEnumPins</a>, enumerator returned by ::IBaseFilter::EnumPins (Windows-specific).  <a href="classts_1_1_sink_enum_pins.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_sink_filter.html">SinkFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DirectShow sink filter (Windows-specific).  <a href="classts_1_1_sink_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_sink_pin.html">SinkPin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_sink_pin.html" title="SinkPin, input pin for SinkFilter (Windows-specific). ">SinkPin</a>, input pin for <a class="el" href="classts_1_1_sink_filter.html" title="The DirectShow sink filter (Windows-specific). ">SinkFilter</a> (Windows-specific).  <a href="classts_1_1_sink_pin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_socket_address.html">SocketAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket address class (IP v4 address &amp; port).  <a href="classts_1_1_socket_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_s_u_data_broadcast_id_descriptor.html">SSUDataBroadcastIdDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a data_broadcast_id_descriptor for system software update.  <a href="classts_1_1_s_s_u_data_broadcast_id_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_s_u_linkage_descriptor.html">SSULinkageDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a linkage_descriptor for system software update.  <a href="classts_1_1_s_s_u_linkage_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_standalone_table_demux.html">StandaloneTableDemux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">SectionDemux</a> which extracts MPEG tables without external handler.  <a href="classts_1_1_standalone_table_demux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_t_d_descriptor.html">STDDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an STD_descriptor.  <a href="classts_1_1_s_t_d_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_stream_identifier_descriptor.html">StreamIdentifierDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a stream_identifier_descriptor.  <a href="classts_1_1_stream_identifier_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_subtitling_descriptor.html">SubtitlingDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a subtitling_descriptor.  <a href="classts_1_1_subtitling_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_supplementary_audio_descriptor.html">SupplementaryAudioDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a supplementary_audio_descriptor.  <a href="classts_1_1_supplementary_audio_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_system_monitor.html">SystemMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitoring thread for system resources used by the application.  <a href="classts_1_1_system_monitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_system_random_generator.html">SystemRandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">System-provided PRNG (pseudo-random numbers generator).  <a href="classts_1_1_system_random_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_table_handler_interface.html">TableHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table handler interface.  <a href="classts_1_1_table_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tables_display.html">TablesDisplay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to display PSI/SI tables.  <a href="classts_1_1_tables_display.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tables_display_args.html">TablesDisplayArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line arguments to display PSI/SI tables.  <a href="classts_1_1_tables_display_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tables_logger.html">TablesLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class logs sections and tables.  <a href="classts_1_1_tables_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tables_logger_args.html">TablesLoggerArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line arguments for the class <a class="el" href="classts_1_1_tables_logger.html" title="This class logs sections and tables. ">TablesLogger</a>.  <a href="classts_1_1_tables_logger_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_c_p_connection.html">TCPConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a TCP/IP session.  <a href="classts_1_1_t_c_p_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_c_p_server.html">TCPServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a TCP/IP server.  <a href="classts_1_1_t_c_p_server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_c_p_socket.html">TCPSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for TCP/IP sockets.  <a href="classts_1_1_t_c_p_socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_d_e_s.html">TDES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triple-DES block cipher.  <a href="classts_1_1_t_d_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_d_t.html">TDT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> &amp; Date Table (<a class="el" href="classts_1_1_t_d_t.html" title="Representation of a Time &amp; Date Table (TDT) ">TDT</a>)  <a href="classts_1_1_t_d_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_teletext_descriptor.html">TeletextDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a teletext_descriptor.  <a href="classts_1_1_teletext_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_telnet_connection.html">TelnetConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a half-duplex line oriented telnet connection.  <a href="classts_1_1_telnet_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_terrestrial_delivery_system_descriptor.html">TerrestrialDeliverySystemDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a terrestrial_delivery_system_descriptor.  <a href="classts_1_1_terrestrial_delivery_system_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for threads.  <a href="classts_1_1_thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_thread_attributes.html">ThreadAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of attributes for a thread object (<a class="el" href="classts_1_1_thread.html" title="Base class for threads. ">ts::Thread</a>).  <a href="classts_1_1_thread_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_time.html">Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a></code> class implements a basic representation of time.  <a href="classts_1_1_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_l_v_syntax.html">TLVSyntax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Tag, Length, Value (TVL) syntax.  <a href="classts_1_1_t_l_v_syntax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_o_t.html">TOT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> Offset Table (<a class="el" href="classts_1_1_t_o_t.html" title="Representation of a Time Offset Table (TOT) ">TOT</a>)  <a href="classts_1_1_t_o_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_transport_stream_id.html">TransportStreamId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of a transport stream.  <a href="structts_1_1_transport_stream_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_analyzer.html">TSAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which analyzes a complete transport stream.  <a href="classts_1_1_t_s_analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_analyzer_options.html">TSAnalyzerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report options for the class <a class="el" href="classts_1_1_t_s_analyzer.html" title="A class which analyzes a complete transport stream. ">TSAnalyzer</a>.  <a href="classts_1_1_t_s_analyzer_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_analyzer_report.html">TSAnalyzerReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subclass of <a class="el" href="classts_1_1_t_s_analyzer.html" title="A class which analyzes a complete transport stream. ">TSAnalyzer</a> with reporting capabilities.  <a href="classts_1_1_t_s_analyzer_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_d_t.html">TSDT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Transport Stream Description Table (<a class="el" href="classts_1_1_t_s_d_t.html" title="Representation of a Transport Stream Description Table (TSDT) ">TSDT</a>)  <a href="classts_1_1_t_s_d_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_file_input.html">TSFileInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport Stream file input.  <a href="classts_1_1_t_s_file_input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_file_input_buffered.html">TSFileInputBuffered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport stream file input with a seekable buffer.  <a href="classts_1_1_t_s_file_input_buffered.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_file_output.html">TSFileOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport Stream file output.  <a href="classts_1_1_t_s_file_output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_file_output_resync.html">TSFileOutputResync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized form of transport stream output file with resynchronized PID and continuity counters.  <a href="classts_1_1_t_s_file_output_resync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_p.html">TSP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_t_s_p.html" title="TSP callback for plugins. ">TSP</a> callback for plugins.  <a href="classts_1_1_t_s_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structts_1_1_t_s_packet.html">TSPacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic definition of an MPEG-2 transport packet.  <a href="structts_1_1_t_s_packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_t_s_scanner.html">TSScanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which scans the services of a transport stream.  <a href="classts_1_1_t_s_scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner.html">Tuner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a DVB tuner.  <a href="classts_1_1_tuner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_args.html">TunerArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line arguments for DVB tuners.  <a href="classts_1_1_tuner_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for DVB tuners parameters.  <a href="classts_1_1_tuner_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters_a_t_s_c.html">TunerParametersATSC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATSC (terrestrial, cable) tuners parameters.  <a href="classts_1_1_tuner_parameters_a_t_s_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters_bitrate_diff_d_v_b_t.html">TunerParametersBitrateDiffDVBT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of DVB-T tuners parameters with an offset between a target bitrate and their theoretical bitrate.  <a href="classts_1_1_tuner_parameters_bitrate_diff_d_v_b_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters_d_v_b_c.html">TunerParametersDVBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-C (cable, QAM) tuners parameters.  <a href="classts_1_1_tuner_parameters_d_v_b_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters_d_v_b_s.html">TunerParametersDVBS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-S / DVB-S2 (satellite) tuners parameters.  <a href="classts_1_1_tuner_parameters_d_v_b_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_tuner_parameters_d_v_b_t.html">TunerParametersDVBT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-T (terrestrial, OFDM) tuners parameters.  <a href="classts_1_1_tuner_parameters_d_v_b_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_d_p_socket.html">UDPSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP Socket.  <a href="classts_1_1_u_d_p_socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_i_d.html">UID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singleton which generates 64-bit <a class="el" href="classts_1_1_u_i_d.html" title="A singleton which generates 64-bit UID, unique integer. ">UID</a>, unique integer.  <a href="classts_1_1_u_i_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_unimplemented_method.html">UnimplementedMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unimplemented method error.  <a href="classts_1_1_unimplemented_method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_uninitialized_variable.html">UninitializedVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialized variable error.  <a href="classts_1_1_uninitialized_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_user_interrupt.html">UserInterrupt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this class handles the Ctrl+C user interrupt.  <a href="classts_1_1_user_interrupt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class which defines a <em>variable</em> which can be either initialized or uninitialized.  <a href="classts_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_v_b_i_data_descriptor.html">VBIDataDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a VBI_data_descriptor.  <a href="classts_1_1_v_b_i_data_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_v_b_i_teletext_descriptor.html">VBITeletextDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a VBI_teletext_descriptor.  <a href="classts_1_1_v_b_i_teletext_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_viaccess_date.html">ViaccessDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a Viaccess date.  <a href="classts_1_1_viaccess_date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_video_attributes.html">VideoAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video attributes for MPEG-1 and MPEG-2.  <a href="classts_1_1_video_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8e1efa16f03c7f160b51fec179f25242"><td class="memItemLeft" align="right" valign="top"><a id="a8e1efa16f03c7f160b51fec179f25242"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_abstract_descriptor.html">AbstractDescriptor</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8e1efa16f03c7f160b51fec179f25242">AbstractDescriptorPtr</a></td></tr>
<tr class="memdesc:a8e1efa16f03c7f160b51fec179f25242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_abstract_descriptor.html" title="Abstract base class for MPEG PSI/SI descriptors. ">AbstractDescriptor</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a8e1efa16f03c7f160b51fec179f25242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4b1374f444f2e5aaa0a036ecdb1b83"><td class="memItemLeft" align="right" valign="top"><a id="acb4b1374f444f2e5aaa0a036ecdb1b83"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_abstract_table.html">AbstractTable</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acb4b1374f444f2e5aaa0a036ecdb1b83">AbstractTablePtr</a></td></tr>
<tr class="memdesc:acb4b1374f444f2e5aaa0a036ecdb1b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_abstract_table.html" title="Abstract base class for MPEG PSI/SI tables. ">AbstractTable</a> (not thread-safe) <br /></td></tr>
<tr class="separator:acb4b1374f444f2e5aaa0a036ecdb1b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bcd1cca716a87efa78c1c20c8e4d77"><td class="memItemLeft" align="right" valign="top"><a id="ad3bcd1cca716a87efa78c1c20c8e4d77"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_binary_table.html">BinaryTable</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad3bcd1cca716a87efa78c1c20c8e4d77">BinaryTablePtr</a></td></tr>
<tr class="memdesc:ad3bcd1cca716a87efa78c1c20c8e4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_binary_table.html" title="Representation of MPEG PSI/SI tables in binary form (ie. ">BinaryTable</a> (not thread-safe) <br /></td></tr>
<tr class="separator:ad3bcd1cca716a87efa78c1c20c8e4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7017b77e378ebf4ac50e83a3b15ee0c4"><td class="memItemLeft" align="right" valign="top"><a id="a7017b77e378ebf4ac50e83a3b15ee0c4"></a>
typedef std::vector&lt; <a class="el" href="namespacets.html#ad3bcd1cca716a87efa78c1c20c8e4d77">BinaryTablePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7017b77e378ebf4ac50e83a3b15ee0c4">BinaryTablePtrVector</a></td></tr>
<tr class="memdesc:a7017b77e378ebf4ac50e83a3b15ee0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classts_1_1_binary_table.html" title="Representation of MPEG PSI/SI tables in binary form (ie. ">BinaryTable</a> pointers. <br /></td></tr>
<tr class="separator:a7017b77e378ebf4ac50e83a3b15ee0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab979eee2ee2eef80c6f655146d4c3961"><td class="memItemLeft" align="right" valign="top"><a id="ab979eee2ee2eef80c6f655146d4c3961"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a></td></tr>
<tr class="memdesc:ab979eee2ee2eef80c6f655146d4c3961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitrate in bits/second. <br /></td></tr>
<tr class="separator:ab979eee2ee2eef80c6f655146d4c3961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542787fc9df4215c6c94d816c50c818"><td class="memItemLeft" align="right" valign="top"><a id="a1542787fc9df4215c6c94d816c50c818"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1542787fc9df4215c6c94d816c50c818">ByteBlockPtr</a></td></tr>
<tr class="memdesc:a1542787fc9df4215c6c94d816c50c818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_byte_block.html" title="Definition of a generic block of bytes. ">ByteBlock</a>, not thread-safe. <br /></td></tr>
<tr class="separator:a1542787fc9df4215c6c94d816c50c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7328925ebbb18a61eb2e84fa56d138de"><td class="memItemLeft" align="right" valign="top"><a id="a7328925ebbb18a61eb2e84fa56d138de"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7328925ebbb18a61eb2e84fa56d138de">ByteBlockPtrMT</a></td></tr>
<tr class="memdesc:a7328925ebbb18a61eb2e84fa56d138de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_byte_block.html" title="Definition of a generic block of bytes. ">ByteBlock</a>, thread-safe (MT = multi-thread). <br /></td></tr>
<tr class="separator:a7328925ebbb18a61eb2e84fa56d138de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfbce1e2e9bd3ae45cb52651f029b6d"><td class="memItemLeft" align="right" valign="top"><a id="a2cfbce1e2e9bd3ae45cb52651f029b6d"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_c_a_descriptor.html">CADescriptor</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2cfbce1e2e9bd3ae45cb52651f029b6d">CADescriptorPtr</a></td></tr>
<tr class="memdesc:a2cfbce1e2e9bd3ae45cb52651f029b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to a <a class="el" href="classts_1_1_c_a_descriptor.html" title="Representation of a generic CA_descriptor. ">CADescriptor</a> (thread-safe). <br /></td></tr>
<tr class="separator:a2cfbce1e2e9bd3ae45cb52651f029b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af043fba2c2a5edefb756223dd56ffa96"><td class="memItemLeft" align="right" valign="top">typedef std::bitset&lt; size_t(<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afabb6e9da27299136faabde20bc6f7b0c5">DS_COUNT</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af043fba2c2a5edefb756223dd56ffa96">DeliverySystemSet</a></td></tr>
<tr class="memdesc:af043fba2c2a5edefb756223dd56ffa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of delivery system values (<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af" title="Delivery systems. ">ts::DeliverySystem</a>).  <a href="#af043fba2c2a5edefb756223dd56ffa96">More...</a><br /></td></tr>
<tr class="separator:af043fba2c2a5edefb756223dd56ffa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cae245ae790bbdb6deef97813f2453"><td class="memItemLeft" align="right" valign="top"><a id="a66cae245ae790bbdb6deef97813f2453"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_descriptor.html">Descriptor</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a66cae245ae790bbdb6deef97813f2453">DescriptorPtr</a></td></tr>
<tr class="memdesc:a66cae245ae790bbdb6deef97813f2453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">Descriptor</a> (not thread-safe) <br /></td></tr>
<tr class="separator:a66cae245ae790bbdb6deef97813f2453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46fe2a5ecc6c2f806f08d9fcbcaf600"><td class="memItemLeft" align="right" valign="top"><a id="ae46fe2a5ecc6c2f806f08d9fcbcaf600"></a>
typedef std::vector&lt; <a class="el" href="namespacets.html#a66cae245ae790bbdb6deef97813f2453">DescriptorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae46fe2a5ecc6c2f806f08d9fcbcaf600">DescriptorPtrVector</a></td></tr>
<tr class="memdesc:ae46fe2a5ecc6c2f806f08d9fcbcaf600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">Descriptor</a> pointers Use class <a class="el" href="classts_1_1_descriptor_list.html" title="List of MPEG PSI/SI descriptors. ">DescriptorList</a> for advanced features. <br /></td></tr>
<tr class="separator:ae46fe2a5ecc6c2f806f08d9fcbcaf600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d34ed2bcf670e7b2a310f660ca900ee"><td class="memItemLeft" align="right" valign="top"><a id="a6d34ed2bcf670e7b2a310f660ca900ee"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6d34ed2bcf670e7b2a310f660ca900ee">DID</a></td></tr>
<tr class="memdesc:a6d34ed2bcf670e7b2a310f660ca900ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">Descriptor</a> identifier. <br /></td></tr>
<tr class="separator:a6d34ed2bcf670e7b2a310f660ca900ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193fcb3d69633d775555333ad51c9cc1"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a193fcb3d69633d775555333ad51c9cc1">Environment</a></td></tr>
<tr class="memdesc:a193fcb3d69633d775555333ad51c9cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a container type holding all environment variables.  <a href="#a193fcb3d69633d775555333ad51c9cc1">More...</a><br /></td></tr>
<tr class="separator:a193fcb3d69633d775555333ad51c9cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="memItemLeft" align="right" valign="top"><a id="a1c5cb8c11b9201fea00bbc07569b1bc4"></a>
typedef platform_specific&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a></td></tr>
<tr class="memdesc:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type for operating system error codes. <br /></td></tr>
<tr class="separator:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62844508c6ce5b912390af83157c7eb"><td class="memItemLeft" align="right" valign="top"><a id="aa62844508c6ce5b912390af83157c7eb"></a>
typedef std::vector&lt; <a class="el" href="structts_1_1_file_name_rate.html">FileNameRate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa62844508c6ce5b912390af83157c7eb">FileNameRateVector</a></td></tr>
<tr class="memdesc:aa62844508c6ce5b912390af83157c7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of file names and an associated repetition rates. <br /></td></tr>
<tr class="separator:aa62844508c6ce5b912390af83157c7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6825a1db0e62afdf5e6ccb895a28c020"><td class="memItemLeft" align="right" valign="top"><a id="a6825a1db0e62afdf5e6ccb895a28c020"></a>
typedef std::vector&lt; <a class="el" href="classts_1_1_i_p_address.html">IPAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6825a1db0e62afdf5e6ccb895a28c020">IPAddressVector</a></td></tr>
<tr class="memdesc:a6825a1db0e62afdf5e6ccb895a28c020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of IP addresses. <br /></td></tr>
<tr class="separator:a6825a1db0e62afdf5e6ccb895a28c020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996c4337196115e063c7b91bf79510e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae996c4337196115e063c7b91bf79510e">MicroSecond</a></td></tr>
<tr class="memdesc:ae996c4337196115e063c7b91bf79510e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of microseconds.  <a href="#ae996c4337196115e063c7b91bf79510e">More...</a><br /></td></tr>
<tr class="separator:ae996c4337196115e063c7b91bf79510e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a></td></tr>
<tr class="memdesc:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of milliseconds.  <a href="#a2c690abc5d90fe5ba7c3ec0237afc348">More...</a><br /></td></tr>
<tr class="separator:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd890ba84c12ced734201afae32a3e95"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">NanoSecond</a></td></tr>
<tr class="memdesc:acd890ba84c12ced734201afae32a3e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of nanoseconds.  <a href="#acd890ba84c12ced734201afae32a3e95">More...</a><br /></td></tr>
<tr class="separator:acd890ba84c12ced734201afae32a3e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c2950340ed7ec04326cd8c1827bccd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classts_1_1_gen_tab_plugin.html">GenTabPlugin</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a56c2950340ed7ec04326cd8c1827bccd">NewGenTabPluginProfile</a>) ()</td></tr>
<tr class="memdesc:a56c2950340ed7ec04326cd8c1827bccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tsgentab plugin interface profile.  <a href="#a56c2950340ed7ec04326cd8c1827bccd">More...</a><br /></td></tr>
<tr class="separator:a56c2950340ed7ec04326cd8c1827bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0db0ec9658176bb813bf254c58f2250"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classts_1_1_input_plugin.html">InputPlugin</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac0db0ec9658176bb813bf254c58f2250">NewInputProfile</a>) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td></tr>
<tr class="memdesc:ac0db0ec9658176bb813bf254c58f2250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input plugin interface profile.  <a href="#ac0db0ec9658176bb813bf254c58f2250">More...</a><br /></td></tr>
<tr class="separator:ac0db0ec9658176bb813bf254c58f2250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9749300d3760618455d38fa9d5aac02b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classts_1_1_output_plugin.html">OutputPlugin</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9749300d3760618455d38fa9d5aac02b">NewOutputProfile</a>) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td></tr>
<tr class="memdesc:a9749300d3760618455d38fa9d5aac02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output plugin interface profile.  <a href="#a9749300d3760618455d38fa9d5aac02b">More...</a><br /></td></tr>
<tr class="separator:a9749300d3760618455d38fa9d5aac02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b051128af01bb7efab96954943abc4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classts_1_1_processor_plugin.html">ProcessorPlugin</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab4b051128af01bb7efab96954943abc4">NewProcessorProfile</a>) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td></tr>
<tr class="memdesc:ab4b051128af01bb7efab96954943abc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet processing plugin interface profile.  <a href="#ab4b051128af01bb7efab96954943abc4">More...</a><br /></td></tr>
<tr class="separator:ab4b051128af01bb7efab96954943abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9230eac85f53f8285807d94c99c80f"><td class="memItemLeft" align="right" valign="top"><a id="aef9230eac85f53f8285807d94c99c80f"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_object.html">Object</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aef9230eac85f53f8285807d94c99c80f">ObjectPtr</a></td></tr>
<tr class="memdesc:aef9230eac85f53f8285807d94c99c80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> (thread-safe). <br /></td></tr>
<tr class="separator:aef9230eac85f53f8285807d94c99c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdec7a120783847f53fbf71e5eb49f6"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a></td></tr>
<tr class="memdesc:a9cdec7a120783847f53fbf71e5eb49f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Transport Stream packets.  <a href="#a9cdec7a120783847f53fbf71e5eb49f6">More...</a><br /></td></tr>
<tr class="separator:a9cdec7a120783847f53fbf71e5eb49f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a8367d7529bc4d441c8e4e61e31984"><td class="memItemLeft" align="right" valign="top"><a id="ab9a8367d7529bc4d441c8e4e61e31984"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab9a8367d7529bc4d441c8e4e61e31984">PDS</a></td></tr>
<tr class="memdesc:ab9a8367d7529bc4d441c8e4e61e31984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private data specifier. <br /></td></tr>
<tr class="separator:ab9a8367d7529bc4d441c8e4e61e31984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689e9f756feec0360be6f7836623531"><td class="memItemLeft" align="right" valign="top"><a id="a0689e9f756feec0360be6f7836623531"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_p_e_s_packet.html">PESPacket</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0689e9f756feec0360be6f7836623531">PESPacketPtr</a></td></tr>
<tr class="memdesc:a0689e9f756feec0360be6f7836623531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_p_e_s_packet.html" title="Representation of MPEG PES packets. ">PESPacket</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a0689e9f756feec0360be6f7836623531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f4de757ad85d084f940278e6e202a"><td class="memItemLeft" align="right" valign="top"><a id="a6e4f4de757ad85d084f940278e6e202a"></a>
typedef std::vector&lt; <a class="el" href="namespacets.html#a0689e9f756feec0360be6f7836623531">PESPacketPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6e4f4de757ad85d084f940278e6e202a">PESPacketPtrVector</a></td></tr>
<tr class="memdesc:a6e4f4de757ad85d084f940278e6e202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classts_1_1_p_e_s_packet.html" title="Representation of MPEG PES packets. ">PESPacket</a> safe pointers. <br /></td></tr>
<tr class="separator:a6e4f4de757ad85d084f940278e6e202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2f5f7d7011d87cc23a8fef31958dc"><td class="memItemLeft" align="right" valign="top"><a id="a90e2f5f7d7011d87cc23a8fef31958dc"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a90e2f5f7d7011d87cc23a8fef31958dc">PID</a></td></tr>
<tr class="memdesc:a90e2f5f7d7011d87cc23a8fef31958dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PID value. <br /></td></tr>
<tr class="separator:a90e2f5f7d7011d87cc23a8fef31958dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1f2460b477bc70d2e394204a2c09b"><td class="memItemLeft" align="right" valign="top">typedef std::bitset&lt; <a class="el" href="namespacets.html#aa81895f76b9b59ec18ee3205408aa5e4">PID_MAX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab1d1f2460b477bc70d2e394204a2c09b">PIDSet</a></td></tr>
<tr class="memdesc:ab1d1f2460b477bc70d2e394204a2c09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit mask for PID values.  <a href="#ab1d1f2460b477bc70d2e394204a2c09b">More...</a><br /></td></tr>
<tr class="separator:ab1d1f2460b477bc70d2e394204a2c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d5a53ca04175acbd22243acc877c7b"><td class="memItemLeft" align="right" valign="top"><a id="ac7d5a53ca04175acbd22243acc877c7b"></a>
typedef std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IPin &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac7d5a53ca04175acbd22243acc877c7b">PinPtrVector</a></td></tr>
<tr class="memdesc:ac7d5a53ca04175acbd22243acc877c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> pointers to IPin interfaces (Windows-specific). <br /></td></tr>
<tr class="separator:ac7d5a53ca04175acbd22243acc877c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab985fc6a17816d4e8484e70e589338f2"><td class="memItemLeft" align="right" valign="top"><a id="ab985fc6a17816d4e8484e70e589338f2"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_plugin_shared_library.html">PluginSharedLibrary</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab985fc6a17816d4e8484e70e589338f2">PluginSharedLibraryPtr</a></td></tr>
<tr class="memdesc:ab985fc6a17816d4e8484e70e589338f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_plugin_shared_library.html" title="Representation of a TSP plugin shared library. ">PluginSharedLibrary</a> (not thread-safe). <br /></td></tr>
<tr class="separator:ab985fc6a17816d4e8484e70e589338f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0a779c88d4f34f07a5fa01cfcf8526"><td class="memItemLeft" align="right" valign="top"><a id="a8f0a779c88d4f34f07a5fa01cfcf8526"></a>
typedef std::list&lt; <a class="el" href="namespacets.html#a270b42517f6f4a9637724d4afdf88fea">PolledFilePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8f0a779c88d4f34f07a5fa01cfcf8526">PolledFileList</a></td></tr>
<tr class="memdesc:a8f0a779c88d4f34f07a5fa01cfcf8526"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of safe pointers to <a class="el" href="classts_1_1_polled_file.html" title="Description of a polled file. ">PolledFile</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a8f0a779c88d4f34f07a5fa01cfcf8526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270b42517f6f4a9637724d4afdf88fea"><td class="memItemLeft" align="right" valign="top"><a id="a270b42517f6f4a9637724d4afdf88fea"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_polled_file.html">PolledFile</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a270b42517f6f4a9637724d4afdf88fea">PolledFilePtr</a></td></tr>
<tr class="memdesc:a270b42517f6f4a9637724d4afdf88fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to a <a class="el" href="classts_1_1_polled_file.html" title="Description of a polled file. ">PolledFile</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a270b42517f6f4a9637724d4afdf88fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1d7cf3ca2437414d1d4238149a2d5b"><td class="memItemLeft" align="right" valign="top"><a id="ade1d7cf3ca2437414d1d4238149a2d5b"></a>
typedef platform_specific&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ade1d7cf3ca2437414d1d4238149a2d5b">ProcessId</a></td></tr>
<tr class="memdesc:ade1d7cf3ca2437414d1d4238149a2d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type for process identifier. <br /></td></tr>
<tr class="separator:ade1d7cf3ca2437414d1d4238149a2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383b83c689b2fc2cc9d13f3244470e7e"><td class="memItemLeft" align="right" valign="top"><a id="a383b83c689b2fc2cc9d13f3244470e7e"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_p_s_i_logger.html">PSILogger</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a383b83c689b2fc2cc9d13f3244470e7e">PSILoggerPtr</a></td></tr>
<tr class="memdesc:a383b83c689b2fc2cc9d13f3244470e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_p_s_i_logger.html" title="This class logs sections and tables. ">PSILogger</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a383b83c689b2fc2cc9d13f3244470e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38592708fbf21dafd004afa1136586c7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a38592708fbf21dafd004afa1136586c7">Second</a></td></tr>
<tr class="memdesc:a38592708fbf21dafd004afa1136586c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of seconds.  <a href="#a38592708fbf21dafd004afa1136586c7">More...</a><br /></td></tr>
<tr class="separator:a38592708fbf21dafd004afa1136586c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df17732b0b5bb9df67fbedd8c14bb12"><td class="memItemLeft" align="right" valign="top"><a id="a9df17732b0b5bb9df67fbedd8c14bb12"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9df17732b0b5bb9df67fbedd8c14bb12">SectionCounter</a></td></tr>
<tr class="memdesc:a9df17732b0b5bb9df67fbedd8c14bb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of sections. <br /></td></tr>
<tr class="separator:a9df17732b0b5bb9df67fbedd8c14bb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cb16ab224d86bb347f19ceccfb7898"><td class="memItemLeft" align="right" valign="top"><a id="ad1cb16ab224d86bb347f19ceccfb7898"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_section.html">Section</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad1cb16ab224d86bb347f19ceccfb7898">SectionPtr</a></td></tr>
<tr class="memdesc:ad1cb16ab224d86bb347f19ceccfb7898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">Section</a> (not thread-safe). <br /></td></tr>
<tr class="separator:ad1cb16ab224d86bb347f19ceccfb7898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae315a0b27332d67d87076aef85b6ab14"><td class="memItemLeft" align="right" valign="top"><a id="ae315a0b27332d67d87076aef85b6ab14"></a>
typedef std::vector&lt; <a class="el" href="namespacets.html#ad1cb16ab224d86bb347f19ceccfb7898">SectionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae315a0b27332d67d87076aef85b6ab14">SectionPtrVector</a></td></tr>
<tr class="memdesc:ae315a0b27332d67d87076aef85b6ab14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">Section</a> pointers. <br /></td></tr>
<tr class="separator:ae315a0b27332d67d87076aef85b6ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2411a296eb562dba7e8ed86921ca5b0f"><td class="memItemLeft" align="right" valign="top"><a id="a2411a296eb562dba7e8ed86921ca5b0f"></a>
typedef std::list&lt; <a class="el" href="classts_1_1_service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2411a296eb562dba7e8ed86921ca5b0f">ServiceList</a></td></tr>
<tr class="memdesc:a2411a296eb562dba7e8ed86921ca5b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of DVB services. <br /></td></tr>
<tr class="separator:a2411a296eb562dba7e8ed86921ca5b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ecee7c0151ef7b232682d08c571cc9"><td class="memItemLeft" align="right" valign="top"><a id="a98ecee7c0151ef7b232682d08c571cc9"></a>
typedef std::set&lt; <a class="el" href="classts_1_1_service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a98ecee7c0151ef7b232682d08c571cc9">ServiceSet</a></td></tr>
<tr class="memdesc:a98ecee7c0151ef7b232682d08c571cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of DVB services. <br /></td></tr>
<tr class="separator:a98ecee7c0151ef7b232682d08c571cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6689d93d263881b635dbcc8273daaa"><td class="memItemLeft" align="right" valign="top"><a id="a7d6689d93d263881b635dbcc8273daaa"></a>
typedef std::vector&lt; <a class="el" href="classts_1_1_service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7d6689d93d263881b635dbcc8273daaa">ServiceVector</a></td></tr>
<tr class="memdesc:a7d6689d93d263881b635dbcc8273daaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of DVB services. <br /></td></tr>
<tr class="separator:a7d6689d93d263881b635dbcc8273daaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5346c902c2c02fd7fdf27ecbd67e0d7e"><td class="memItemLeft" align="right" valign="top"><a id="a5346c902c2c02fd7fdf27ecbd67e0d7e"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5346c902c2c02fd7fdf27ecbd67e0d7e">SocketErrorCode</a></td></tr>
<tr class="memdesc:a5346c902c2c02fd7fdf27ecbd67e0d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for socket error code. <br /></td></tr>
<tr class="separator:a5346c902c2c02fd7fdf27ecbd67e0d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77205d22f2dbdd9b05890f954048912"><td class="memItemLeft" align="right" valign="top"><a id="ac77205d22f2dbdd9b05890f954048912"></a>
typedef std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac77205d22f2dbdd9b05890f954048912">StringList</a></td></tr>
<tr class="memdesc:ac77205d22f2dbdd9b05890f954048912"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of strings. <br /></td></tr>
<tr class="separator:ac77205d22f2dbdd9b05890f954048912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454b16cac3b52dc4931bfbc02b3cb0c0"><td class="memItemLeft" align="right" valign="top"><a id="a454b16cac3b52dc4931bfbc02b3cb0c0"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a454b16cac3b52dc4931bfbc02b3cb0c0">StringVector</a></td></tr>
<tr class="memdesc:a454b16cac3b52dc4931bfbc02b3cb0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of strings. <br /></td></tr>
<tr class="separator:a454b16cac3b52dc4931bfbc02b3cb0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a></td></tr>
<tr class="memdesc:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent any sub-quantity of seconds.  <a href="#ab310e3cadb18cb3e6e7d1e7bb403d4d8">More...</a><br /></td></tr>
<tr class="separator:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee5a28b364c6e010992a2a976a729e1"><td class="memItemLeft" align="right" valign="top"><a id="adee5a28b364c6e010992a2a976a729e1"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_tables_logger.html">TablesLogger</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#adee5a28b364c6e010992a2a976a729e1">TablesLoggerPtr</a></td></tr>
<tr class="memdesc:adee5a28b364c6e010992a2a976a729e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_tables_logger.html" title="This class logs sections and tables. ">TablesLogger</a> (not thread-safe). <br /></td></tr>
<tr class="separator:adee5a28b364c6e010992a2a976a729e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855b24e25cbd2daefa8e0d97e3e48b4e"><td class="memItemLeft" align="right" valign="top"><a id="a855b24e25cbd2daefa8e0d97e3e48b4e"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_t_c_p_connection.html">TCPConnection</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a855b24e25cbd2daefa8e0d97e3e48b4e">TCPConnectionPtr</a></td></tr>
<tr class="memdesc:a855b24e25cbd2daefa8e0d97e3e48b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to a <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">TCPConnection</a> (not thread-safe). <br /></td></tr>
<tr class="separator:a855b24e25cbd2daefa8e0d97e3e48b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063258e3a3bda3e5bad682899f7a3113"><td class="memItemLeft" align="right" valign="top"><a id="a063258e3a3bda3e5bad682899f7a3113"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_t_c_p_connection.html">TCPConnection</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a063258e3a3bda3e5bad682899f7a3113">TCPConnectionPtrMT</a></td></tr>
<tr class="memdesc:a063258e3a3bda3e5bad682899f7a3113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to a <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">TCPConnection</a> (thread-safe). <br /></td></tr>
<tr class="separator:a063258e3a3bda3e5bad682899f7a3113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd5f064250bef7a92ceabdda5dd29c"><td class="memItemLeft" align="right" valign="top"><a id="a10bd5f064250bef7a92ceabdda5dd29c"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_t_c_p_socket.html">TCPSocket</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a10bd5f064250bef7a92ceabdda5dd29c">TCPSocketPtr</a></td></tr>
<tr class="memdesc:a10bd5f064250bef7a92ceabdda5dd29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to <a class="el" href="classts_1_1_t_c_p_socket.html" title="Base class for TCP/IP sockets. ">TCPSocket</a>, single-threaded. <br /></td></tr>
<tr class="separator:a10bd5f064250bef7a92ceabdda5dd29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbae4128cb4924cdff8ed0b530c635d2"><td class="memItemLeft" align="right" valign="top"><a id="abbae4128cb4924cdff8ed0b530c635d2"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_t_c_p_socket.html">TCPSocket</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abbae4128cb4924cdff8ed0b530c635d2">TCPSocketPtrMT</a></td></tr>
<tr class="memdesc:abbae4128cb4924cdff8ed0b530c635d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to <a class="el" href="classts_1_1_t_c_p_socket.html" title="Base class for TCP/IP sockets. ">TCPSocket</a>, multi-threaded. <br /></td></tr>
<tr class="separator:abbae4128cb4924cdff8ed0b530c635d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2cbf0a41a7db2577a737cc9568e3cb"><td class="memItemLeft" align="right" valign="top"><a id="a3c2cbf0a41a7db2577a737cc9568e3cb"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3c2cbf0a41a7db2577a737cc9568e3cb">TID</a></td></tr>
<tr class="memdesc:a3c2cbf0a41a7db2577a737cc9568e3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table identifier. <br /></td></tr>
<tr class="separator:a3c2cbf0a41a7db2577a737cc9568e3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2327bfc457f4e3d173551d6574adb5"><td class="memItemLeft" align="right" valign="top"><a id="a8e2327bfc457f4e3d173551d6574adb5"></a>
typedef std::vector&lt; <a class="el" href="classts_1_1_t_l_v_syntax.html">TLVSyntax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8e2327bfc457f4e3d173551d6574adb5">TLVSyntaxVector</a></td></tr>
<tr class="memdesc:a8e2327bfc457f4e3d173551d6574adb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of <a class="el" href="classts_1_1_t_l_v_syntax.html" title="Representation of a Tag, Length, Value (TVL) syntax. ">TLVSyntax</a>. <br /></td></tr>
<tr class="separator:a8e2327bfc457f4e3d173551d6574adb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb33fc12be416918a9d249639e0fd8c8"><td class="memItemLeft" align="right" valign="top"><a id="adb33fc12be416918a9d249639e0fd8c8"></a>
typedef std::set&lt; <a class="el" href="structts_1_1_transport_stream_id.html">TransportStreamId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#adb33fc12be416918a9d249639e0fd8c8">TransportStreamIdSet</a></td></tr>
<tr class="memdesc:adb33fc12be416918a9d249639e0fd8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of <a class="el" href="structts_1_1_transport_stream_id.html" title="Identification of a transport stream. ">TransportStreamId</a>. <br /></td></tr>
<tr class="separator:adb33fc12be416918a9d249639e0fd8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a9da79d8044bcdddb318c3a3825b65"><td class="memItemLeft" align="right" valign="top"><a id="af6a9da79d8044bcdddb318c3a3825b65"></a>
typedef std::vector&lt; <a class="el" href="structts_1_1_transport_stream_id.html">TransportStreamId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af6a9da79d8044bcdddb318c3a3825b65">TransportStreamIdVector</a></td></tr>
<tr class="memdesc:af6a9da79d8044bcdddb318c3a3825b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="structts_1_1_transport_stream_id.html" title="Identification of a transport stream. ">TransportStreamId</a>. <br /></td></tr>
<tr class="separator:af6a9da79d8044bcdddb318c3a3825b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa3bb4244d103e8504d07a98e7c6e7"><td class="memItemLeft" align="right" valign="top"><a id="a9eaa3bb4244d103e8504d07a98e7c6e7"></a>
typedef std::vector&lt; <a class="el" href="structts_1_1_t_s_packet.html">TSPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9eaa3bb4244d103e8504d07a98e7c6e7">TSPacketVector</a></td></tr>
<tr class="memdesc:a9eaa3bb4244d103e8504d07a98e7c6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of packets. <br /></td></tr>
<tr class="separator:a9eaa3bb4244d103e8504d07a98e7c6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105f698804900a0f1a1a7e41754ec1c"><td class="memItemLeft" align="right" valign="top"><a id="ac105f698804900a0f1a1a7e41754ec1c"></a>
typedef std::list&lt; <a class="el" href="classts_1_1_tuner_parameters_bitrate_diff_d_v_b_t.html">TunerParametersBitrateDiffDVBT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac105f698804900a0f1a1a7e41754ec1c">TunerParametersBitrateDiffDVBTList</a></td></tr>
<tr class="memdesc:ac105f698804900a0f1a1a7e41754ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="classts_1_1_tuner_parameters_bitrate_diff_d_v_b_t.html" title="A variant of DVB-T tuners parameters with an offset between a target bitrate and their theoretical bi...">TunerParametersBitrateDiffDVBT</a>. <br /></td></tr>
<tr class="separator:ac105f698804900a0f1a1a7e41754ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95070d4f89e857c918f449f9c770afd3"><td class="memItemLeft" align="right" valign="top"><a id="a95070d4f89e857c918f449f9c770afd3"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a>, <a class="el" href="classts_1_1_mutex.html">Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a95070d4f89e857c918f449f9c770afd3">TunerParametersPtr</a></td></tr>
<tr class="memdesc:a95070d4f89e857c918f449f9c770afd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer for <a class="el" href="classts_1_1_tuner_parameters.html" title="Abstract base class for DVB tuners parameters. ">TunerParameters</a> (thread-safe). <br /></td></tr>
<tr class="separator:a95070d4f89e857c918f449f9c770afd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ffb6b302f28bccec06127acbc94ca9"><td class="memItemLeft" align="right" valign="top"><a id="a81ffb6b302f28bccec06127acbc94ca9"></a>
typedef <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; <a class="el" href="classts_1_1_tuner.html">Tuner</a>, <a class="el" href="classts_1_1_null_mutex.html">NullMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a81ffb6b302f28bccec06127acbc94ca9">TunerPtr</a></td></tr>
<tr class="memdesc:a81ffb6b302f28bccec06127acbc94ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe pointer to a DVB tuner (not thread-safe). <br /></td></tr>
<tr class="separator:a81ffb6b302f28bccec06127acbc94ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59eedac3c06259bfe955660fbc964d7"><td class="memItemLeft" align="right" valign="top"><a id="ac59eedac3c06259bfe955660fbc964d7"></a>
typedef std::vector&lt; <a class="el" href="namespacets.html#a81ffb6b302f28bccec06127acbc94ca9">TunerPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac59eedac3c06259bfe955660fbc964d7">TunerPtrVector</a></td></tr>
<tr class="memdesc:ac59eedac3c06259bfe955660fbc964d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of safe pointers to DVB tuners (not thread-safe). <br /></td></tr>
<tr class="separator:ac59eedac3c06259bfe955660fbc964d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acb0d05eb5829cfca3e8cbddb3ea5297a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint8_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#acb0d05eb5829cfca3e8cbddb3ea5297aadd865c554e922bc87e46ef506cab65db">SC_CLEAR</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#acb0d05eb5829cfca3e8cbddb3ea5297aa85da402c9f4f8064bfb39bea12341a87">SC_DVB_RESERVED</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#acb0d05eb5829cfca3e8cbddb3ea5297aab6c2f8efcd745f940043e66cbfe5b97d">SC_EVEN_KEY</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#acb0d05eb5829cfca3e8cbddb3ea5297aaa1b72fa51d8d2cc9b2ea056b807b8635">SC_ODD_KEY</a> = 3
<br />
 }<tr class="memdesc:acb0d05eb5829cfca3e8cbddb3ea5297a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scrambling_control values (used in TS and PES packets headers)  <a href="namespacets.html#acb0d05eb5829cfca3e8cbddb3ea5297a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acb0d05eb5829cfca3e8cbddb3ea5297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527bab7b821ddcd06cec9ee953c67f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a8fb8f085bba8e86e7a051bc7ef647985">PDS_NAGRA</a> = 0x00000009, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a6b556756a51afa9aa9c5af408ad58e5e">PDS_NAGRA_2</a> = 0x0000000A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a9f082e0dbb08a7d81a3baf51146118d0">PDS_NAGRA_3</a> = 0x0000000B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a02fc87186aa6ef5e13115ecd095a5fc0">PDS_NAGRA_4</a> = 0x0000000C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a5919a56e77b3c760c45d62e3a7863a54">PDS_NAGRA_5</a> = 0x0000000D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a998ec8c870daf1febc31daada13fc47f">PDS_TPS</a> = 0x00000010, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3aa7935f7e276a52d3185fc6b7f67fe46e">PDS_EACEM</a> = 0x00000028, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a58039b6e3fc4749508e7d9b918d88938">PDS_EICTA</a> = PDS_EACEM, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a75148d08d494405942f8716665f175c2">PDS_LOGIWAYS</a> = 0x000000A2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a5ba212c1c98888b29fa6e0de352c978a">PDS_CANALPLUS</a> = 0x000000C0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3a5d46f2f177335db690b080c7094688b6">PDS_EUTELSAT</a> = 0x0000055F
<br />
 }<tr class="memdesc:af527bab7b821ddcd06cec9ee953c67f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private data specifier (PDS) values.  <a href="namespacets.html#af527bab7b821ddcd06cec9ee953c67f3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af527bab7b821ddcd06cec9ee953c67f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86644912ed316d3a3109e2c313bf797"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: DID { <br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab2effbf25052322ca83820e2057ccd8e">DID_VIDEO</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a1bc31446e45db604f42d40c8b4a3610b">DID_AUDIO</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2a82ef43f5886937eb14fd035925034b">DID_HIERARCHY</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797add70fd64756039ba418c23f1e05b63df">DID_REGISTRATION</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac5288d63c27f32913565f42a7cd1b975">DID_DATA_ALIGN</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac473c5df3d67cded130240f0414ad0e2">DID_TGT_BG_GRID</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac5b80f99116d302d0a07ab3156f08a20">DID_VIDEO_WIN</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8a86521d8862cc5acb467ca9557c0328">DID_CA</a> = 0x09, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a80bc68e5a5986bce274fd3032be9c208">DID_LANGUAGE</a> = 0x0A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae29909d938f2f477f1bb943b82ca1ab4">DID_SYS_CLOCK</a> = 0x0B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af2f648264d4a0ea40419b6d81f690e6b">DID_MUX_BUF_USE</a> = 0x0C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad81cf58fc33b84f1972ffbc4a08ef3b8">DID_COPYRIGHT</a> = 0x0D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a70a93a464bf67da6fc2b89157d524690">DID_MAX_BITRATE</a> = 0x0E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad717b0f8ca18789e9b26a3c2da1c509a">DID_PRIV_DATA_IND</a> = 0x0F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a10c7eb2671a73cb4c77a060396fc8831">DID_SMOOTH_BUF</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5cbcacf1153ca8056638401567b43283">DID_STD</a> = 0x11, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac9c051117dbd60673517d8360440058a">DID_IBP</a> = 0x12, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6bc7153b7a2aad94f57df9cbed7e10d7">DID_MPEG4_VIDEO</a> = 0x1B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a4dd60f11476e7d65d0d1d3637a07d59e">DID_MPEG4_AUDIO</a> = 0x1C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad09aa07136333b7ca19e0c62dabb417c">DID_IOD</a> = 0x1D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa9e52524f5966f47daa52c6891dc9dc4">DID_SL</a> = 0x1E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a104a61f8b90ef5c6d4051360b3bdf46c">DID_FMC</a> = 0x1F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aacc8a98e295fce907e8d29cc053ea419">DID_EXT_ES_ID</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2c5998e74614ede3310e131ad3293a40">DID_MUXCODE</a> = 0x21, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2f9bd96fab7fd6af98bfa09bdca58f57">DID_FMX_BUFFER_SIZE</a> = 0x22, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8fa0e448959220d3eb3e5335bbf316db">DID_MUX_BUFFER</a> = 0x23, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abf4bbe1f169c2572cbd1e9a77922f1c2">DID_CONTENT_LABELING</a> = 0x24, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad9d7e0029141deee84af5e40d0d25f64">DID_METADATA_ASSOC</a> = 0x25, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad5d91308ac7ee7622686473462f9338b">DID_METADATA</a> = 0x26, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5745172f79735da29b2122c3cf92a603">DID_METADATA_STD</a> = 0x27, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac2da933b4b7bba785aa319691bcaab7c">DID_AVC_VIDEO</a> = 0x28, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0624bacbfb038371a9e6e557f16bce1b">DID_MPEG2_IPMP</a> = 0x29, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa956ff09455f3cd52015e73b2edb31f7">DID_AVC_TIMING_HRD</a> = 0x2A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a272d2353115c65eef5e6430692850fdd">DID_NETWORK_NAME</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797afd40c0e6746750b47a889a7f8b87db10">DID_SERVICE_LIST</a> = 0x41, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6ba3b888ddd63bd6eb37f95f0623341c">DID_STUFFING</a> = 0x42, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7a5f26296d5c60bc41095c7bfb04771d">DID_SAT_DELIVERY</a> = 0x43, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac34d6f896236bb18906079bdeb2f94dc">DID_CABLE_DELIVERY</a> = 0x44, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6b555c15e21a2807f3b9124af39da486">DID_VBI_DATA</a> = 0x45, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a269e89bcc524d433b193f8138e2c2f8e">DID_VBI_TELETEXT</a> = 0x46, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a3b711279dc3c5e2b14ff30fbfe1067c7">DID_BOUQUET_NAME</a> = 0x47, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a9e8ed5f3efdf5ef376f8904422c354ae">DID_SERVICE</a> = 0x48, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7f846280672cc3f82d21753bbad71fd5">DID_COUNTRY_AVAIL</a> = 0x49, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab32d8c68f070879da2143ebb4e6598f0">DID_LINKAGE</a> = 0x4A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a568a3891c1511c225a7faa20427105bd">DID_NVOD_REFERENCE</a> = 0x4B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2af1d6c31d8836d4c5fbc77a6ce3e229">DID_TIME_SHIFT_SERVICE</a> = 0x4C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797acbaa405744d6e79072c4c16cab6d27fb">DID_SHORT_EVENT</a> = 0x4D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abecac052f6146fa5112c1e7e817dcf20">DID_EXTENDED_EVENT</a> = 0x4E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad7a1e105be7cd9a403d1e0e851c40e07">DID_TIME_SHIFT_EVENT</a> = 0x4F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8d04e00d78658868fc9d7cd384402b0b">DID_COMPONENT</a> = 0x50, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a3661962fe63b2ee19c40de0b44f7568a">DID_MOSAIC</a> = 0x51, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab42fa3f6be42e0c46e83cb6b1c5db24b">DID_STREAM_ID</a> = 0x52, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af4d04064001533408cdf256aa3cfd44c">DID_CA_ID</a> = 0x53, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad4d2f30eacc75143ef65900317a1c504">DID_CONTENT</a> = 0x54, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a371432833e8fa2f302ebb438b37ffbed">DID_PARENTAL_RATING</a> = 0x55, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab711e704b83c2e6cebf975e860519414">DID_TELETEXT</a> = 0x56, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa75e6cdf963c6c7d2740367a1db59894">DID_TELEPHONE</a> = 0x57, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a85b6dd671003c7243fb4d550010febc0">DID_LOCAL_TIME_OFFSET</a> = 0x58, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a23e74855e386c285c340c9f54c85d919">DID_SUBTITLING</a> = 0x59, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a41e190ae11ec3be18423079683e8cdd6">DID_TERREST_DELIVERY</a> = 0x5A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a09178207ef07a2a31b749b0e89e025fe">DID_MLINGUAL_NETWORK</a> = 0x5B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8a211c58e2ea2116e97bf0a55f6bf112">DID_MLINGUAL_BOUQUET</a> = 0x5C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad1c90fbcaa307e57d313b8d2f196a70a">DID_MLINGUAL_SERVICE</a> = 0x5D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797acbb9004b2d83226e7a559687c9937af4">DID_MLINGUAL_COMPONENT</a> = 0x5E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7bb89e2ec8e56da6bf019dcd7feaaa37">DID_PRIV_DATA_SPECIF</a> = 0x5F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac62508a1790b47ac49680a94eb9d0cb7">DID_SERVICE_MOVE</a> = 0x60, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae4bd47f9991a7c4ec5508ce619a9e766">DID_SHORT_SMOOTH_BUF</a> = 0x61, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac10736a8898885043d0203b6b0a50c41">DID_FREQUENCY_LIST</a> = 0x62, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa01adab187fc896205a0ba58ebaac167">DID_PARTIAL_TS</a> = 0x63, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa514ee1ebd6451480eff60f288eab0fa">DID_DATA_BROADCAST</a> = 0x64, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a47d9da1700f3d033b8f0a1b7d02008bd">DID_SCRAMBLING</a> = 0x65, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a59048f1e2e39873ab0798ca9e3902df2">DID_DATA_BROADCAST_ID</a> = 0x66, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aeee73d3dc9068d4a9d9020667e051005">DID_TRANSPORT_STREAM</a> = 0x67, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6fb6a7cdef53fe3719b373ccbb810be3">DID_DSNG</a> = 0x68, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abb7214a6c187b036c1af4ddb2e363884">DID_PDC</a> = 0x69, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a33ba6989021d614d2aeea33e7510fbb8">DID_AC3</a> = 0x6A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a790a9b0fe3e2585e597e2621a55474fb">DID_ANCILLARY_DATA</a> = 0x6B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8ce45f6b9ccb7c73beddf39f9135f2be">DID_CELL_LIST</a> = 0x6C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0c502ec558a0e10488551e9ede9ea59b">DID_CELL_FREQ_LINK</a> = 0x6D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797afcefc07be78ebfa60f609227a314cd40">DID_ANNOUNCE_SUPPORT</a> = 0x6E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5e9298a75170d6066dfda611fd065c0e">DID_APPLI_SIGNALLING</a> = 0x6F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae25438926e8e5cc636c28d497ecf9baa">DID_ADAPTFIELD_DATA</a> = 0x70, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a404188e1b6e700dfe88b0a50613ff088">DID_SERVICE_ID</a> = 0x71, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a138b0652e568c26bbe68a48964db2e9c">DID_SERVICE_AVAIL</a> = 0x72, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a4eeb644bef98c14f789cebf6adecec2d">DID_DEFAULT_AUTHORITY</a> = 0x73, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a97395366b9f7dd1bc35f3e2755810f6f">DID_RELATED_CONTENT</a> = 0x74, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6e10f48920d9b40324c7b71eb7d4ed25">DID_TVA_ID</a> = 0x75, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7dc4b8be0006656da97fd8dfd0b1472f">DID_CONTENT_ID</a> = 0x76, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac60e3c13afabd1c7597c3133dd85dfc7">DID_TIME_SLICE_FEC_ID</a> = 0x77, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2639dde2b94888a8e64bb13b48806c60">DID_ECM_REPETITION_RATE</a> = 0x78, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a81eca939426a0d23760a9a83718e669c">DID_S2_SAT_DELIVERY</a> = 0x79, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa5667f7a0eb12f656d033602784226da">DID_ENHANCED_AC3</a> = 0x7A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af7313a07d460d448f21667cfa03854de">DID_DTS</a> = 0x7B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797acc728080a2c6714af8a007c23444bc21">DID_AAC</a> = 0x7C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a44ebe007c396f0663e1d081bcc26ace5">DID_XAIT_LOCATION</a> = 0x7D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5a3459ae4241ba34bce8599e5a8bd8e7">DID_FTA_CONTENT_MGMT</a> = 0x7E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a92a86a67e5972c70354814d376877e52">DID_EXTENSION</a> = 0x7F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797afd2a8afb3099a6153ec474597a4d2077">DID_ATSC_STUFFING</a> = 0X80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a81c493055ea1217a6e7ed5cd7d7da568">DID_AC3_AUDIO_STREAM</a> = 0x81, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2f9a6a552740ac7cee41cf38e4206729">DID_ATSC_PID</a> = 0x85, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a11d3e6b059ef84f818f1ce2dbdfdf9d3">DID_CAPTION</a> = 0x86, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac9471fad8b253efc1308410899196881">DID_CONTENT_ADVIS</a> = 0x87, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a4c815e50661599cdada598a5cbe8e3a2">DID_EXT_CHAN_NAME</a> = 0xA0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7b282b015f8abca55d5724cc1adec6f3">DID_SERV_LOCATION</a> = 0xA1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a3c2a5309542f3755999ac4dcae5f6e53">DID_ATSC_TIME_SHIFT</a> = 0xA2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a14eb6c61f9fcc7dd4dfc9d7f100a6faa">DID_COMPONENT_NAME</a> = 0xA3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8a0dfa2b6c1a4d685f0443dbff833b31">DID_ATSC_DATA_BRDCST</a> = 0xA4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac27c86d2b26dae3701b48b2b6bc35bca">DID_PID_COUNT</a> = 0xA5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abe7a03b298f4d02c213dfdca67a9c3a7">DID_DOWNLOAD</a> = 0xA6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab61412e0cb1734add550d52b741ace9d">DID_MPROTO_ENCAPS</a> = 0xA7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797afec7f185b20b1e5bab26867d4b55b29d">DID_LW_SUBSCRIPTION</a> = 0x81, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a30531dec532de8565e60b571766fdb8a">DID_LW_SCHEDULE</a> = 0xB0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a31aab0c37e8580c2655cfeb700c24603">DID_LW_PRIV_COMPONENT</a> = 0xB1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a18481d5cda727106fa736061cf769ad6">DID_LW_PRIV_LINKAGE</a> = 0xB2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0c8532405be6f48bf8ef6acc4d109cae">DID_LW_CHAPTER</a> = 0xB3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a77aaa644ba49af0b83172bed5ab41763">DID_LW_DRM</a> = 0xB4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab0c6b23afdcbb06edc4963abe63e7cd8">DID_LW_VIDEO_SIZE</a> = 0xB5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a3b2c02552c605df274fcb7da860a3ddc">DID_LW_EPISODE</a> = 0xB6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af82523c15894677ab91e4837ded31f93">DID_LW_PRICE</a> = 0xB7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a1791237efab90807a89a5ff28b6af45c">DID_LW_ASSET_REFERENCE</a> = 0xB8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a93d9c8634555a3dd93c869ae03a74491">DID_LW_CONTENT_CODING</a> = 0xB9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a53484db4ae1f3bbff7fe1d090ff37240">DID_LW_VOD_COMMAND</a> = 0xBA, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7006cd9ceb73d0cca7dec83a953e7714">DID_LW_DELETION_DATE</a> = 0xBB, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab569d4c0d0f7af32b889000deb9cbbb6">DID_LW_PLAY_LIST</a> = 0xBC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aad3da56bca7e52a642ed27457a595921">DID_LW_PLAY_LIST_ENTRY</a> = 0xBD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7c249fb4d36bd96b1e05dfd422576d4e">DID_LW_ORDER_CODE</a> = 0xBE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a42b41533e61fe1a4586ced0c36ad80b7">DID_LW_BOUQUET_REFERENCE</a> = 0xBF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5e0e7ce708c7b6092c0bfaf3231709ff">DID_EUTELSAT_CHAN_NUM</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac65f9add2829fa7e7c1ba048e46f62d7">DID_LOGICAL_CHANNEL_NUM</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a2a53a68c03527f8a1e6c00eb0c94a985">DID_PREF_NAME_LIST</a> = 0x84, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae61025d266ae91b138b1d7054d6d9185">DID_PREF_NAME_ID</a> = 0x85, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aef0b5e0965ac1996efe27fa31c3900bd">DID_EACEM_STREAM_ID</a> = 0x86, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a1ac305f14efb23d55d276fafb3b95db1">DID_HD_SIMULCAST_LCN</a> = 0x88, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0310b81faabaf896e97890baef588bb9">DID_DTG_STREAM_IND</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a686800ff5b2134ab44a105a6d18189df">DID_PIO_OFFSET_TIME</a> = 0X80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6e14f8f7bc9fbb95ed1bd575d403d2e8">DID_LOGICAL_CHANNEL_81</a> = 0x81, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0409e10273a8abde6a20bcb71116527c">DID_PRIVATE2</a> = 0x82, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af0e69e3d74658c8de407ecd8ce41b8c2">DID_LOGICAL_CHANNEL</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa2a0b7c50212d39ed0366d077d97442b">DID_PIO_CONTENT</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a6f6c6adda03725f9495c152e9f298bd1">DID_PIO_LOGO</a> = 0x84, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a11ef0ade4584e0b0bebb1547f05c98ca">DID_ADSL_DELIVERY</a> = 0x85, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a58d5fd611b3e4258efdb15f4af55daf2">DID_PIO_FEE</a> = 0x86, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac6a95ce6c545548cff70ef89286d8d53">DID_PIO_EVENT_RANGE</a> = 0x88, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7045df3c39767fd6a48d21f0d2200224">DID_PIO_COPY_MANAGEMENT</a> = 0x8B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a86b9e6bc741e7f47d5b54ba3588b44e8">DID_PIO_COPY_CONTROL</a> = 0x8C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a275b1b0035798142c76c4f547dc3e0e9">DID_PIO_PPV</a> = 0x8E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae6bbe919c6a08c04d931e95e3b89a24c">DID_PIO_STB_SERVICE_ID</a> = 0x90, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa28575cc3f5307fe81cf9ef6a1443a0e">DID_PIO_MASKING_SERV_ID</a> = 0x91, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a312ffa7f54ad0c8f3d5fb6019a5235cb">DID_PIO_STB_SERVMAP_UPD</a> = 0x92, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a112558a31f852226b041e949c280309a">DID_NEW_SERVICE_LIST</a> = 0x93, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a3b5b74db153e17711afbc3bf45daa99a">DID_MESSAGE_NAGRA</a> = 0x94, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aa728edce83eb10bf24462f5afa7e0dab">DID_ITEM_EVENT</a> = 0xA1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a08dfaac329428c1431571ba028aaa3ea">DID_ITEM_ZAPPING</a> = 0xA2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797afe642776f25cca6ed1e7eb15d11ab0dc">DID_APPLI_MESSAGE</a> = 0xA3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a9eb2f0d2f68ed4e392b5b050c5a84f36">DID_LIST</a> = 0xA4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8907af68f4cad2585a29475ab191941e">DID_KEY_LIST</a> = 0xB0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aae9b6d7306fa7f89d208b7992e40c6d4">DID_PICTURE_SIGNALLING</a> = 0xB1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a36e5409ab3f46aff61300756bd35a01a">DID_COUNTER_BB</a> = 0xBB, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aab098ed1b42c2efe0f8da6253ac8d302">DID_DATA_COMPONENT_BD</a> = 0xBD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a8e703e102818edc38420d5f1e555ab09">DID_SYSTEM_MGMT_BE</a> = 0xBE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abe016f5910b6d77c0d2bfc4b897cca4e">DID_VO_LANGUAGE</a> = 0xC0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a568163bac05a8e012314425a4eea214a">DID_DATA_LIST</a> = 0xC1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0beba6687a0c871a415e8a6d3fcfb5df">DID_APPLI_LIST</a> = 0xC2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aeebae241f653638e3f51ee7bea04e0c9">DID_MESSAGE</a> = 0xC3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5504e21be01569d5ccc1c68601b782f1">DID_FILE</a> = 0xC4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a897e8c8c16cae9ceedddd2850770984d">DID_RADIO_FORMAT</a> = 0xC5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a1dc575dddacb7cfb9e11971c54589577">DID_APPLI_STARTUP</a> = 0xC6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a47e1703fcdaf751cbd173206ab3ce011">DID_PATCH</a> = 0xC7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a253aedb309feb01966741ebcf8215986">DID_LOADER</a> = 0xC8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a58dd0bc2033e18c1b8fb56a2f88714a9">DID_CHANNEL_MAP_UPDATE</a> = 0xC9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abde49a5d2e98089bd4e6b6084c1555fe">DID_PPV</a> = 0xCA, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aadcf0e235474e82d3099d98a5a47dbbc">DID_COUNTER_CB</a> = 0xCB, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7fa96c71804dba8ab3b94e050720cca3">DID_OPERATOR_INFO</a> = 0xCC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af86631b0bcd9d47a60619000eeba1499">DID_SERVICE_DEF_PARAMS</a> = 0xCD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad3cf2d8f05b2c90a6182824a7582f8e1">DID_FINGER_PRINTING</a> = 0xCE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797adf183c732420a7a13e2d2d7722b8d826">DID_FINGER_PRINTING_V2</a> = 0xCF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ab59d3c071cd599c535d53d9cc28ce2a9">DID_CONCEALED_GEO_ZONES</a> = 0xD0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a55314e165adfbc8816a9b300ea2a77c2">DID_COPY_PROTECTION</a> = 0xD1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ae3e365cd6d237935e7d73303ed13d3b7">DID_MG_SUBSCRIPTION</a> = 0xD3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797af136ba6ac6ea37fae7ba00a39fde95f9">DID_CABLE_BACKCH_DELIV</a> = 0xD4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aebe1b3bbc4a5a49ef976c896005a6b98">DID_INTERACT_SNAPSHOT</a> = 0xD5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a359b734d03f766a018eb7423fac78d57">DID_ICON_POSITION</a> = 0xDC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a97d68a598f7deff41914b4b3e3d46795">DID_ICON_PIXMAP</a> = 0xDD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5aa44755143e49bd840c2783c3817373">DID_ZONE_COORDINATE</a> = 0xDE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a23b9219871827fb27b5c05fa21b51524">DID_HD_APP_CONTROL_CODE</a> = 0xDF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abb040861cd912f6b527aad01ac752783">DID_EVENT_REPEAT</a> = 0xE0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a528020d4ccb6716d690d14e568dc83ad">DID_PPV_V2</a> = 0xE1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a802a1804be51d2311f9535a3410f27b0">DID_HYPERLINK_REF</a> = 0xE2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a4214102e15ea7d77070d66c55c7eb47c">DID_SHORT_SERVICE</a> = 0xE4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ac70057864d0ad5e4acb4d03e703b4b87">DID_OPERATOR_TELEPHONE</a> = 0xE5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a42599269bcaeebc3ee99b59bf38c81db">DID_ITEM_REFERENCE</a> = 0xE6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a5868397ea3e6357d8d0735a75b7cc263">DID_MH_PARAMETERS</a> = 0xE9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a54553945a5889256422d7fbcda054cc2">DID_LOGICAL_REFERENCE</a> = 0xED, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a859bb0363447323101946bc0d3e51a54">DID_DATA_VERSION</a> = 0xEE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a215f91319a5aa8fbc0a4c4ea0718e0ee">DID_SERVICE_GROUP</a> = 0xEF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a07e8026c101f61e01d9c23fe0b4ffa35">DID_STREAM_LOC_TRANSP</a> = 0xF0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a0c616fe9ddc183431d3d6e04b1d83d95">DID_DATA_LOCATOR</a> = 0xF1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad2e5f3ec7a15260637772bcec8da2f29">DID_RESIDENT_APP</a> = 0xF2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a738b57b676f86379a8bba33dc891f8fa">DID_RESIDENT_APP_SIGNAL</a> = 0xF3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad4f2eb17a0305a31c9bb4324105c6b14">DID_MH_LOGICAL_REF</a> = 0xF8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797aee6dca68f261e745699ea19f741b542e">DID_RECORD_CONTROL</a> = 0xF9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a136dfd94cb9a4a6b3babdd82680cf124">DID_CMPS_RECORD_CONTROL</a> = 0xFA, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797ad3205e97ffa1ec571b560657bde4d0ac">DID_EPISODE</a> = 0xFB, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a7f7c580734ae097fba71a0419380d1cf">DID_CMP_SELECTION</a> = 0xFC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797a70f1f88abecd2898ac247be9a3a15d55">DID_DATA_COMPONENT_FD</a> = 0xFD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad86644912ed316d3a3109e2c313bf797abf2196ce2a0bc6d8f0f135f4d2903f81">DID_SYSTEM_MGMT_FE</a> = 0xFE
<br />
 }<tr class="memdesc:ad86644912ed316d3a3109e2c313bf797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor tag values (descriptor identification, DID)  <a href="namespacets.html#ad86644912ed316d3a3109e2c313bf797">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad86644912ed316d3a3109e2c313bf797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65eca52660a5db7689e344a97f11ff9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: DID { <br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a9397a430b78b55d37f835d74728543e8">EDID_IMAGE_ICON</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9affefb23a7815791bcb645db083409609">EDID_CPCM_DELIVERY_SIG</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9aaeacf4e235aad61fd96c36970e914b8a">EDID_CP</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a588e5924b959743a8d9cbf65848dd4e1">EDID_CP_IDENTIFIER</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9acbd1a1496c3cced500dceea62015791e">EDID_T2_DELIVERY</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a478132d4a173908575f8724c49d875be">EDID_SH_DELIVERY</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9afbc27a78625c80ea3f0294ab9d70c105">EDID_SUPPL_AUDIO</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9aea7462613ccb6767b78df85323b5c04e">EDID_NETW_CHANGE_NOTIFY</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a450b08037f6eb854bf488f8ac76103e1">EDID_MESSAGE</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a85641ef8137e3d66d33951576305c4f1">EDID_TARGET_REGION</a> = 0x09, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a5fca01deb1c49ab1cbfcd374488cdf2c">EDID_TARGET_REGION_NAME</a> = 0x0A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a7c5e10dc4ed34be2f441f436850ca1ae">EDID_SERVICE_RELOCATED</a> = 0x0B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9ad5644d0fa46993f269f79f6a469cb5a2">EDID_XAIT_PID</a> = 0x0C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a5363b5b0eab1e878abc5900ea5249662">EDID_C2_DELIVERY</a> = 0x0D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9aef307e2fdd7900f0cb62bce164f5c30d">EDID_DTS_HD_AUDIO</a> = 0x0E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9abb53e6f6100eb973cfc5a573a765d94d">EDID_DTS_NEURAL</a> = 0x0F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9add3fc782ad94e94674945585b2a8645f">EDID_VIDEO_DEPTH_RANGE</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9aab6aee86919fa41bf02d77dbdfa48ad8">EDID_T2MI</a> = 0x11, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a2a6a4f046a4750b93e7a78eff14bbe96">EDID_URI_LINKAGE</a> = 0x13, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a56e40ca751a731f315797f9e251b29f7">EDID_CI_ANCILLARY_DATA</a> = 0x14, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a87ce21034a68737e5a20eddeb086133f">EDID_AC4</a> = 0x15, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af65eca52660a5db7689e344a97f11ff9a0ccb2634533c4bd7da02c3b47367c872">EDID_C2_BUNDLE_DELIVERY</a> = 0x16
<br />
 }<tr class="memdesc:af65eca52660a5db7689e344a97f11ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended descriptor tag values (in extension_descriptor)  <a href="namespacets.html#af65eca52660a5db7689e344a97f11ff9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af65eca52660a5db7689e344a97f11ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567862128828cb0aca97f42b61800495"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint8_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a43b03312d6d4c2d01b57841004c8fe93">LINKAGE_INFO</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a7c04c1e1698de9af1e502c1eed34223b">LINKAGE_EPG</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a36158e249137b6ccd3151fb929b781f1">LINKAGE_CA_REPLACE</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495ac62c317896edf1e095f19677bd8cdf8e">LINKAGE_TS_NIT_BAT</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495ae1b8fa9b8378c290d528b9655ae5f229">LINKAGE_SERVICE_REPLACE</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a345ac9d9e6639eb1711312dc55c91d03">LINKAGE_DATA_BROADCAST</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a4456ced5c78ccdb1ad52d7deba6f287e">LINKAGE_RCS_MAP</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495ac774177dd82f17a91f17c46c51438e86">LINKAGE_HAND_OVER</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a5b88d007b85462b3e07a4828dce3433c">LINKAGE_SSU</a> = 0x09, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a43bbc0d543796c9947b0f6170b94bbaf">LINKAGE_SSU_TABLE</a> = 0x0A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a07dbe3437e1105857351731655663b82">LINKAGE_IP_NOTIFY</a> = 0x0B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a567862128828cb0aca97f42b61800495a90eddc622703c3465952fb452cf442d3">LINKAGE_INT_BAT_NIT</a> = 0x0C
<br />
 }<tr class="memdesc:a567862128828cb0aca97f42b61800495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linkage type values (in linkage_descriptor)  <a href="namespacets.html#a567862128828cb0aca97f42b61800495">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a567862128828cb0aca97f42b61800495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b474791d0063369fb7eb5b3c5d9593"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint16_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a5e854bc8b1615bda6a23fad70151c326">DBID_DATA_PIPE</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a3c4667e64a6226fc2f9a8728b37a89aa">DBID_ASYNC_DATA_STREAM</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593ab009ae42169bfbfb58c29edfc1b1e9c0">DBID_SYNC_DATA_STREAM</a> = 0x0003, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a68085ba7aaa707971948593cae187580">DBID_SYNCED_DATA_STREAM</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593ad55f828edd163550e9862ba3f2ed7a3d">DBID_MPE</a> = 0x0005, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a326fddbe00e51a80077b2aaf4877f23e">DBID_DATA_CSL</a> = 0x0006, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a5c4109707c334220f8cd9cab31dcab66">DBID_OBJECT_CSL</a> = 0x0007, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a7e3d371de6aa4711f7d7e9fb19d2c7a9">DBID_ATM</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a12d754fe6d09fbcd01b5bb4510c4bff2">DBID_HP_ASYNC_DATA_STREAM</a> = 0x0009, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a8ed1735a7f3d9752bbe38a03d9341d89">DBID_SSU</a> = 0x000A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593adeffb3a87ddbd34e993e4c706ba7bafc">DBID_IPMAC_NOTIFICATION</a> = 0x000B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a891afde52d176ce396665deeea31b0d5">DBID_MHP_OBJECT_CSL</a> = 0x00F0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593acc126606247f09353b3101ebfc95e8e8">DBID_MHP_MPE</a> = 0x00F1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593accc56d195853b5abbf89cff2ce7ade16">DBID_EUTELSAT_DATA_PIPE</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a31ca12594fb27f27b7380e431b41f780">DBID_EUTELSAT_DATA_STREAM</a> = 0x0101, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a59b33466f7b38189e3314f5c36f266a5">DBID_SAGEM_IP</a> = 0x0102, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a0dd75ef2f7acdf8d5bbc5d1cdde8c881">DBID_BARCO_DATA_BRD</a> = 0x0103, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a82b4aef63934dff2c1fdc06fbe23aea7">DBID_CIBERCITY_MPE</a> = 0x0104, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a0437f4faad02fb77dd2b448d5daeb0c4">DBID_CYBERSAT_MPE</a> = 0x0105, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a7dd399d26567d830e9f07bc5c636672e">DBID_TDN</a> = 0x0106, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593afca579ec0e91401b12c2a519a468de74">DBID_OPENTV_DATA_CSL</a> = 0x0107, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a54916b1110748ecf821c16a05045feaa">DBID_PANASONIC</a> = 0x0108, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a43e0e983e3fd60a45cabc888324ebdc0">DBID_KABEL_DEUTSCHLAND</a> = 0x0109, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a440fffe954dcb6170e7e689793620cfb">DBID_TECHNOTREND</a> = 0x010A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593ab3f83c06663dc1343593f11ce72f5753">DBID_MEDIAHIGHWAY_SSU</a> = 0x010B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a4599d719117300f363db64a26767b174">DBID_GUIDE_PLUS</a> = 0x010C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a3b503c60c8d12691e68ebf8e223661ea">DBID_ACAP_OBJECT_CSL</a> = 0x010D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593aa2df52439d3069a905a1151acdb1c6f0">DBID_MICRONAS</a> = 0x010E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a584717d2c80ab6d7e6bdb00df561d889">DBID_POLSAT</a> = 0x0110, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a83033c28ce1b1eb77d9939a60b3a012c">DBID_DTG</a> = 0x0111, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a711a931e1360897f5c912cd3fa9665d7">DBID_SKYMEDIA</a> = 0x0112, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a1a3f0449a12ddbe4a18b89b8016b7884">DBID_INTELLIBYTE</a> = 0x0113, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a59ff22ab360f9995df498afdadbada2b">DBID_TELEWEB_DATA_CSL</a> = 0x0114, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a15d490344912deab3dd83897548d589a">DBID_TELEWEB_OBJECT_CSL</a> = 0x0115, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593aed3a7671e9722881b76e6fe211b8ee31">DBID_TELEWEB</a> = 0x0116, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a98157cdfc6e2f1ea9e751219e32c543a">DBID_BBC</a> = 0x0117, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593aa9d610022adcfe725a1428b2e38ea7dd">DBID_ELECTRA</a> = 0x0118, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a0037fdd0843f548f9c7082615ddca19f">DBID_BBC_2_3</a> = 0x011A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a6d523bb0eca72dafd66e619f731f0883">DBID_TELETEXT</a> = 0x011B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a59f246b8808845dda6c3d71b1d059630">DBID_SKY_DOWNLOAD_1_5</a> = 0x0120, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a7c83af778ad957fd71022cd7d0f3e862">DBID_ICO</a> = 0x0121, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593afeee380154bc20a319f2880d67db5c96">DBID_CIPLUS_DATA_CSL</a> = 0x0122, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a3405658e49464fdcce06972d52ecb26d">DBID_HBBTV</a> = 0x0123, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a01d7fae99c9336e582fbfb289ceb5157">DBID_ROVI_PREMIUM</a> = 0x0124, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a079d83fe51b6583ceab60f913a9e8c91">DBID_MEDIA_GUIDE</a> = 0x0125, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a59d7346e745f824308d433559e6e4f61">DBID_INVIEW</a> = 0x0126, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593acc92d2c4dd5d3559a62f90ab154a7b79">DBID_BOTECH</a> = 0x0130, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a7f5fa6551086bc48fe5780f4967bc706">DBID_SCILLA_PUSHVOD_CSL</a> = 0x0131, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a8c9c3f6ec6bc5e81db62f2895e934e2b">DBID_CANAL_PLUS</a> = 0x0140, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a6b50db71be608bd959bd7fa3018cf672">DBID_OIPF_OBJECT_CSL</a> = 0x0150, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a124d61536e3fcc9649febc1afa691eeb">DBID_4TV</a> = 0x4444, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a0735d78b67aafbe7a1c7fd2a29bc40e4">DBID_NOKIA_IP_SSU</a> = 0x4E4F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593a899fac929d3280afe18f2e5649366e23">DBID_BBG_DATA_CSL</a> = 0xBBB1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593ae1fe2058832182955710d87c4c00e0b7">DBID_BBG_OBJECT_CSL</a> = 0xBBB2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593abda049b64ab0fdf45a61fd4a2282f523">DBID_BBG</a> = 0xBBBB
<br />
 }<tr class="memdesc:ad3b474791d0063369fb7eb5b3c5d9593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data broadcast id values (in data_broadcast[_id]_descriptor)  <a href="namespacets.html#ad3b474791d0063369fb7eb5b3c5d9593">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad3b474791d0063369fb7eb5b3c5d9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0071f2918a8c95ab8f3c188250ce2b7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint16_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a0071f2918a8c95ab8f3c188250ce2b7faa2d1bf81289ee39f5819366aa003775e">BID_TVNUMERIC</a> = 0x0086, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a0071f2918a8c95ab8f3c188250ce2b7fa3e5052a523c8b6a8bea580345275540b">BID_TVNUMERIC_EUTELSAT</a> = 0xC030, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a0071f2918a8c95ab8f3c188250ce2b7fab2f1ecd8398a5712afd7d79d08f767a0">BID_TVNUMERIC_ASTRA</a> = 0xC031
<br />
 }<tr class="memdesc:a0071f2918a8c95ab8f3c188250ce2b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-assigned Bouquet Identifier values.  <a href="namespacets.html#a0071f2918a8c95ab8f3c188250ce2b7f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0071f2918a8c95ab8f3c188250ce2b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443b2a4f497204a667fde32be9d72277"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint16_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a1183fa7863df85531cc8c790879136cd">CASID_MEDIAGUARD_MIN</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a21faff0f81464fe7ffc1f23920531f1b">CASID_MEDIAGUARD_MAX</a> = 0x01FF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277aaa77af9e1d2faa3a57d1de963cf9f223">CASID_VIACCESS_MIN</a> = 0x0500, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a2872c4929c4ec4a21f7367f8921ada9e">CASID_VIACCESS_MAX</a> = 0x05FF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a6956ef8e23a09136b637dff9f5a6ede9">CASID_NAGRA_MIN</a> = 0x1800, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277aaf747ad50c2a7ac79e63a8c6b89ddc83">CASID_NAGRA_MAX</a> = 0x18FF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a57ff1d43b05d798784bde8aa9e376864">CASID_THALESCRYPT_MIN</a> = 0x4A80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277af5f401cd0482559575e806016d835008">CASID_THALESCRYPT_MAX</a> = 0x4A8F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a443b2a4f497204a667fde32be9d72277a581c463569cc256c895ffd5209d9c059">CASID_SAFEACCESS</a> = 0x4ADC
<br />
 }<tr class="memdesc:a443b2a4f497204a667fde32be9d72277"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-assigned CA System Identifier values.  <a href="namespacets.html#a443b2a4f497204a667fde32be9d72277">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a443b2a4f497204a667fde32be9d72277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e055e7ef7b6e3e2d04a2744b2142cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint16_t { <a class="el" href="namespacets.html#ac7e055e7ef7b6e3e2d04a2744b2142cfa00aaa8dbcc42db0c145597826f6455e6">NID_TNT_FRANCE</a> = 0x20FA
 }<tr class="memdesc:ac7e055e7ef7b6e3e2d04a2744b2142cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DVB-assigned Network Identifier values.  <a href="namespacets.html#ac7e055e7ef7b6e3e2d04a2744b2142cf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac7e055e7ef7b6e3e2d04a2744b2142cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4503aa2186893e4d94ff9d8da88d178"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacets.html#ab4503aa2186893e4d94ff9d8da88d178aa85e5b790ab8964d0073b3c6ab0873a3">OUI_DVB</a> = 0x00015A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab4503aa2186893e4d94ff9d8da88d178ac26d4d80924b3fd601e80125e942a686">OUI_SKARDIN</a> = 0x001222, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab4503aa2186893e4d94ff9d8da88d178a8784c141e8c5ba924a3b8905b79d7dea">OUI_LOGIWAYS</a> = 0x002660
<br />
 }<tr class="memdesc:ab4503aa2186893e4d94ff9d8da88d178"><td class="mdescLeft">&#160;</td><td class="mdescRight">IEEE-assigned Organizationally Unique Identifier (OUI) values.  <a href="namespacets.html#ab4503aa2186893e4d94ff9d8da88d178">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab4503aa2186893e4d94ff9d8da88d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49ea8a46f549e6396e453119f0e6aa2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: PID { <br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a247897773bfc216f2c046b38195994aa">PID_PAT</a> = 0x0000, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2aea1c15792b70c8ac8e0f28d17ad612bb">PID_CAT</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a95ca43dd7ee5ef20d961951fbab7d5dc">PID_TSDT</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2ada7de7f0f513344653d9796e75a35526">PID_NULL</a> = 0x1FFF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2ad5345e400b662b12eb7e01a7a94faec9">PID_NIT</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2adb0d56a42ecb9459abb3d879dd86687e">PID_SDT</a> = 0x0011, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a570a262cd09340e12bc8cda912aab4b6">PID_BAT</a> = 0x0011, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a3d2139a9d1fba9b0eba928caa6a1dbe7">PID_EIT</a> = 0x0012, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a1c18976f7e482541e859767a00085c87">PID_RST</a> = 0x0013, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2ab534380ccdfb86dc5d46d460b3e871aa">PID_TDT</a> = 0x0014, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2ad8e9dc4f984ab0cb88af7b7ff4372206">PID_TOT</a> = 0x0014, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2aa7109e1d319b0fea956f476ab640839a">PID_NETSYNC</a> = 0x0015, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2a8ac76760111c83dc938daeccadccd08e">PID_RNT</a> = 0x0016, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2af9dbd0da20bc2607a66da503a6156605">PID_INBSIGN</a> = 0x001C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2aa7cff244b2a603e58dcd764817e791de">PID_MEASURE</a> = 0x001D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2ad09a2808fe0f840cfb7b3cef9613af65">PID_DIT</a> = 0x001E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2affc18c13f5e9c7a6b213edc46f57f6e8">PID_SIT</a> = 0x001F
<br />
 }<tr class="memdesc:aa49ea8a46f549e6396e453119f0e6aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined PID values.  <a href="namespacets.html#aa49ea8a46f549e6396e453119f0e6aa2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa49ea8a46f549e6396e453119f0e6aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2873593dbf2b644a7963a5591fd2f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint8_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0aa0f6a36cc8fbfa2344b3d46e82f7125d">SID_PSMAP</a> = 0xBC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0afd9302672d7e21f88364a8d4091c6269">SID_PRIV1</a> = 0xBD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0ab453367700ee8313085b61c2b8a73cc4">SID_PAD</a> = 0xBE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a9b14161fc30f1cb696c605a22c09d009">SID_PRIV2</a> = 0xBF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0aa5ecc6e58134957280e191f33290a84f">SID_AUDIO</a> = 0xC0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0af2cc13d3667d6451d3469ab4adf6f0d7">SID_AUDIO_MASK</a> = 0x1F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a5f96a0ced61943cdc0cc820b51d0c112">SID_VIDEO</a> = 0xE0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0ab274521e20ec99ccd72a00b710627e0f">SID_VIDEO_MASK</a> = 0x0F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a150cc72663e7aae27f76d6bcbd9b3168">SID_ECM</a> = 0xF0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a40a18b673f9cb633dfcebbe4c961e0b4">SID_EMM</a> = 0xF1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0ad77a40f3577f34a9d1fbd0117ab6f0f5">SID_DSMCC</a> = 0xF2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0aa01ef4c1fc0a755e5d42a12799e3cbfe">SID_ISO13522</a> = 0xF3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a5164c28edd8c2102faa4dbae73ff14d1">SID_H222_1_A</a> = 0xF4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a579fa3383c3966ebe8c62a83f4072887">SID_H222_1_B</a> = 0xF5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a1fb0d2a298ec82ce5891daa62d0ac52f">SID_H222_1_C</a> = 0xF6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a68df471681803ef2b345592dec12227c">SID_H222_1_D</a> = 0xF7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0ab654873407406b9a14f72aba165fb68b">SID_H222_1_E</a> = 0xF8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a7921b933226968f3a96a736d7617fde3">SID_ANCILLARY</a> = 0xF9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a6b6abcdd9c10f3f4019df7ab02d2dab6">SID_MP4_SLPACK</a> = 0xFA, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a8104c7a3df9982c4b7d5b67b0b88d2dd">SID_MP4_FLEXM</a> = 0xFB, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a745bb782923faec357f6811b1c743135">SID_METADATA</a> = 0xFC, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0add4c5e710d0145683c0f831041b08854">SID_EXTENDED</a> = 0xFD, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a4c443b38b1a84e543e20d57264aa6379">SID_RESERVED</a> = 0xFE, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0a45e7a579bfaacc37834b5f3407be2063">SID_PSDIR</a> = 0xFF
<br />
 }<tr class="memdesc:a6a2873593dbf2b644a7963a5591fd2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream id values, as used in PES header.  <a href="namespacets.html#a6a2873593dbf2b644a7963a5591fd2f0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6a2873593dbf2b644a7963a5591fd2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51658c20180539b0acb147d22f9569e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint8_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0aa962c72069b64268132739e60eab63c9">PST_PICTURE</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a3b5e2914708829d3bd434c81023e7ddc">PST_SLICE_MIN</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a171cad75f3c8738857b2da610a53268e">PST_SLICE_MAX</a> = 0xAF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a1280ff628a7287b540621bad1691d8b6">PST_RESERVED_B0</a> = 0xB0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a191bff851eb433c1a2d3e21efe4019c4">PST_RESERVED_B1</a> = 0xB1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a4cbb234c0af12cb05b8bd3785158ffcc">PST_USER_DATA</a> = 0xB2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0aa5f8b8dbccb4ff0aaf9a97f57e629ee7">PST_SEQUENCE_HEADER</a> = 0xB3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a19dd228424fd6c05dde1b182cf6f9df1">PST_SEQUENCE_ERROR</a> = 0xB4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a56e2e7bacda3411efa9b76ca3f0119ab">PST_EXTENSION</a> = 0xB5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a921847fca66925f1521d797096eed247">PST_RESERVED_B6</a> = 0xB6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0aba3c3c53ff8e2a07e7d107f4c3347a3f">PST_SEQUENCE_END</a> = 0xB7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a56d7048b53be3152ec31bfdaa2dde953">PST_GROUP</a> = 0xB8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a897a95721f8039db7f2ffd85387d7eb5">PST_SYSTEM_MIN</a> = 0xB9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a51658c20180539b0acb147d22f9569e0a2b7cebf5cec0991e74c8f60e0c84da31">PST_SYSTEM_MAX</a> = 0xFF
<br />
 }<tr class="memdesc:a51658c20180539b0acb147d22f9569e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PES start code values.  <a href="namespacets.html#a51658c20180539b0acb147d22f9569e0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a51658c20180539b0acb147d22f9569e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08350e57208be14f8c0fd69df58b0bc4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacets.html#a08350e57208be14f8c0fd69df58b0bc4a71e0c68286f58b045096a9d71bfad098">AR_SQUARE</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a08350e57208be14f8c0fd69df58b0bc4a068d038ff6c970bd591096cb3fda415b">AR_4_3</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a08350e57208be14f8c0fd69df58b0bc4a9cc48b42ff3e6af9537291dc75b509b1">AR_16_9</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a08350e57208be14f8c0fd69df58b0bc4ad6f3b0a4ff44a968d12d334bf6d4d536">AR_221</a> = 4
<br />
 }<tr class="memdesc:a08350e57208be14f8c0fd69df58b0bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aspect ratio values (in MPEG-1/2 video sequence header).  <a href="namespacets.html#a08350e57208be14f8c0fd69df58b0bc4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a08350e57208be14f8c0fd69df58b0bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59385f479bb35e79a614d5536eb24f63"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacets.html#a59385f479bb35e79a614d5536eb24f63af07e44906f4ddd30d5426619509c9055">CHROMA_MONO</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a59385f479bb35e79a614d5536eb24f63a4d4a7f5e3c5dd71d078b044f6fac15fc">CHROMA_420</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a59385f479bb35e79a614d5536eb24f63ad8d76b5e322b2cf47ef3737bf1acbbcb">CHROMA_422</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a59385f479bb35e79a614d5536eb24f63a6050b95b5f50b87f3719cb5ea914e820">CHROMA_444</a> = 3
<br />
 }<tr class="memdesc:a59385f479bb35e79a614d5536eb24f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chroma format values (in MPEG-1/2 video sequence header).  <a href="namespacets.html#a59385f479bb35e79a614d5536eb24f63">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a59385f479bb35e79a614d5536eb24f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d5160a4aca8802098c55c1f8cdb09"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09aea4ef7568d2165e29b795ca912ef8895">AVC_AUT_NON_IDR</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09ab3262e1b6c3eb500fe52ba8b30d27542">AVC_AUT_SLICE_A</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09ae3574939996488e4398da781ef8d9fab">AVC_AUT_SLICE_B</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09ad72b33048deac1217cfcf4fe7f7b6ad5">AVC_AUT_SLICE_C</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a33dace0be8904d109a5b29d6ce45dbf9">AVC_AUT_IDR</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09adeae4a192867c8cdd931f0d88890501f">AVC_AUT_SEI</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a8ee8b0cb11cc0263177791783fb51222">AVC_AUT_SEQPARAMS</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a22a42c47b94933a9cd3aaaf05f3d8f93">AVC_AUT_PICPARAMS</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a85078e1dcebe3ed63ecac0c15785a165">AVC_AUT_DELIMITER</a> = 9, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a5adcd52aea52fd28bdd5f566844130bf">AVC_AUT_END_SEQUENCE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09aa58989fc6de63c8c58fde91a294498d1">AVC_AUT_END_STREAM</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a314551a19951033f2a8ba8415029a59f">AVC_AUT_FILLER</a> = 12, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a027db1c293036f157e88e438eea4fa9d">AVC_AUT_SEQPARAMSEXT</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a8dbaf70e81b36fc2c896e030f43d8881">AVC_AUT_PREFIX</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09ac9127980fd6a04367e5515391df4fbd8">AVC_AUT_SUBSETPARAMS</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a6dc63bf1cca4f89c74b2d560329b6033">AVC_AUT_SLICE_NOPART</a> = 19, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09a6f08eaa4eb0ae489a778a012b9517afe">AVC_AUT_SLICE_SCALE</a> = 20
<br />
 }<tr class="memdesc:a422d5160a4aca8802098c55c1f8cdb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVC access unit types.  <a href="namespacets.html#a422d5160a4aca8802098c55c1f8cdb09">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a422d5160a4aca8802098c55c1f8cdb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3707cedfb26068131a6836830eed63cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint8_t { <br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa4e74688359b33734095fe060587316ff">ST_MPEG1_VIDEO</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa5ea82697b1781cae8923fd879bcf1355">ST_MPEG2_VIDEO</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa141c9f19d26f6c8cafbf9d26666c6b43">ST_MPEG1_AUDIO</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa59f6537e6a8443cca962fcfd05ebe762">ST_MPEG2_AUDIO</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa85964257bebdb3664800a2ede56cc4ec">ST_PRIV_SECT</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa49048b6dac3bba964d813c119f3a0e1f">ST_PES_PRIV</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfac447f599bc69b47e2948ae391908a7d7">ST_MHEG</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa8cb3d0d058ec0e2f8659420490687178">ST_DSMCC</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa263a70d0f816d534387a5396dbddc115">ST_MPEG2_ATM</a> = 0x09, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa31d3b997f9c2a93bfeb60d02303767ae">ST_DSMCC_MPE</a> = 0x0A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa481e217bbe53374c523577e8bc791b46">ST_DSMCC_UN</a> = 0x0B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa0a73b86aa236c3fb798a441c40afecc6">ST_DSMCC_SD</a> = 0x0C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfaa40f49f97d908544e6151715d35c8e80">ST_DSMCC_SECT</a> = 0x0D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa217d57db856a9a7f6339cc1b4cda4679">ST_MPEG2_AUX</a> = 0x0E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa75b8b977e1328dc3dd32389758568655">ST_AAC_AUDIO</a> = 0x0F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa2a0650fafce691dde91ed5f70cf15954">ST_MPEG4_VIDEO</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa62c0d21b7ac66b96d5dd0640b1368c15">ST_MPEG4_AUDIO</a> = 0x11, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa191df8b2216a903570ca02d0deb0b4aa">ST_MPEG4_PES</a> = 0x12, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa8c12c6d6550207d3e9f9aaa65b0b884f">ST_MPEG4_SECT</a> = 0x13, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa195af2918b26d3e571c2ec348e628d40">ST_DSMCC_DLOAD</a> = 0x14, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa790a050daa31d07e4a19691c32932bf8">ST_MDATA_PES</a> = 0x15, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfac7e7c0be665bfa22a5b096ae7bf72da5">ST_MDATA_SECT</a> = 0x16, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfac67f05a00ed6984b8c5fe2d46692cbe1">ST_MDATA_DC</a> = 0x17, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfab1ef8808c0ac4e7ba7eb6ca9b3f6118d">ST_MDATA_OC</a> = 0x18, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa17b676250b644a50324b263b686dbbc8">ST_MDATA_DLOAD</a> = 0x19, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa88799dd392515afd568d8aa685275941">ST_MPEG2_IPMP</a> = 0x1A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfae6c2b09e69687b5f7c42807bdcf8412a">ST_AVC_VIDEO</a> = 0x1B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa99b5bbbb706c491a92890b8b08fa1885">ST_IPMP</a> = 0x7F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfaab39beb9e977a34486a82f64bd0b1620">ST_AC3_AUDIO</a> = 0x81, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3707cedfb26068131a6836830eed63cfa7e763ff014e1ba6e638c423002a71a56">ST_EAC3_AUDIO</a> = 0x87
<br />
 }<tr class="memdesc:a3707cedfb26068131a6836830eed63cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream type values, as used in the PMT.  <a href="namespacets.html#a3707cedfb26068131a6836830eed63cf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3707cedfb26068131a6836830eed63cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56343654e2b01380409afc12dd2b037"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: TID { <br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a96daeb6d4904472be75955446d097f57">TID_PAT</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a13cf559a7a67bf284282b36baa648888">TID_CAT</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a2b77f31e0fd86def5354eecae304e8b1">TID_PMT</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a617c1d6b0e390b0424d73b867cb14dfb">TID_TSDT</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037af363a0c30af78a040124226c6618b244">TID_MP4SDT</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a232f16adc12ccbb3837421e78564133f">TID_MP4ODT</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a423fddcadbe82585d430a50c0f9da73e">TID_MDT</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a6de8575d697d56a785ed22b09210f5ee">TID_DSMCC_MPE</a> = 0x3A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a8b549c5cdb8039f18d5907a9af1b5488">TID_DSMCC_UNM</a> = 0x3B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a30811e76a364da82f7ad318813bfcb4f">TID_DSMCC_DDM</a> = 0x3C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a51c367b7bdf8f263b868a3581c932ba5">TID_DSMCC_SD</a> = 0x3D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a425ccf991a5f5d1d4889f5cc2c23bb84">TID_DSMCC_PD</a> = 0x3E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ad51c95d1eb15054cb4f69437a5207ecf">TID_NULL</a> = 0xFF, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ae15af73528a1290c2e635dc92ea11321">TID_NIT_ACT</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a61be3fb538e1f44da59c03d776ca7543">TID_NIT_OTH</a> = 0x41, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a6a382cc0ea3606e9182985f2a0a473ec">TID_SDT_ACT</a> = 0x42, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a46279362a38fea02569cfd5d585e4873">TID_SDT_OTH</a> = 0x46, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a538224f74a11c7311e8f680ddeb51b8b">TID_BAT</a> = 0x4A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037aedc0a2ab15b5da31db86c8923a6f0330">TID_EIT_PF_ACT</a> = 0x4E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a57d4f3c767d80a3f9f8343bab420a8ac">TID_EIT_PF_OTH</a> = 0x4F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a27ce235e5cf0a836ffcb4126753e50c6">TID_EIT_S_ACT_MIN</a> = 0x50, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a381337a1bbf01e51ef0e2431e3ef70c2">TID_EIT_S_ACT_MAX</a> = 0x5F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ad36fe44c7d8976658664551f7dfa5e2e">TID_EIT_S_OTH_MIN</a> = 0x60, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a69554964cee7a4d4b93aadde5e9d455f">TID_EIT_S_OTH_MAX</a> = 0x6F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a617c3c6ac3e77d5121946eccd271d99f">TID_TDT</a> = 0x70, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a89e79cab11caf0e845495b30e022b983">TID_RST</a> = 0x71, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037af4a9feb0ac3b9335cc0c021853e48680">TID_ST</a> = 0x72, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ae0198dc094ad69c878d148b71987e91f">TID_TOT</a> = 0x73, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a2ea0d009e91c6184e63015ae1f94b061">TID_RNT</a> = 0x74, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a99a760333f8cf8d185d25c3e5efc8806">TID_CT</a> = 0x75, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a6d67a7350927e8a6d29ceb4d5b8f85f0">TID_RCT</a> = 0x76, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a12e2a44d0812596db1eca6f58b6a9da7">TID_CIT</a> = 0x77, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ab7e93acd478597b74674f5f03a96a264">TID_MPE_FEC</a> = 0x78, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037afd2b8c258ccb9b80357554ae44da2e0d">TID_DIT</a> = 0x7E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037abeb80c4db361666798ad4671ca063827">TID_SIT</a> = 0x7F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a81b2bf38d5f812962790904e880edbbb">TID_ECM_80</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a660d47458af8a9270911eaaf4dda73a4">TID_ECM_81</a> = 0x81, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a757f75e7ce72d3dda6ff995aaaf96983">TID_EMM_FIRST</a> = 0x82, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037aaa2c1268627471242ad87af69cc5f5ac">TID_EMM_LAST</a> = 0x8F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a34248b172138c98d222e4e91b9dcdcdd">TID_EIT_MIN</a> = 0x4E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037af163086650d5e6df407e29b04c20e310">TID_EIT_MAX</a> = 0x6F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ad7334af40fe461845b49c7cefecf72a5">TID_CAS_FIRST</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a3cf423368589ea4bd3385a0b08dce31f">TID_CAS_LAST</a> = 0x8F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a08261a38571b8197c70e4cc919bdf615">TID_SA_CECM_82</a> = 0x82, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a64d930c0b8a8ca179d92b8821ea3763e">TID_SA_CECM_83</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037aa9467e645ccfc85d6ab4467eed8ea1cd">TID_SA_EMM_STB_U</a> = 0x84, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a44ed883496756248f997aedb0c077365">TID_SA_EMM_STB_G</a> = 0x85, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037adbd56fbf54d9778c732c804b3f932bd1">TID_SA_EMM_A</a> = 0x86, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a968214a88cb501e18da563ea2b17b3ee">TID_SA_EMM_U</a> = 0x87, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a1e658e728fc1dcb7fb141eaec86bd241">TID_SA_EMM_S</a> = 0x88, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a2f77365ddc3d2a702cb76d38c1f4ed66">TID_SA_EMM_CAM_G</a> = 0x89, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a63f25024bdf3c2820a7510e11e586259">TID_SA_RECM_8A</a> = 0x8A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037acafbfe8a4f206706abc244408d494dbc">TID_SA_RECM_8B</a> = 0x8B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a8880841dac861d2dc6a53218892a8aa5">TID_SA_EMM_T</a> = 0x8F, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a29ef90c143b1790cc89f3aeac9032e28">TID_LW_DMT</a> = 0x90, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a00c56af4e53ec8ef9a5ba09348c48b86">TID_LW_BDT</a> = 0x91, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a240fcbd4f14cf4d6cdedcb2235fff240">TID_LW_VIT</a> = 0x92, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a28bc4d5dbe3222ea2eaa37177a735bfd">TID_LW_VCT</a> = 0x93, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a018312c97c14c5d163bf66708e888548">TID_VIA_EMM_U</a> = 0x88, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ad919c1ad1a6155232b520613ab346f28">TID_VIA_EMM_GA_E</a> = 0x8A, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ae23861252812d3d1780f5f17024f5c77">TID_VIA_EMM_GA_O</a> = 0x8B, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037adb28248a89a10cf1673156b391b46a27">TID_VIA_EMM_GH_E</a> = 0x8C, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037afa006554c228affa735a95012afec86c">TID_VIA_EMM_GH_O</a> = 0x8D, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a6b7fa003abdc5bcda776f4c25ee3fc44">TID_VIA_EMM_S</a> = 0x8E, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037af9e7a0c60353fc9de9397be664c12d9d">TID_MG_EMM_U</a> = 0x82, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037ab6bf9ae0f8f2e4e34cd330d56cc4a5b5">TID_MG_EMM_A</a> = 0x83, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a87842feaec3068fd54862a4e88a6c5c5">TID_MG_EMM_I</a> = 0x85, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a9d4f38a721605ea7f49a177964447f5a">TID_MG_EMM_G</a> = 0x84, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a9c13db3b04a7feb291a11732b1e8df46">TID_MG_EMM_C</a> = 0x86, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae56343654e2b01380409afc12dd2b037a6cd215233ac84a1c86bfe9a9e1e5db08">TID_MG_EMM_CG</a> = 0x89
<br />
 }<tr class="memdesc:ae56343654e2b01380409afc12dd2b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table identification (TID) values.  <a href="namespacets.html#ae56343654e2b01380409afc12dd2b037">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae56343654e2b01380409afc12dd2b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bb51c4b1573092910ab6fdec459e31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">BandWidth</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31afb16b9f94267bd78db001355f4b365b1">BW_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31a9acc07f7aeaf8984f32f381076d1e9c8">BW_8_MHZ</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31a25fe22090defe689c68444ba9d63ec5f">BW_7_MHZ</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31a35a58784bef0d136add5b6ab207f89bb">BW_6_MHZ</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31a48d8795184580cd5ceeee470bf3e8aa0">BW_5_MHZ</a>
<br />
 }<tr class="memdesc:a14bb51c4b1573092910ab6fdec459e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bandwidth (OFDM)  <a href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a14bb51c4b1573092910ab6fdec459e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de171688c3a6ff71896a8f3e5817c11"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11">CASFamily</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11a79bba7cbc9e78632bc132244f9c83d9e">CAS_OTHER</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11a34ef926344fa76ad37e4c914225f3086">CAS_MEDIAGUARD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11a052e2f867595b687b227bb8c3baa9bf7">CAS_NAGRA</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11a31588d8b5cdb65efd8fd6f62e85af5c8">CAS_VIACCESS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11acd138ce077fb1c0d2b69f7e14c39202c">CAS_THALESCRYPT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11a6c7174e9a4df3ea5e3140ecf412de773">CAS_SAFEACCESS</a>
<br />
 }<tr class="memdesc:a1de171688c3a6ff71896a8f3e5817c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Known Conditional Access Systems families.  <a href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1de171688c3a6ff71896a8f3e5817c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3fc0fa119551548f2550c83ca68e47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47">CopyShare</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47a5083b3f9b5f22506be23ec56cc217b7a">COPY</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47a278c7050331579ffce6ee95b6157f5f9">SHARE</a>
<br />
 }<tr class="memdesc:a2d3fc0fa119551548f2550c83ca68e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration type used to indicate if the data referenced by a pointer shall be copied or shared.  <a href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2d3fc0fa119551548f2550c83ca68e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ee613ab8c2346d8201038e5e9a94af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af">DeliverySystem</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa2f1c5e247c3b607b53cfea2223d5c872">DS_UNDEFINED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afaa6927162dd347f1a563d7ebc8bbe1f76">DS_DVB_S</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afad9df61967a4d4772edc7da3721154de7">DS_DVB_S2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa7abae46347f832d589cef40dba86ea36">DS_DVB_T</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afae5830a58622b59832b0caab25f33c03b">DS_DVB_T2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa13bba9106a2cbc87774f879b5557396a">DS_DVB_C</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afae0da8f4f58eaf13645cc958159a3984d">DS_DVB_C_ANNEX_AC</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afad8876364c19ff425828fb9d12b8723de">DS_DVB_C_ANNEX_B</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afaca24a29fd6f82e999f6638a9259100ce">DS_DVB_C2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afac13871f9f0b767fb48f4327a38002aa3">DS_DVB_H</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa6ec1493be9d22b54dcf18ee435d5acb2">DS_ISDB_S</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afaec66186d59c2aff494119dabe9224130">DS_ISDB_T</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa4513d5455ee0852588b46b229c7aa749">DS_ISDB_C</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afab6972a4a69541eec4fc3ec81a422407a">DS_ATSC</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa83115f1fa0d48b061f6e02b45db10494">DS_ATSC_MH</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afaa644e7f3309f955ce83d448c81c25fb7">DS_DMB_TH</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afadaee127223e5f9243a7fa2e7bf57d03d">DS_CMMB</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa3b7d37c13decc2ba0604ce5ee198684f">DS_DAB</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afa435c50851a76ccdaae45282a0d35e82e">DS_DSS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afabb6e9da27299136faabde20bc6f7b0c5">DS_COUNT</a>
<br />
 }<tr class="memdesc:af4ee613ab8c2346d8201038e5e9a94af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delivery systems.  <a href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af4ee613ab8c2346d8201038e5e9a94af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e77074819f7f75377d48b113d360a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360a">DirectShowPinFilter</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aaf35b094d7ef7a5f8c390c6b2e47f7c09">xPIN_CONNECTED</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aa3b40c92e209b6b5ac947086ed7d09915">xPIN_UNCONNECTED</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aa3135226c9bfca03d7ac531c5c340d388">xPIN_INPUT</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aa2fdfc924a62c3d95e5e187eb0e83ca21">xPIN_OUTPUT</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aaeca568fbe551db05cab6c7898d31c742">xPIN_ALL_INPUT</a> = xPIN_INPUT | xPIN_CONNECTED | xPIN_UNCONNECTED, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aa579d2bf985ce9b0443607593b11b977b">xPIN_ALL_OUTPUT</a> = xPIN_OUTPUT | xPIN_CONNECTED | xPIN_UNCONNECTED, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360aa4f52982b3618751e40366e718ba92db4">xPIN_ALL</a> = xPIN_INPUT | xPIN_OUTPUT | xPIN_CONNECTED | xPIN_UNCONNECTED
<br />
 }<tr class="memdesc:ab34e77074819f7f75377d48b113d360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for DirectShow filter pin selections (Windows-specific).  <a href="namespacets.html#ab34e77074819f7f75377d48b113d360a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab34e77074819f7f75377d48b113d360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244247a91af4595a95740ef778f85184"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">GuardInterval</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184a2fb0b47db806537c58dab7cedff71112">GUARD_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184a66aa4c8d70c8147728e1ec12de949fb4">GUARD_1_32</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184ae586b7cf9368a0692c7b7cc4d325dc87">GUARD_1_16</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184aadab74e89c402061d46911b2d4767b1f">GUARD_1_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184a199309263f4d2d0b4683d1374c710f9c">GUARD_1_4</a>
<br />
 }<tr class="memdesc:a244247a91af4595a95740ef778f85184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard interval (OFDM)  <a href="namespacets.html#a244247a91af4595a95740ef778f85184">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a244247a91af4595a95740ef778f85184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9df6e98dda571737595eff7b169350"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350">Hierarchy</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350a0343626c64db75bcfdedf2f7867b35cd">HIERARCHY_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350a06de6d2482ab8c1cd60654c953d08d0b">HIERARCHY_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350a8212482c29a1175de4eebd430074cbeb">HIERARCHY_1</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350a8e57fd00a538280f2d001e8323e932b1">HIERARCHY_2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350ac2c674e2a1ea789754b4c247f5995a50">HIERARCHY_4</a>
<br />
 }<tr class="memdesc:a6c9df6e98dda571737595eff7b169350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchy (OFDM)  <a href="namespacets.html#a6c9df6e98dda571737595eff7b169350">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6c9df6e98dda571737595eff7b169350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba02cdc67c6160675835a56352ee020e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">InnerFEC</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea69a5707f8c4ef024383295b0aaff0193">FEC_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea288026384bfdca7d26e7409462d4397e">FEC_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020eaea4156395c7a42ffcfd54537b3b44cf5">FEC_1_2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea82578220fbfcfce441e3ec59092908a8">FEC_2_3</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea20d7cf9c855305d2623d12ed061b428c">FEC_3_4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea9f1789555eb052c9d852a57ba097057a">FEC_4_5</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea8b5b735d2e08ea9167842a0f7d109af0">FEC_5_6</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020eabae8428fe00a279d4ade696795a76096">FEC_6_7</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea63e630fe2a408061fe30cd66e6e04f1d">FEC_7_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea6ad8fb01826b9bd51fd954af389951d3">FEC_8_9</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ead733ffd2bc56c34c8d8f4883f691d74c">FEC_9_10</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea2bd8576d53dd516a235776a01024cebb">FEC_3_5</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020eaef4f7e3dfc2b6589bc2b7840207ff771">FEC_1_3</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ea59db66efc65849a7a363ead9a20a984c">FEC_1_4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020eae042625e679024593de2cffc8d097ab7">FEC_2_5</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020ead25d179ce439b3c6f691a4d0a22e057b">FEC_5_11</a>
<br />
 }<tr class="memdesc:aba02cdc67c6160675835a56352ee020e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner Forward Error Correction.  <a href="namespacets.html#aba02cdc67c6160675835a56352ee020e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aba02cdc67c6160675835a56352ee020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e82c198bc4395f3dc9368516da5b58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58">Modulation</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a0b582d43d238d99727c306ccad2d9a36">QPSK</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58ab2b994d65f7db1767ab53cfb88684134">PSK_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a6807a69c21a498cdd0951c0c05241ad2">QAM_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58acea9210508939f28b48e4a30a22a56b6">QAM_16</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a0573f6d2156f0dc045477ec99e6dd1c3">QAM_32</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a46861d1e063832e921a2ddeb2da5ebfb">QAM_64</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a39b5f30493274003ec7111514318a8d1">QAM_128</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a881d38d8a438d3b0873b4af375c80d3a">QAM_256</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a3d1005fc3e0b470215083799d8640100">VSB_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58a3df3d7ca662bd00d744619d8b5f5b65a">VSB_16</a>
<br />
 }<tr class="memdesc:ae4e82c198bc4395f3dc9368516da5b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulation types.  <a href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae4e82c198bc4395f3dc9368516da5b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ed5958edc396beb6eddd0ffbed538d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538d">Pilot</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538dab958f6c5d72b83b80d2f6ef4a86bffe4">PILOT_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538da3ccc710513dc7a9296920c55edf8d7be">PILOT_ON</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538da5ef28bdb9847aedd043b034dea5ff902">PILOT_OFF</a>
<br />
 }<tr class="memdesc:a26ed5958edc396beb6eddd0ffbed538d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pilot (DVB-S2)  <a href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a26ed5958edc396beb6eddd0ffbed538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a9b6fe6d16b09d8a76c227cddae90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90">Polarization</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90abc89287f3814e55e3929fbbb8cd5503d">POL_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90ab5cf7410eade407781cd1811601a2d39">POL_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90ab118e0eddc0d17e401f9549eafaaef78">POL_HORIZONTAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90a8286ef50015a093450f60bc3bf0060fd">POL_VERTICAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90a900c06ce65eadce5a99c445384c39b45">POL_LEFT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90a042e59aee73c5d6857506d33384b05ed">POL_RIGHT</a>
<br />
 }<tr class="memdesc:a251a9b6fe6d16b09d8a76c227cddae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polarization.  <a href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a251a9b6fe6d16b09d8a76c227cddae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55fc1506e1299dbed38c039463201f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201f">RollOff</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201fa1a8b65ac60553a148ebf03654f31de94">ROLLOFF_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201fab28dd56e0e693f14368c3df73b16c405">ROLLOFF_35</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201fa316d12a94730acabd6d857e0078439d3">ROLLOFF_25</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201fac5b00d68832637ef94352475de399f4c">ROLLOFF_20</a>
<br />
 }<tr class="memdesc:aba55fc1506e1299dbed38c039463201f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roll-off (DVB-S2)  <a href="namespacets.html#aba55fc1506e1299dbed38c039463201f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aba55fc1506e1299dbed38c039463201f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef665dc6784989ee4169c6a792999de6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6">SpectralInversion</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6ade6f08713a3d3dd389b77bb339694788">SPINV_OFF</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6a6da7a9cc1e62915ca3a0713b0351ef4e">SPINV_ON</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6a9f96b4a4bf08cb75508f5d8b73da8de9">SPINV_AUTO</a>
<br />
 }<tr class="memdesc:aef665dc6784989ee4169c6a792999de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spectral inversion.  <a href="namespacets.html#aef665dc6784989ee4169c6a792999de6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aef665dc6784989ee4169c6a792999de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2f4a753d453dd84bab8636dc4b7ba5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5">TransmissionMode</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5a73a3ae69386c7b74a5557ce789ac3758">TM_AUTO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5aa2722fe11be3cd528403c0cf4f4465ff">TM_2K</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5a406a117e3e6a9407da9b33b123eeb3e1">TM_4K</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5a5098fb3b070042eefb1d8ac011647dd0">TM_8K</a>
<br />
 }<tr class="memdesc:aee2f4a753d453dd84bab8636dc4b7ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission mode (OFDM)  <a href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aee2f4a753d453dd84bab8636dc4b7ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfe51c83f30216c9beaac7fc31f96d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2">TunerType</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2a8825bfa004ac099ccdc7c26bd8d7ac0e">DVB_S</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2a432b464338b95b35eb73bffe97bb0ef6">DVB_C</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2af41860dee15210708765831cace36ed5">DVB_T</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2a63975afe0cd79887faca5be13bd7d7d0">ATSC</a>
<br />
 }<tr class="memdesc:a0bfe51c83f30216c9beaac7fc31f96d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Known tuner types.  <a href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0bfe51c83f30216c9beaac7fc31f96d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b76963ba3c3e6d12b29fc10bd4642fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa">VersionFormat</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faaba95baa6c3dc575f82d5ced4879619d7">VERSION_SHORT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faacc4a4738370590fc3b4b29e660bdb518">VERSION_GLOBAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faa9ca9a7309972b9095446810f08664ccc">VERSION_LONG</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faa7c8baaececaedc8e028bea2f04926e68">VERSION_DATE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faae14179522627d36a7ace0c4cb4be8c8d">VERSION_NSIS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faaf20bd58a733e0b559edac6ea4fe88b2a">VERSION_DEKTEC</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faa1beccd6420073a2a8eae48f62ce86341">VERSION_FILES</a>
<br />
 }<tr class="memdesc:a3b76963ba3c3e6d12b29fc10bd4642fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of version formatting, for predefined option &ndash;version.  <a href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3b76963ba3c3e6d12b29fc10bd4642fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7e91f1fc19b43a859dffb518daf4488"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac7e91f1fc19b43a859dffb518daf4488">AddPathSuffix</a> (const std::string &amp;path, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ac7e91f1fc19b43a859dffb518daf4488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally add a suffix to a file path.  <a href="#ac7e91f1fc19b43a859dffb518daf4488">More...</a><br /></td></tr>
<tr class="separator:ac7e91f1fc19b43a859dffb518daf4488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e4e88a9c2f7064573fd90c72ff156d"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ae6e4e88a9c2f7064573fd90c72ff156d"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ae6e4e88a9c2f7064573fd90c72ff156d">AppendContainer</a> (CONTAINER &amp;container, int argc, const char *const argv[])</td></tr>
<tr class="memdesc:ae6e4e88a9c2f7064573fd90c72ff156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of C-strings to a container of strings.  <a href="#ae6e4e88a9c2f7064573fd90c72ff156d">More...</a><br /></td></tr>
<tr class="separator:ae6e4e88a9c2f7064573fd90c72ff156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae621d83bb5d17fa06d18f342a75cb06f"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ae621d83bb5d17fa06d18f342a75cb06f"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ae621d83bb5d17fa06d18f342a75cb06f">AppendContainer</a> (CONTAINER &amp;container, int argc, char *const argv[])</td></tr>
<tr class="memdesc:ae621d83bb5d17fa06d18f342a75cb06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of C-strings to a container of strings.  <a href="#ae621d83bb5d17fa06d18f342a75cb06f">More...</a><br /></td></tr>
<tr class="separator:ae621d83bb5d17fa06d18f342a75cb06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5760f774441c48a9c5f8138b0f2fdb"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8e5760f774441c48a9c5f8138b0f2fdb">AppendHexa</a> (std::string &amp;str, const void *data, size_t size, uint32_t flags=<a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a>, size_t indent=0, size_t line_width=<a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a>, size_t init_offset=0, size_t inner_indent=0)</td></tr>
<tr class="memdesc:a8e5760f774441c48a9c5f8138b0f2fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a multi-line string containing the hexadecimal dump of a memory area.  <a href="#a8e5760f774441c48a9c5f8138b0f2fdb">More...</a><br /></td></tr>
<tr class="separator:a8e5760f774441c48a9c5f8138b0f2fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2839cd69668c7102e1757131e1c6e5"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT , class CONTAINER &gt; </td></tr>
<tr class="memitem:a6f2839cd69668c7102e1757131e1c6e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a6f2839cd69668c7102e1757131e1c6e5">AppendUnique</a> (CONTAINER &amp;container, const ELEMENT &amp;e)</td></tr>
<tr class="memdesc:a6f2839cd69668c7102e1757131e1c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element into a container if not already present in the container.  <a href="#a6f2839cd69668c7102e1757131e1c6e5">More...</a><br /></td></tr>
<tr class="separator:a6f2839cd69668c7102e1757131e1c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4243f1bbc2cce04db3982f9684f29b7"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ad4243f1bbc2cce04db3982f9684f29b7"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ad4243f1bbc2cce04db3982f9684f29b7">AssignContainer</a> (CONTAINER &amp;container, int argc, const char *const argv[])</td></tr>
<tr class="memdesc:ad4243f1bbc2cce04db3982f9684f29b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an array of C-strings to a container of strings.  <a href="#ad4243f1bbc2cce04db3982f9684f29b7">More...</a><br /></td></tr>
<tr class="separator:ad4243f1bbc2cce04db3982f9684f29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b00c4b99bf91b332b150c7c6492f15"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ac7b00c4b99bf91b332b150c7c6492f15"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ac7b00c4b99bf91b332b150c7c6492f15">AssignContainer</a> (CONTAINER &amp;container, int argc, char *const argv[])</td></tr>
<tr class="memdesc:ac7b00c4b99bf91b332b150c7c6492f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an array of C-strings to a container of strings.  <a href="#ac7b00c4b99bf91b332b150c7c6492f15">More...</a><br /></td></tr>
<tr class="separator:ac7b00c4b99bf91b332b150c7c6492f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a052d6addf8a3d5d796113412763b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">BandWidth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afa8a052d6addf8a3d5d796113412763b">BandWidthCodeFromHz</a> (uint32_t hz)</td></tr>
<tr class="memdesc:afa8a052d6addf8a3d5d796113412763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bandwidth code from a value in Hz.  <a href="#afa8a052d6addf8a3d5d796113412763b">More...</a><br /></td></tr>
<tr class="separator:afa8a052d6addf8a3d5d796113412763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37a7bf7b228d4590928b32c6873cda8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab37a7bf7b228d4590928b32c6873cda8">BandWidthValueHz</a> (<a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">BandWidth</a> bw)</td></tr>
<tr class="memdesc:ab37a7bf7b228d4590928b32c6873cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bandwidth value in Hz.  <a href="#ab37a7bf7b228d4590928b32c6873cda8">More...</a><br /></td></tr>
<tr class="separator:ab37a7bf7b228d4590928b32c6873cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49fabcce93a8e3bf7e998873a5a78a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae49fabcce93a8e3bf7e998873a5a78a1">BaseName</a> (const std::string &amp;path, const std::string &amp;suffix=std::string())</td></tr>
<tr class="memdesc:ae49fabcce93a8e3bf7e998873a5a78a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base file name of a file path ("dir/foo.bar" =&gt; "foo.bar").  <a href="#ae49fabcce93a8e3bf7e998873a5a78a1">More...</a><br /></td></tr>
<tr class="separator:ae49fabcce93a8e3bf7e998873a5a78a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ace6ccbb276bb1cd485e692eab3fc11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0ace6ccbb276bb1cd485e692eab3fc11">BCDToString</a> (std::string &amp;str, const uint8_t *bcd, size_t bcd_count, int decimal)</td></tr>
<tr class="memdesc:a0ace6ccbb276bb1cd485e692eab3fc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string representation of a variable-length Binary Coded Decimal (BCD) encoded integer.  <a href="#a0ace6ccbb276bb1cd485e692eab3fc11">More...</a><br /></td></tr>
<tr class="separator:a0ace6ccbb276bb1cd485e692eab3fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad228da89510018c994467ef6df2058d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad228da89510018c994467ef6df2058d5">BitsPerSymbol</a> (<a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58">Modulation</a> mod)</td></tr>
<tr class="memdesc:ad228da89510018c994467ef6df2058d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bits per symbol for a specified modulation.  <a href="#ad228da89510018c994467ef6df2058d5">More...</a><br /></td></tr>
<tr class="separator:ad228da89510018c994467ef6df2058d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a65372e92a780aa7ed79802c41c6ab"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a65a65372e92a780aa7ed79802c41c6ab"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a65a65372e92a780aa7ed79802c41c6ab">BoundedAdd</a> (INT a, INT b)</td></tr>
<tr class="memdesc:a65a65372e92a780aa7ed79802c41c6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a bounded addition without overflow.  <a href="#a65a65372e92a780aa7ed79802c41c6ab">More...</a><br /></td></tr>
<tr class="separator:a65a65372e92a780aa7ed79802c41c6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd38176df8cc88d81af7f93f0821995"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:afcd38176df8cc88d81af7f93f0821995"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#afcd38176df8cc88d81af7f93f0821995">BoundedSub</a> (INT a, INT b)</td></tr>
<tr class="memdesc:afcd38176df8cc88d81af7f93f0821995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a bounded subtraction without overflow.  <a href="#afcd38176df8cc88d81af7f93f0821995">More...</a><br /></td></tr>
<tr class="separator:afcd38176df8cc88d81af7f93f0821995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62efc57362e856920b2008d838583ea8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a62efc57362e856920b2008d838583ea8">ByteSwap16</a> (uint16_t x)</td></tr>
<tr class="memdesc:a62efc57362e856920b2008d838583ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 16-bit integer data.  <a href="#a62efc57362e856920b2008d838583ea8">More...</a><br /></td></tr>
<tr class="separator:a62efc57362e856920b2008d838583ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9b4e88f0624d9fc9fb36d2b8dea9d99c">ByteSwap24</a> (uint32_t x)</td></tr>
<tr class="memdesc:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 24-bit integer data.  <a href="#a9b4e88f0624d9fc9fb36d2b8dea9d99c">More...</a><br /></td></tr>
<tr class="separator:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1516fddd435f2bd54085b3674ff6fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8c1516fddd435f2bd54085b3674ff6fd">ByteSwap32</a> (uint32_t x)</td></tr>
<tr class="memdesc:a8c1516fddd435f2bd54085b3674ff6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 32-bit integer data.  <a href="#a8c1516fddd435f2bd54085b3674ff6fd">More...</a><br /></td></tr>
<tr class="separator:a8c1516fddd435f2bd54085b3674ff6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae133add30b41089dacbb1ffa4fc42656"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae133add30b41089dacbb1ffa4fc42656">ByteSwap64</a> (uint64_t x)</td></tr>
<tr class="memdesc:ae133add30b41089dacbb1ffa4fc42656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 64-bit integer data.  <a href="#ae133add30b41089dacbb1ffa4fc42656">More...</a><br /></td></tr>
<tr class="separator:ae133add30b41089dacbb1ffa4fc42656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b73dac0d0e1108e1acc38354a1d3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11">CASFamily</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a28b73dac0d0e1108e1acc38354a1d3c1">CASFamilyOf</a> (uint16_t ca_system_id)</td></tr>
<tr class="memdesc:a28b73dac0d0e1108e1acc38354a1d3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a CAS family from a CA system id.  <a href="#a28b73dac0d0e1108e1acc38354a1d3c1">More...</a><br /></td></tr>
<tr class="separator:a28b73dac0d0e1108e1acc38354a1d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156abf4673a5c590de73bbd6f488762c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a156abf4673a5c590de73bbd6f488762c">CheckModEnum</a> (int value, const std::string &amp;name, const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a> &amp;conv, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a156abf4673a5c590de73bbd6f488762c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an enumeration value is supported by the native implementation.  <a href="#a156abf4673a5c590de73bbd6f488762c">More...</a><br /></td></tr>
<tr class="separator:a156abf4673a5c590de73bbd6f488762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefacebb545891e8e34e3532f9009c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aaefacebb545891e8e34e3532f9009c94">CheckNonNull</a> (const void *ptr)</td></tr>
<tr class="memdesc:aaefacebb545891e8e34e3532f9009c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the value of a pointer and abort the application when zero.  <a href="#aaefacebb545891e8e34e3532f9009c94">More...</a><br /></td></tr>
<tr class="separator:aaefacebb545891e8e34e3532f9009c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd872cb1364138bbabccd3e41fec9a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acd872cb1364138bbabccd3e41fec9a36">CleanupDownstream</a> (::IGraphBuilder *graph, ::IBaseFilter *filter, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:acd872cb1364138bbabccd3e41fec9a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a DirectShow filter graph, cleanup everything downstream a specified filter (Windows-specific).  <a href="#acd872cb1364138bbabccd3e41fec9a36">More...</a><br /></td></tr>
<tr class="separator:acd872cb1364138bbabccd3e41fec9a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a6233f878e3f8be1f5085de80a54a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab6a6233f878e3f8be1f5085de80a54a2">ComMessage</a> (::HRESULT status)</td></tr>
<tr class="memdesc:ab6a6233f878e3f8be1f5085de80a54a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the message for a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific).  <a href="#ab6a6233f878e3f8be1f5085de80a54a2">More...</a><br /></td></tr>
<tr class="separator:ab6a6233f878e3f8be1f5085de80a54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ee0892a7b1dea3452dfad4da4dd769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a71ee0892a7b1dea3452dfad4da4dd769">ComSuccess</a> (::HRESULT status, const char *message, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a71ee0892a7b1dea3452dfad4da4dd769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific).  <a href="#a71ee0892a7b1dea3452dfad4da4dd769">More...</a><br /></td></tr>
<tr class="separator:a71ee0892a7b1dea3452dfad4da4dd769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5810bf9e7895fffa6548f08465661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a14d5810bf9e7895fffa6548f08465661">ComSuccess</a> (::HRESULT status, const std::string &amp;message, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a14d5810bf9e7895fffa6548f08465661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific).  <a href="#a14d5810bf9e7895fffa6548f08465661">More...</a><br /></td></tr>
<tr class="separator:a14d5810bf9e7895fffa6548f08465661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf42628048bf867b3b2accc46c0e1f0e"><td class="memTemplParams" colspan="2">template&lt;class COMCLASS &gt; </td></tr>
<tr class="memitem:acf42628048bf867b3b2accc46c0e1f0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#acf42628048bf867b3b2accc46c0e1f0e">ComVectorClear</a> (std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt; COMCLASS &gt;&gt; &amp;vec)</td></tr>
<tr class="memdesc:acf42628048bf867b3b2accc46c0e1f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects in a vector and clear the vector (Windows-specific).  <a href="#acf42628048bf867b3b2accc46c0e1f0e">More...</a><br /></td></tr>
<tr class="separator:acf42628048bf867b3b2accc46c0e1f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4537fb83d538a76bb69656a3d9661ad4"><td class="memTemplParams" colspan="2">template&lt;class COMCLASS &gt; </td></tr>
<tr class="memitem:a4537fb83d538a76bb69656a3d9661ad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a4537fb83d538a76bb69656a3d9661ad4">ComVectorRelease</a> (std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt; COMCLASS &gt;&gt; &amp;vec)</td></tr>
<tr class="memdesc:a4537fb83d538a76bb69656a3d9661ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects in a vector (Windows-specific).  <a href="#a4537fb83d538a76bb69656a3d9661ad4">More...</a><br /></td></tr>
<tr class="separator:a4537fb83d538a76bb69656a3d9661ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103d4008075d1c45ec21011f0c5b58df"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a103d4008075d1c45ec21011f0c5b58df"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a103d4008075d1c45ec21011f0c5b58df">CondByteSwap</a> (INT x)</td></tr>
<tr class="memdesc:a103d4008075d1c45ec21011f0c5b58df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in big endian representation.  <a href="#a103d4008075d1c45ec21011f0c5b58df">More...</a><br /></td></tr>
<tr class="separator:a103d4008075d1c45ec21011f0c5b58df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9cec3aee4ec20d0fea7c12d0d0e8347e">CondByteSwap16</a> (uint16_t x)</td></tr>
<tr class="memdesc:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation.  <a href="#a9cec3aee4ec20d0fea7c12d0d0e8347e">More...</a><br /></td></tr>
<tr class="separator:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8b72cb6e05cd166c8346ee6bbbb6b4d8">CondByteSwap16BE</a> (uint16_t x)</td></tr>
<tr class="memdesc:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation.  <a href="#a8b72cb6e05cd166c8346ee6bbbb6b4d8">More...</a><br /></td></tr>
<tr class="separator:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baec140b94d96b53eed46b5461081e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3baec140b94d96b53eed46b5461081e0">CondByteSwap16LE</a> (uint16_t x)</td></tr>
<tr class="memdesc:a3baec140b94d96b53eed46b5461081e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in little endian representation.  <a href="#a3baec140b94d96b53eed46b5461081e0">More...</a><br /></td></tr>
<tr class="separator:a3baec140b94d96b53eed46b5461081e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b2fbe7a2ee13195f725e96d51310cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a98b2fbe7a2ee13195f725e96d51310cb">CondByteSwap24</a> (uint32_t x)</td></tr>
<tr class="memdesc:a98b2fbe7a2ee13195f725e96d51310cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation.  <a href="#a98b2fbe7a2ee13195f725e96d51310cb">More...</a><br /></td></tr>
<tr class="separator:a98b2fbe7a2ee13195f725e96d51310cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1daad980866e973aa0bcdd3991d47f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5b1daad980866e973aa0bcdd3991d47f">CondByteSwap24BE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a5b1daad980866e973aa0bcdd3991d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation.  <a href="#a5b1daad980866e973aa0bcdd3991d47f">More...</a><br /></td></tr>
<tr class="separator:a5b1daad980866e973aa0bcdd3991d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d035c03d139c7ca220cbb318089ab7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a55d035c03d139c7ca220cbb318089ab7">CondByteSwap24LE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a55d035c03d139c7ca220cbb318089ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in little endian representation.  <a href="#a55d035c03d139c7ca220cbb318089ab7">More...</a><br /></td></tr>
<tr class="separator:a55d035c03d139c7ca220cbb318089ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf35fc29b505b8b31ae5f331e4e9979"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acaf35fc29b505b8b31ae5f331e4e9979">CondByteSwap32</a> (uint32_t x)</td></tr>
<tr class="memdesc:acaf35fc29b505b8b31ae5f331e4e9979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation.  <a href="#acaf35fc29b505b8b31ae5f331e4e9979">More...</a><br /></td></tr>
<tr class="separator:acaf35fc29b505b8b31ae5f331e4e9979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7d797ee241bdfa65935663268a8cf4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc7d797ee241bdfa65935663268a8cf4">CondByteSwap32BE</a> (uint32_t x)</td></tr>
<tr class="memdesc:afc7d797ee241bdfa65935663268a8cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation.  <a href="#afc7d797ee241bdfa65935663268a8cf4">More...</a><br /></td></tr>
<tr class="separator:afc7d797ee241bdfa65935663268a8cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d8873bb0120e283796079cdf3f5f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2d3d8873bb0120e283796079cdf3f5f9">CondByteSwap32LE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a2d3d8873bb0120e283796079cdf3f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in little endian representation.  <a href="#a2d3d8873bb0120e283796079cdf3f5f9">More...</a><br /></td></tr>
<tr class="separator:a2d3d8873bb0120e283796079cdf3f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c20d76fd476e16a318b1b8445b40c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b6c20d76fd476e16a318b1b8445b40c">CondByteSwap64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3b6c20d76fd476e16a318b1b8445b40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation.  <a href="#a3b6c20d76fd476e16a318b1b8445b40c">More...</a><br /></td></tr>
<tr class="separator:a3b6c20d76fd476e16a318b1b8445b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4a858ba042ba9ff717978fee34209a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3d4a858ba042ba9ff717978fee34209a">CondByteSwap64BE</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3d4a858ba042ba9ff717978fee34209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation.  <a href="#a3d4a858ba042ba9ff717978fee34209a">More...</a><br /></td></tr>
<tr class="separator:a3d4a858ba042ba9ff717978fee34209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3ffa36c67fd7339fc5e0924c9f6b688e">CondByteSwap64LE</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in little endian representation.  <a href="#a3ffa36c67fd7339fc5e0924c9f6b688e">More...</a><br /></td></tr>
<tr class="separator:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73790a97bab5af98d70d61ac940e812"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa73790a97bab5af98d70d61ac940e812"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa73790a97bab5af98d70d61ac940e812">CondByteSwapBE</a> (INT x)</td></tr>
<tr class="memdesc:aa73790a97bab5af98d70d61ac940e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in big endian representation.  <a href="#aa73790a97bab5af98d70d61ac940e812">More...</a><br /></td></tr>
<tr class="separator:aa73790a97bab5af98d70d61ac940e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5727edb9849beae3829fb323b15585d6"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a5727edb9849beae3829fb323b15585d6"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a5727edb9849beae3829fb323b15585d6">CondByteSwapLE</a> (INT x)</td></tr>
<tr class="memdesc:a5727edb9849beae3829fb323b15585d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in little endian representation.  <a href="#a5727edb9849beae3829fb323b15585d6">More...</a><br /></td></tr>
<tr class="separator:a5727edb9849beae3829fb323b15585d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4aa575e4686cea6a7d5db3cfc1981f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7c4aa575e4686cea6a7d5db3cfc1981f">ConnectFilters</a> (::IGraphBuilder *graph, ::IBaseFilter *filter1, ::IBaseFilter *filter2, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a7c4aa575e4686cea6a7d5db3cfc1981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly connect two DirectShow filters using whatever output and input pin (Windows-specific).  <a href="#a7c4aa575e4686cea6a7d5db3cfc1981f">More...</a><br /></td></tr>
<tr class="separator:a7c4aa575e4686cea6a7d5db3cfc1981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972efcce0a4e6ba9678d3152cdf0387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> ::HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4972efcce0a4e6ba9678d3152cdf0387">CopyMediaType</a> (::AM_MEDIA_TYPE &amp;dst, const ::AM_MEDIA_TYPE &amp;src)</td></tr>
<tr class="memdesc:a4972efcce0a4e6ba9678d3152cdf0387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a media type to another (Windows-specific).  <a href="#a4972efcce0a4e6ba9678d3152cdf0387">More...</a><br /></td></tr>
<tr class="separator:a4972efcce0a4e6ba9678d3152cdf0387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60d5af605eb100728b5449eef13b24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5d60d5af605eb100728b5449eef13b24">CreateDirectory</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a5d60d5af605eb100728b5449eef13b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <a href="#a5d60d5af605eb100728b5449eef13b24">More...</a><br /></td></tr>
<tr class="separator:a5d60d5af605eb100728b5449eef13b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad527ee2430f46867cba71d2671bcc355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad527ee2430f46867cba71d2671bcc355">CreateRegistryKey</a> (const std::string &amp;key, bool is_volatile=false)</td></tr>
<tr class="memdesc:ad527ee2430f46867cba71d2671bcc355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a registry key (Windows-specific).  <a href="#ad527ee2430f46867cba71d2671bcc355">More...</a><br /></td></tr>
<tr class="separator:ad527ee2430f46867cba71d2671bcc355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac83403c71f0d14f31ee088e99c7fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#ade1d7cf3ca2437414d1d4238149a2d5b">ProcessId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aeac83403c71f0d14f31ee088e99c7fce">CurrentProcessId</a> ()</td></tr>
<tr class="memdesc:aeac83403c71f0d14f31ee088e99c7fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current process id.  <a href="#aeac83403c71f0d14f31ee088e99c7fce">More...</a><br /></td></tr>
<tr class="separator:aeac83403c71f0d14f31ee088e99c7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889077d129ec53aafeb88d066f016d7a"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a889077d129ec53aafeb88d066f016d7a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a889077d129ec53aafeb88d066f016d7a">Decimal</a> (const INT &amp;value, size_t min_width=0, bool right_justified=true, const char *separator=&quot;,&quot;, bool force_sign=false)</td></tr>
<tr class="memdesc:a889077d129ec53aafeb88d066f016d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string containing a decimal value.  <a href="#a889077d129ec53aafeb88d066f016d7a">More...</a><br /></td></tr>
<tr class="separator:a889077d129ec53aafeb88d066f016d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3dfedaa899b7a41e7c65b40bf39d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a86b3dfedaa899b7a41e7c65b40bf39d2">DecodeBCD</a> (uint8_t b)</td></tr>
<tr class="memdesc:a86b3dfedaa899b7a41e7c65b40bf39d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the decimal value of a Binary Coded Decimal (BCD) encoded byte.  <a href="#a86b3dfedaa899b7a41e7c65b40bf39d2">More...</a><br /></td></tr>
<tr class="separator:a86b3dfedaa899b7a41e7c65b40bf39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3b811606a75a6ce077fa6edd3504e5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4b3b811606a75a6ce077fa6edd3504e5">DecodeBCD</a> (const uint8_t *bcd, size_t bcd_count)</td></tr>
<tr class="memdesc:a4b3b811606a75a6ce077fa6edd3504e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the decimal value of a Binary Coded Decimal (BCD) encoded string.  <a href="#a4b3b811606a75a6ce077fa6edd3504e5">More...</a><br /></td></tr>
<tr class="separator:a4b3b811606a75a6ce077fa6edd3504e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc488febbeb2d704f43067d14e1a650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0bc488febbeb2d704f43067d14e1a650">DecodeDeliveryDescriptor</a> (const <a class="el" href="classts_1_1_descriptor.html">Descriptor</a> &amp;desc)</td></tr>
<tr class="memdesc:a0bc488febbeb2d704f43067d14e1a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DVB tuner parameters from a delivery system descriptor.  <a href="#a0bc488febbeb2d704f43067d14e1a650">More...</a><br /></td></tr>
<tr class="separator:a0bc488febbeb2d704f43067d14e1a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825344141ed756c464e741feafbf826c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a825344141ed756c464e741feafbf826c">DecodeMJD</a> (const uint8_t *mjd, size_t mjd_size, <a class="el" href="classts_1_1_time.html">Time</a> &amp;time)</td></tr>
<tr class="memdesc:a825344141ed756c464e741feafbf826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Modified Julian Date (MJD) into a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">ts::Time</a>.  <a href="#a825344141ed756c464e741feafbf826c">More...</a><br /></td></tr>
<tr class="separator:a825344141ed756c464e741feafbf826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6b50463bf9e942dd7bd8bf23190bf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0a6b50463bf9e942dd7bd8bf23190bf1">DeleteEnvironment</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a0a6b50463bf9e942dd7bd8bf23190bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an environment variable.  <a href="#a0a6b50463bf9e942dd7bd8bf23190bf1">More...</a><br /></td></tr>
<tr class="separator:a0a6b50463bf9e942dd7bd8bf23190bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ee8cba56b55cc80888dd85248d576e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab3ee8cba56b55cc80888dd85248d576e">DeleteFile</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab3ee8cba56b55cc80888dd85248d576e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file or directory.  <a href="#ab3ee8cba56b55cc80888dd85248d576e">More...</a><br /></td></tr>
<tr class="separator:ab3ee8cba56b55cc80888dd85248d576e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0067d3e29f03a0420c61dfa4dce50f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac0067d3e29f03a0420c61dfa4dce50f0">DeleteMediaType</a> (::AM_MEDIA_TYPE *media_type)</td></tr>
<tr class="memdesc:ac0067d3e29f03a0420c61dfa4dce50f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a heap-allocated AM_MEDIA_TYPE structure (Windows-specific).  <a href="#ac0067d3e29f03a0420c61dfa4dce50f0">More...</a><br /></td></tr>
<tr class="separator:ac0067d3e29f03a0420c61dfa4dce50f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4bccb473270020c937fc3b92fca3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc4bccb473270020c937fc3b92fca3b1">DeleteRegistryKey</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:afc4bccb473270020c937fc3b92fca3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a registry key (Windows-specific).  <a href="#afc4bccb473270020c937fc3b92fca3b1">More...</a><br /></td></tr>
<tr class="separator:afc4bccb473270020c937fc3b92fca3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d251d900e34d4b91b91c9dddb1b687f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8d251d900e34d4b91b91c9dddb1b687f">DeleteRegistryValue</a> (const std::string &amp;key, const std::string &amp;value_name)</td></tr>
<tr class="memdesc:a8d251d900e34d4b91b91c9dddb1b687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a value of a registry key (Windows-specific).  <a href="#a8d251d900e34d4b91b91c9dddb1b687f">More...</a><br /></td></tr>
<tr class="separator:a8d251d900e34d4b91b91c9dddb1b687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6152d8b5663d062a2797cd3bb9496ab9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6152d8b5663d062a2797cd3bb9496ab9">DirectoryName</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a6152d8b5663d062a2797cd3bb9496ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the directory name of a file path ("dir/foo.bar" =&gt; "dir").  <a href="#a6152d8b5663d062a2797cd3bb9496ab9">More...</a><br /></td></tr>
<tr class="separator:a6152d8b5663d062a2797cd3bb9496ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4535b34d24a4b5f2883fd921f1625e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4535b34d24a4b5f2883fd921f1625e94">DisplayDevicesByCategory</a> (std::ostream &amp;strm, const ::GUID &amp;category, const std::string &amp;margin, const std::string &amp;name, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a4535b34d24a4b5f2883fd921f1625e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display all devices of the specified category (Windows-specific).  <a href="#a4535b34d24a4b5f2883fd921f1625e94">More...</a><br /></td></tr>
<tr class="separator:a4535b34d24a4b5f2883fd921f1625e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace175bdc5f4a9125a6d80d9ebf07fc30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ace175bdc5f4a9125a6d80d9ebf07fc30">DisplayFilterGraph</a> (std::ostream &amp;strm, const <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IBaseFilter &gt; &amp;filter, const std::string &amp;margin, bool verbose, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:ace175bdc5f4a9125a6d80d9ebf07fc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the description of a DirectShow filter graph (Windows-specific).  <a href="#ace175bdc5f4a9125a6d80d9ebf07fc30">More...</a><br /></td></tr>
<tr class="separator:ace175bdc5f4a9125a6d80d9ebf07fc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910fd7399db097ceca4dbf6e37a574f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a910fd7399db097ceca4dbf6e37a574f0">DisplayFilterGraph</a> (std::ostream &amp;strm, const <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IGraphBuilder &gt; &amp;graph, const std::string &amp;margin, bool verbose, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a910fd7399db097ceca4dbf6e37a574f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the description of a DirectShow filter graph (Windows-specific).  <a href="#a910fd7399db097ceca4dbf6e37a574f0">More...</a><br /></td></tr>
<tr class="separator:a910fd7399db097ceca4dbf6e37a574f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d9ebe7b3844665f2d9c236188ad68"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa71d9ebe7b3844665f2d9c236188ad68">EncodeBCD</a> (int i)</td></tr>
<tr class="memdesc:aa71d9ebe7b3844665f2d9c236188ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a one-byte Binary Coded Decimal (BCD) representation of an integer.  <a href="#aa71d9ebe7b3844665f2d9c236188ad68">More...</a><br /></td></tr>
<tr class="separator:aa71d9ebe7b3844665f2d9c236188ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fc214dd82608d324ad17bd751ac2ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a80fc214dd82608d324ad17bd751ac2ad">EncodeMJD</a> (const <a class="el" href="classts_1_1_time.html">Time</a> &amp;time, uint8_t *mjd, size_t mjd_size)</td></tr>
<tr class="memdesc:a80fc214dd82608d324ad17bd751ac2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">ts::Time</a> into a Modified Julian Date (MJD).  <a href="#a80fc214dd82608d324ad17bd751ac2ad">More...</a><br /></td></tr>
<tr class="separator:a80fc214dd82608d324ad17bd751ac2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa6e545213c5fd39a1053fbd43a095b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acaa6e545213c5fd39a1053fbd43a095b">EndWith</a> (const std::string &amp;s, const char *suffix)</td></tr>
<tr class="memdesc:acaa6e545213c5fd39a1053fbd43a095b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix.  <a href="#acaa6e545213c5fd39a1053fbd43a095b">More...</a><br /></td></tr>
<tr class="separator:acaa6e545213c5fd39a1053fbd43a095b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f150c14724d830da22138ddef8aa56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a45f150c14724d830da22138ddef8aa56">EndWith</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a45f150c14724d830da22138ddef8aa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix.  <a href="#a45f150c14724d830da22138ddef8aa56">More...</a><br /></td></tr>
<tr class="separator:a45f150c14724d830da22138ddef8aa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4923b602ba062ef4f527ca62fe09088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab4923b602ba062ef4f527ca62fe09088">EndWithInsensitive</a> (const std::string &amp;s, const char *suffix)</td></tr>
<tr class="memdesc:ab4923b602ba062ef4f527ca62fe09088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix, case-insensitive.  <a href="#ab4923b602ba062ef4f527ca62fe09088">More...</a><br /></td></tr>
<tr class="separator:ab4923b602ba062ef4f527ca62fe09088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696723ccbd395ba7b1d6b82ec202730b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a696723ccbd395ba7b1d6b82ec202730b">EndWithInsensitive</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a696723ccbd395ba7b1d6b82ec202730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix, case-insensitive.  <a href="#a696723ccbd395ba7b1d6b82ec202730b">More...</a><br /></td></tr>
<tr class="separator:a696723ccbd395ba7b1d6b82ec202730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c0c67e025cd6ee1b5a1d6839e12c52"><td class="memTemplParams" colspan="2">template&lt;typename T , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae0c0c67e025cd6ee1b5a1d6839e12c52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ae0c0c67e025cd6ee1b5a1d6839e12c52">EnumerateCombinations</a> (const std::set&lt; T &gt; &amp;values, const std::set&lt; T &gt; &amp;fixed, size_t size, UnaryPredicate predicate)</td></tr>
<tr class="memdesc:ae0c0c67e025cd6ee1b5a1d6839e12c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all 'k'-elements combinations of a 'n'-elements set.  <a href="#ae0c0c67e025cd6ee1b5a1d6839e12c52">More...</a><br /></td></tr>
<tr class="separator:ae0c0c67e025cd6ee1b5a1d6839e12c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa269a8b9ad17a6eb5ef511c2e0286b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa269a8b9ad17a6eb5ef511c2e0286b67">EnumerateDevicesByClass</a> (const ::CLSID &amp;clsid, std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IMoniker &gt;&gt; &amp;monikers, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:aa269a8b9ad17a6eb5ef511c2e0286b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all devices of the specified class.  <a href="#aa269a8b9ad17a6eb5ef511c2e0286b67">More...</a><br /></td></tr>
<tr class="separator:aa269a8b9ad17a6eb5ef511c2e0286b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27e4332cd3ac6cd4c8455fcc6f5543e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa27e4332cd3ac6cd4c8455fcc6f5543e">EnvironmentExists</a> (const std::string &amp;varname)</td></tr>
<tr class="memdesc:aa27e4332cd3ac6cd4c8455fcc6f5543e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an environment variable exists.  <a href="#aa27e4332cd3ac6cd4c8455fcc6f5543e">More...</a><br /></td></tr>
<tr class="separator:aa27e4332cd3ac6cd4c8455fcc6f5543e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc90f0819fcb22d328d56f707ff3f37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8dc90f0819fcb22d328d56f707ff3f37">ErrorCodeMessage</a> (<a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> code=<a class="el" href="namespacets.html#aa816d1f04480538021fee6d480570238">LastErrorCode</a>())</td></tr>
<tr class="memdesc:a8dc90f0819fcb22d328d56f707ff3f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format an error code into a string.  <a href="#a8dc90f0819fcb22d328d56f707ff3f37">More...</a><br /></td></tr>
<tr class="separator:a8dc90f0819fcb22d328d56f707ff3f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716f791b1bb4f10defba533ee696a193"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a716f791b1bb4f10defba533ee696a193">ExecutableFile</a> ()</td></tr>
<tr class="memdesc:a716f791b1bb4f10defba533ee696a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current application executable file.  <a href="#a716f791b1bb4f10defba533ee696a193">More...</a><br /></td></tr>
<tr class="separator:a716f791b1bb4f10defba533ee696a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663085e6ea259e268bb59923823c113"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1663085e6ea259e268bb59923823c113">ExpandEnvironment</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a1663085e6ea259e268bb59923823c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand environment variables inside a file path (or any string).  <a href="#a1663085e6ea259e268bb59923823c113">More...</a><br /></td></tr>
<tr class="separator:a1663085e6ea259e268bb59923823c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677c17ff06fb84cfd077cfc172bbd3ac"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a677c17ff06fb84cfd077cfc172bbd3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a677c17ff06fb84cfd077cfc172bbd3ac">ExpandWildcard</a> (CONTAINER &amp;container, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:a677c17ff06fb84cfd077cfc172bbd3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all files matching a specified wildcard pattern.  <a href="#a677c17ff06fb84cfd077cfc172bbd3ac">More...</a><br /></td></tr>
<tr class="separator:a677c17ff06fb84cfd077cfc172bbd3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872c8a98756714309fe0a90e32d323c6"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a872c8a98756714309fe0a90e32d323c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a872c8a98756714309fe0a90e32d323c6">ExpandWildcardAndAppend</a> (CONTAINER &amp;container, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:a872c8a98756714309fe0a90e32d323c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all files matching a specified wildcard pattern and append them into a container.  <a href="#a872c8a98756714309fe0a90e32d323c6">More...</a><br /></td></tr>
<tr class="separator:a872c8a98756714309fe0a90e32d323c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d43091fa662ad1d16b323994a77e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a026d43091fa662ad1d16b323994a77e5">FatalError</a> (const char *message, size_t length)</td></tr>
<tr class="memdesc:a026d43091fa662ad1d16b323994a77e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a fatal error.  <a href="#a026d43091fa662ad1d16b323994a77e5">More...</a><br /></td></tr>
<tr class="separator:a026d43091fa662ad1d16b323994a77e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440dc142daf576dd4c291aa41ccb23ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a440dc142daf576dd4c291aa41ccb23ef">FatalMemoryAllocation</a> ()</td></tr>
<tr class="memdesc:a440dc142daf576dd4c291aa41ccb23ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle fatal memory allocation failure.  <a href="#a440dc142daf576dd4c291aa41ccb23ef">More...</a><br /></td></tr>
<tr class="separator:a440dc142daf576dd4c291aa41ccb23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a0c64adb713a2917de5cb2711ed91"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aed8a0c64adb713a2917de5cb2711ed91">FECDivider</a> (<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">InnerFEC</a> fec)</td></tr>
<tr class="memdesc:aed8a0c64adb713a2917de5cb2711ed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divider of a FEC value.  <a href="#aed8a0c64adb713a2917de5cb2711ed91">More...</a><br /></td></tr>
<tr class="separator:aed8a0c64adb713a2917de5cb2711ed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b7a0dc5023472f5928cbaed6780e77"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a56b7a0dc5023472f5928cbaed6780e77">FECMultiplier</a> (<a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">InnerFEC</a> fec)</td></tr>
<tr class="memdesc:a56b7a0dc5023472f5928cbaed6780e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the multiplier of a FEC value.  <a href="#a56b7a0dc5023472f5928cbaed6780e77">More...</a><br /></td></tr>
<tr class="separator:a56b7a0dc5023472f5928cbaed6780e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c97a02f849dec86d490c6f37f2152bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6c97a02f849dec86d490c6f37f2152bb">FileExists</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a6c97a02f849dec86d490c6f37f2152bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file or directory exists.  <a href="#a6c97a02f849dec86d490c6f37f2152bb">More...</a><br /></td></tr>
<tr class="separator:a6c97a02f849dec86d490c6f37f2152bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20c24ed1bf1ead37597f9ffb95ddb7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3a20c24ed1bf1ead37597f9ffb95ddb7">Format</a> (const char *format,...)</td></tr>
<tr class="memdesc:a3a20c24ed1bf1ead37597f9ffb95ddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string using a printf-like format.  <a href="#a3a20c24ed1bf1ead37597f9ffb95ddb7">More...</a><br /></td></tr>
<tr class="separator:a3a20c24ed1bf1ead37597f9ffb95ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea9d40213127e4e3de8890b1737761f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#adea9d40213127e4e3de8890b1737761f">FormatGUID</a> (const ::GUID &amp;guid, bool with_braces=true)</td></tr>
<tr class="memdesc:adea9d40213127e4e3de8890b1737761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a GUID as string (Windows-specific).  <a href="#adea9d40213127e4e3de8890b1737761f">More...</a><br /></td></tr>
<tr class="separator:adea9d40213127e4e3de8890b1737761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5988d10d1b0b9625f1cad0a60b431c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac5988d10d1b0b9625f1cad0a60b431c3">FreeMediaType</a> (::AM_MEDIA_TYPE &amp;media_type)</td></tr>
<tr class="memdesc:ac5988d10d1b0b9625f1cad0a60b431c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an existing media type, ie free resources it holds (Windows-specific).  <a href="#ac5988d10d1b0b9625f1cad0a60b431c3">More...</a><br /></td></tr>
<tr class="separator:ac5988d10d1b0b9625f1cad0a60b431c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10322711d0b7969007f6fdad31e38b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae10322711d0b7969007f6fdad31e38b6">GetDektecVersions</a> ()</td></tr>
<tr class="memdesc:ae10322711d0b7969007f6fdad31e38b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the versions of Dektec API and drivers.  <a href="#ae10322711d0b7969007f6fdad31e38b6">More...</a><br /></td></tr>
<tr class="separator:ae10322711d0b7969007f6fdad31e38b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a4130331712aade3ef14c149d39f94"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a19a4130331712aade3ef14c149d39f94">GetEnvironment</a> (const std::string &amp;varname, const std::string &amp;defvalue=std::string())</td></tr>
<tr class="memdesc:a19a4130331712aade3ef14c149d39f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an environment variable.  <a href="#a19a4130331712aade3ef14c149d39f94">More...</a><br /></td></tr>
<tr class="separator:a19a4130331712aade3ef14c149d39f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77da99b840fd0e0f3610e490b75314da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a77da99b840fd0e0f3610e490b75314da">GetEnvironment</a> (<a class="el" href="namespacets.html#a193fcb3d69633d775555333ad51c9cc1">Environment</a> &amp;env)</td></tr>
<tr class="memdesc:a77da99b840fd0e0f3610e490b75314da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content of the entire environment (all environment variables).  <a href="#a77da99b840fd0e0f3610e490b75314da">More...</a><br /></td></tr>
<tr class="separator:a77da99b840fd0e0f3610e490b75314da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d35e2646586828824e02e2ef9fd4fa1"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a2d35e2646586828824e02e2ef9fd4fa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a2d35e2646586828824e02e2ef9fd4fa1">GetEnvironmentPath</a> (CONTAINER &amp;container, const std::string &amp;name, const std::string &amp;def=std::string())</td></tr>
<tr class="memdesc:a2d35e2646586828824e02e2ef9fd4fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an environment variable containing a search path.  <a href="#a2d35e2646586828824e02e2ef9fd4fa1">More...</a><br /></td></tr>
<tr class="separator:a2d35e2646586828824e02e2ef9fd4fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73e8bb9eddf0c571dbc5c091b03b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8a73e8bb9eddf0c571dbc5c091b03b2f">GetFileModificationTimeLocal</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8a73e8bb9eddf0c571dbc5c091b03b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local time of the last modification of a file.  <a href="#a8a73e8bb9eddf0c571dbc5c091b03b2f">More...</a><br /></td></tr>
<tr class="separator:a8a73e8bb9eddf0c571dbc5c091b03b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9bcad6c2ca95ba2fed59ae677f1c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6b9bcad6c2ca95ba2fed59ae677f1c96">GetFileModificationTimeUTC</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a6b9bcad6c2ca95ba2fed59ae677f1c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UTC time of the last modification of a file.  <a href="#a6b9bcad6c2ca95ba2fed59ae677f1c96">More...</a><br /></td></tr>
<tr class="separator:a6b9bcad6c2ca95ba2fed59ae677f1c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9496a30d57f3184cf57739acd04c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b9496a30d57f3184cf57739acd04c12">GetFileNameRates</a> (<a class="el" href="namespacets.html#aa62844508c6ce5b912390af83157c7eb">FileNameRateVector</a> &amp;files, <a class="el" href="classts_1_1_args.html">Args</a> &amp;args, const char *option_name=0, <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a> default_rate=0)</td></tr>
<tr class="memdesc:a3b9496a30d57f3184cf57739acd04c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a list of parameters containing a list of file names with optional repetition rates in milliseconds.  <a href="#a3b9496a30d57f3184cf57739acd04c12">More...</a><br /></td></tr>
<tr class="separator:a3b9496a30d57f3184cf57739acd04c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6246d849cc1244eb701bba6a73899968"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6246d849cc1244eb701bba6a73899968">GetFileSize</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a6246d849cc1244eb701bba6a73899968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes of a file.  <a href="#a6246d849cc1244eb701bba6a73899968">More...</a><br /></td></tr>
<tr class="separator:a6246d849cc1244eb701bba6a73899968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17265d933a9beb229d001b26bbf021af"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a17265d933a9beb229d001b26bbf021af"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a17265d933a9beb229d001b26bbf021af">GetInt</a> (const void *p)</td></tr>
<tr class="memdesc:a17265d933a9beb229d001b26bbf021af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="#a17265d933a9beb229d001b26bbf021af">More...</a><br /></td></tr>
<tr class="separator:a17265d933a9beb229d001b26bbf021af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#afcc9d2fb4021b00dac5c7aa0cae59c6e">GetInt</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="#afcc9d2fb4021b00dac5c7aa0cae59c6e">More...</a><br /></td></tr>
<tr class="separator:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b32ec99a2e227a7742865f27974b67"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae4b32ec99a2e227a7742865f27974b67">GetInt16</a> (const void *p)</td></tr>
<tr class="memdesc:ae4b32ec99a2e227a7742865f27974b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="#ae4b32ec99a2e227a7742865f27974b67">More...</a><br /></td></tr>
<tr class="separator:ae4b32ec99a2e227a7742865f27974b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabce47934b112b06aa1d0e034c0ab851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aabce47934b112b06aa1d0e034c0ab851">GetInt16</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:aabce47934b112b06aa1d0e034c0ab851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="#aabce47934b112b06aa1d0e034c0ab851">More...</a><br /></td></tr>
<tr class="separator:aabce47934b112b06aa1d0e034c0ab851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6e0c99c5cd7dff8ec394e5515eae6357">GetInt16BE</a> (const void *p)</td></tr>
<tr class="memdesc:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="#a6e0c99c5cd7dff8ec394e5515eae6357">More...</a><br /></td></tr>
<tr class="separator:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d6bbd751c624abd11d5871edbb4f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a00d6bbd751c624abd11d5871edbb4f83">GetInt16BE</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:a00d6bbd751c624abd11d5871edbb4f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="#a00d6bbd751c624abd11d5871edbb4f83">More...</a><br /></td></tr>
<tr class="separator:a00d6bbd751c624abd11d5871edbb4f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb588d1a13c75a5d5422ce40004b9c22"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abb588d1a13c75a5d5422ce40004b9c22">GetInt16LE</a> (const void *p)</td></tr>
<tr class="memdesc:abb588d1a13c75a5d5422ce40004b9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in little endian representation.  <a href="#abb588d1a13c75a5d5422ce40004b9c22">More...</a><br /></td></tr>
<tr class="separator:abb588d1a13c75a5d5422ce40004b9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921a2b83853ab95d3a8071f9568f655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9921a2b83853ab95d3a8071f9568f655">GetInt16LE</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:a9921a2b83853ab95d3a8071f9568f655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in little endian representation.  <a href="#a9921a2b83853ab95d3a8071f9568f655">More...</a><br /></td></tr>
<tr class="separator:a9921a2b83853ab95d3a8071f9568f655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c27f13544400a9832dd9fe12425c2e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa6c27f13544400a9832dd9fe12425c2e">GetInt24</a> (const void *p)</td></tr>
<tr class="memdesc:aa6c27f13544400a9832dd9fe12425c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="#aa6c27f13544400a9832dd9fe12425c2e">More...</a><br /></td></tr>
<tr class="separator:aa6c27f13544400a9832dd9fe12425c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a88d4ec1b3fbdd3ff2d19f2c38b79499b">GetInt24</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="#a88d4ec1b3fbdd3ff2d19f2c38b79499b">More...</a><br /></td></tr>
<tr class="separator:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea6588c8736c18a436c561227d007ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6ea6588c8736c18a436c561227d007ba">GetInt24BE</a> (const void *p)</td></tr>
<tr class="memdesc:a6ea6588c8736c18a436c561227d007ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="#a6ea6588c8736c18a436c561227d007ba">More...</a><br /></td></tr>
<tr class="separator:a6ea6588c8736c18a436c561227d007ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74b54d502f2d4904300533e43d11a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afe74b54d502f2d4904300533e43d11a3">GetInt24BE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:afe74b54d502f2d4904300533e43d11a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="#afe74b54d502f2d4904300533e43d11a3">More...</a><br /></td></tr>
<tr class="separator:afe74b54d502f2d4904300533e43d11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a831c7bf60e2ae215cd33eb90f4ad644c">GetInt24LE</a> (const void *p)</td></tr>
<tr class="memdesc:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in little endian representation.  <a href="#a831c7bf60e2ae215cd33eb90f4ad644c">More...</a><br /></td></tr>
<tr class="separator:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271258a9dfdd04ccd315680f743e484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0271258a9dfdd04ccd315680f743e484">GetInt24LE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a0271258a9dfdd04ccd315680f743e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in little endian representation.  <a href="#a0271258a9dfdd04ccd315680f743e484">More...</a><br /></td></tr>
<tr class="separator:a0271258a9dfdd04ccd315680f743e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b85f9ebc717a54509a44eb340b1352d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0b85f9ebc717a54509a44eb340b1352d">GetInt32</a> (const void *p)</td></tr>
<tr class="memdesc:a0b85f9ebc717a54509a44eb340b1352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="#a0b85f9ebc717a54509a44eb340b1352d">More...</a><br /></td></tr>
<tr class="separator:a0b85f9ebc717a54509a44eb340b1352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2700410ea296c21f2bcddd7186e84c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad2700410ea296c21f2bcddd7186e84c4">GetInt32</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:ad2700410ea296c21f2bcddd7186e84c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="#ad2700410ea296c21f2bcddd7186e84c4">More...</a><br /></td></tr>
<tr class="separator:ad2700410ea296c21f2bcddd7186e84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9c67eafbbf4f7b06b2cba52a54359ab3">GetInt32BE</a> (const void *p)</td></tr>
<tr class="memdesc:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="#a9c67eafbbf4f7b06b2cba52a54359ab3">More...</a><br /></td></tr>
<tr class="separator:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a081c684a9d7f24ea32c62d021d2cf6a3">GetInt32BE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="#a081c684a9d7f24ea32c62d021d2cf6a3">More...</a><br /></td></tr>
<tr class="separator:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa4e42b691d1b61264a6ac1ddc820eaa7">GetInt32LE</a> (const void *p)</td></tr>
<tr class="memdesc:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in little endian representation.  <a href="#aa4e42b691d1b61264a6ac1ddc820eaa7">More...</a><br /></td></tr>
<tr class="separator:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbbe3883b9e2c35587a405593405876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8cbbe3883b9e2c35587a405593405876">GetInt32LE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a8cbbe3883b9e2c35587a405593405876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in little endian representation.  <a href="#a8cbbe3883b9e2c35587a405593405876">More...</a><br /></td></tr>
<tr class="separator:a8cbbe3883b9e2c35587a405593405876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56224321d92070fb07832659c23d553d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a56224321d92070fb07832659c23d553d">GetInt64</a> (const void *p)</td></tr>
<tr class="memdesc:a56224321d92070fb07832659c23d553d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="#a56224321d92070fb07832659c23d553d">More...</a><br /></td></tr>
<tr class="separator:a56224321d92070fb07832659c23d553d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc81f51b1795f2dae40bbb2eecb2f2e7">GetInt64</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="#afc81f51b1795f2dae40bbb2eecb2f2e7">More...</a><br /></td></tr>
<tr class="separator:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee51ebfe80183472394a82a099b050a9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aee51ebfe80183472394a82a099b050a9">GetInt64BE</a> (const void *p)</td></tr>
<tr class="memdesc:aee51ebfe80183472394a82a099b050a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="#aee51ebfe80183472394a82a099b050a9">More...</a><br /></td></tr>
<tr class="separator:aee51ebfe80183472394a82a099b050a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf0acc4d3952cf73398cb86dfedf935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4bf0acc4d3952cf73398cb86dfedf935">GetInt64BE</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:a4bf0acc4d3952cf73398cb86dfedf935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="#a4bf0acc4d3952cf73398cb86dfedf935">More...</a><br /></td></tr>
<tr class="separator:a4bf0acc4d3952cf73398cb86dfedf935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa827b7a0b2e9a76136cbffe4b6258a06">GetInt64LE</a> (const void *p)</td></tr>
<tr class="memdesc:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in little endian representation.  <a href="#aa827b7a0b2e9a76136cbffe4b6258a06">More...</a><br /></td></tr>
<tr class="separator:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395998cb5255d75c73aedbba83408c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a395998cb5255d75c73aedbba83408c03">GetInt64LE</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:a395998cb5255d75c73aedbba83408c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in little endian representation.  <a href="#a395998cb5255d75c73aedbba83408c03">More...</a><br /></td></tr>
<tr class="separator:a395998cb5255d75c73aedbba83408c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af67f53a8fcbddf0e3b5195d63f469bf5">GetInt8</a> (const void *p)</td></tr>
<tr class="memdesc:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit signed integer from serialized data.  <a href="#af67f53a8fcbddf0e3b5195d63f469bf5">More...</a><br /></td></tr>
<tr class="separator:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebbae738a51852399693a6cfe37d919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aeebbae738a51852399693a6cfe37d919">GetInt8</a> (const void *p, int8_t &amp;i)</td></tr>
<tr class="memdesc:aeebbae738a51852399693a6cfe37d919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit signed integer from serialized data.  <a href="#aeebbae738a51852399693a6cfe37d919">More...</a><br /></td></tr>
<tr class="separator:aeebbae738a51852399693a6cfe37d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#afb3a7db5384f5070e45edfb58e92c3d2">GetIntBE</a> (const void *p)</td></tr>
<tr class="memdesc:afb3a7db5384f5070e45edfb58e92c3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="#afb3a7db5384f5070e45edfb58e92c3d2">More...</a><br /></td></tr>
<tr class="separator:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add89d5728c5affffa607ff9f52f7ca45"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:add89d5728c5affffa607ff9f52f7ca45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#add89d5728c5affffa607ff9f52f7ca45">GetIntBE</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:add89d5728c5affffa607ff9f52f7ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="#add89d5728c5affffa607ff9f52f7ca45">More...</a><br /></td></tr>
<tr class="separator:add89d5728c5affffa607ff9f52f7ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10732fdeb495c72480c06249aa9e270"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:ab10732fdeb495c72480c06249aa9e270"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ab10732fdeb495c72480c06249aa9e270">GetIntLE</a> (const void *p)</td></tr>
<tr class="memdesc:ab10732fdeb495c72480c06249aa9e270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in little endian representation.  <a href="#ab10732fdeb495c72480c06249aa9e270">More...</a><br /></td></tr>
<tr class="separator:ab10732fdeb495c72480c06249aa9e270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa461b054bf380348f7db7f899840e382"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa461b054bf380348f7db7f899840e382"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa461b054bf380348f7db7f899840e382">GetIntLE</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:aa461b054bf380348f7db7f899840e382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in little endian representation.  <a href="#aa461b054bf380348f7db7f899840e382">More...</a><br /></td></tr>
<tr class="separator:aa461b054bf380348f7db7f899840e382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64242ae941b3b1a93dccb53ef5ea2582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a64242ae941b3b1a93dccb53ef5ea2582">GetLocalIPAddresses</a> (<a class="el" href="namespacets.html#a6825a1db0e62afdf5e6ccb895a28c020">IPAddressVector</a> &amp;addresses, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report=(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>()))</td></tr>
<tr class="memdesc:a64242ae941b3b1a93dccb53ef5ea2582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all local IPv4 addresses in the system.  <a href="#a64242ae941b3b1a93dccb53ef5ea2582">More...</a><br /></td></tr>
<tr class="separator:a64242ae941b3b1a93dccb53ef5ea2582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a99e4b44cc2663249707bc8c1b90b24"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1a99e4b44cc2663249707bc8c1b90b24">GetPCR</a> (const uint8_t *b)</td></tr>
<tr class="memdesc:a1a99e4b44cc2663249707bc8c1b90b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine extracts a PCR from a stream.  <a href="#a1a99e4b44cc2663249707bc8c1b90b24">More...</a><br /></td></tr>
<tr class="separator:a1a99e4b44cc2663249707bc8c1b90b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a8237da12cf198a7d95e872844a9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a90a8237da12cf198a7d95e872844a9dd">GetPin</a> (<a class="el" href="namespacets.html#ac7d5a53ca04175acbd22243acc877c7b">PinPtrVector</a> &amp;pins, ::IBaseFilter *filter, int flags, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a90a8237da12cf198a7d95e872844a9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of pins on a DirectShow filter (Windows-specific).  <a href="#a90a8237da12cf198a7d95e872844a9dd">More...</a><br /></td></tr>
<tr class="separator:a90a8237da12cf198a7d95e872844a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cc0b0979e89bf83d62afa726e7d0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a64cc0b0979e89bf83d62afa726e7d0e3">GetProcessMetrics</a> (<a class="el" href="structts_1_1_process_metrics.html">ProcessMetrics</a> &amp;metrics)</td></tr>
<tr class="memdesc:a64cc0b0979e89bf83d62afa726e7d0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get metrics for the current process.  <a href="#a64cc0b0979e89bf83d62afa726e7d0e3">More...</a><br /></td></tr>
<tr class="separator:a64cc0b0979e89bf83d62afa726e7d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfec5855785c253a943aa0726bdb39cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#adfec5855785c253a943aa0726bdb39cd">GetRegistryValue</a> (const std::string &amp;key, const std::string &amp;value_name=&quot;&quot;)</td></tr>
<tr class="memdesc:adfec5855785c253a943aa0726bdb39cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a value in a registry key as a string (Windows-specific).  <a href="#adfec5855785c253a943aa0726bdb39cd">More...</a><br /></td></tr>
<tr class="separator:adfec5855785c253a943aa0726bdb39cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bd9929f8fc64be7b9501f3f2a8d49d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa8bd9929f8fc64be7b9501f3f2a8d49d">GetRevision</a> (const std::string &amp;fileName=std::string(), bool includeLibrary=true)</td></tr>
<tr class="memdesc:aa8bd9929f8fc64be7b9501f3f2a8d49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TSDuck revision number as integer from a binary file.  <a href="#aa8bd9929f8fc64be7b9501f3f2a8d49d">More...</a><br /></td></tr>
<tr class="separator:aa8bd9929f8fc64be7b9501f3f2a8d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32407d90ff51474766cdacd51fdfa695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a32407d90ff51474766cdacd51fdfa695">GetStringPropertyBag</a> (::IMoniker *moniker, const ::OLECHAR *property_name, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a32407d90ff51474766cdacd51fdfa695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string property from the "property bag" of an object (Windows-specific).  <a href="#a32407d90ff51474766cdacd51fdfa695">More...</a><br /></td></tr>
<tr class="separator:a32407d90ff51474766cdacd51fdfa695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1dcaccdf30869ae92f04e3c6ff698e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3e1dcaccdf30869ae92f04e3c6ff698e">GetTunerFromZapFile</a> (const std::string &amp;channel_name, const std::string &amp;file_name, <a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a> &amp;parameters, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report=(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>()))</td></tr>
<tr class="memdesc:a3e1dcaccdf30869ae92f04e3c6ff698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DVB tuner parameters from a Linux zap configuration file.  <a href="#a3e1dcaccdf30869ae92f04e3c6ff698e">More...</a><br /></td></tr>
<tr class="separator:a3e1dcaccdf30869ae92f04e3c6ff698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ccd6ebc59fc1f9e52a3f47d04194dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a81ccd6ebc59fc1f9e52a3f47d04194dd">GetTuningSpaceFriendlyName</a> (::ITuningSpace *tuning, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:a81ccd6ebc59fc1f9e52a3f47d04194dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user-friendly name of a DirectShow tuning space (Windows-specific).  <a href="#a81ccd6ebc59fc1f9e52a3f47d04194dd">More...</a><br /></td></tr>
<tr class="separator:a81ccd6ebc59fc1f9e52a3f47d04194dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6df875a157273fabeb7e3d1910e9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aeb6df875a157273fabeb7e3d1910e9f1">GetTuningSpaceUniqueName</a> (::ITuningSpace *tuning, <a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report)</td></tr>
<tr class="memdesc:aeb6df875a157273fabeb7e3d1910e9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique name of a DirectShow tuning space (Windows-specific).  <a href="#aeb6df875a157273fabeb7e3d1910e9f1">More...</a><br /></td></tr>
<tr class="separator:aeb6df875a157273fabeb7e3d1910e9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac91ac45e9e2741fd64f495afb7dd5e61">GetUInt16</a> (const void *p)</td></tr>
<tr class="memdesc:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="#ac91ac45e9e2741fd64f495afb7dd5e61">More...</a><br /></td></tr>
<tr class="separator:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640588fb3bf230cc97292e011bc6386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a640588fb3bf230cc97292e011bc6386d">GetUInt16</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:a640588fb3bf230cc97292e011bc6386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="#a640588fb3bf230cc97292e011bc6386d">More...</a><br /></td></tr>
<tr class="separator:a640588fb3bf230cc97292e011bc6386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ccc17acabae9276cea7a69fe85cfc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac90ccc17acabae9276cea7a69fe85cfc">GetUInt16BE</a> (const void *p)</td></tr>
<tr class="memdesc:ac90ccc17acabae9276cea7a69fe85cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="#ac90ccc17acabae9276cea7a69fe85cfc">More...</a><br /></td></tr>
<tr class="separator:ac90ccc17acabae9276cea7a69fe85cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de659ceb502ea588e7b1d54beb326b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae6de659ceb502ea588e7b1d54beb326b">GetUInt16BE</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:ae6de659ceb502ea588e7b1d54beb326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="#ae6de659ceb502ea588e7b1d54beb326b">More...</a><br /></td></tr>
<tr class="separator:ae6de659ceb502ea588e7b1d54beb326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4afd90bdfe6e1a70c534da4b2a0f1657">GetUInt16LE</a> (const void *p)</td></tr>
<tr class="memdesc:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation.  <a href="#a4afd90bdfe6e1a70c534da4b2a0f1657">More...</a><br /></td></tr>
<tr class="separator:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb655627968c393bc4847b1801e7ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afdb655627968c393bc4847b1801e7ccc">GetUInt16LE</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:afdb655627968c393bc4847b1801e7ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation.  <a href="#afdb655627968c393bc4847b1801e7ccc">More...</a><br /></td></tr>
<tr class="separator:afdb655627968c393bc4847b1801e7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2c8afb0d642689f1ca2429d96e1eb9e7">GetUInt24</a> (const void *p)</td></tr>
<tr class="memdesc:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="#a2c8afb0d642689f1ca2429d96e1eb9e7">More...</a><br /></td></tr>
<tr class="separator:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3509bd545f2ef43e00fff957d39b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6a3509bd545f2ef43e00fff957d39b6d">GetUInt24</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a6a3509bd545f2ef43e00fff957d39b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="#a6a3509bd545f2ef43e00fff957d39b6d">More...</a><br /></td></tr>
<tr class="separator:a6a3509bd545f2ef43e00fff957d39b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70882b518121c43cd47d258bbe0e7f01"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a70882b518121c43cd47d258bbe0e7f01">GetUInt24BE</a> (const void *p)</td></tr>
<tr class="memdesc:a70882b518121c43cd47d258bbe0e7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="#a70882b518121c43cd47d258bbe0e7f01">More...</a><br /></td></tr>
<tr class="separator:a70882b518121c43cd47d258bbe0e7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502006f7de222a7313790483bd219a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a502006f7de222a7313790483bd219a80">GetUInt24BE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a502006f7de222a7313790483bd219a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="#a502006f7de222a7313790483bd219a80">More...</a><br /></td></tr>
<tr class="separator:a502006f7de222a7313790483bd219a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e63036518e36c9aade78a0672757b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a196e63036518e36c9aade78a0672757b">GetUInt24LE</a> (const void *p)</td></tr>
<tr class="memdesc:a196e63036518e36c9aade78a0672757b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation.  <a href="#a196e63036518e36c9aade78a0672757b">More...</a><br /></td></tr>
<tr class="separator:a196e63036518e36c9aade78a0672757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4344c054ebe6196445c629dccec90142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4344c054ebe6196445c629dccec90142">GetUInt24LE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a4344c054ebe6196445c629dccec90142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation.  <a href="#a4344c054ebe6196445c629dccec90142">More...</a><br /></td></tr>
<tr class="separator:a4344c054ebe6196445c629dccec90142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68fc76b965efdefafa9ec1742ffb834"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae68fc76b965efdefafa9ec1742ffb834">GetUInt32</a> (const void *p)</td></tr>
<tr class="memdesc:ae68fc76b965efdefafa9ec1742ffb834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="#ae68fc76b965efdefafa9ec1742ffb834">More...</a><br /></td></tr>
<tr class="separator:ae68fc76b965efdefafa9ec1742ffb834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac2d03f32b2cc3d180c0278cb528f2dd3">GetUInt32</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="#ac2d03f32b2cc3d180c0278cb528f2dd3">More...</a><br /></td></tr>
<tr class="separator:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11bde3bce4bc0cfae007433d280f239"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad11bde3bce4bc0cfae007433d280f239">GetUInt32BE</a> (const void *p)</td></tr>
<tr class="memdesc:ad11bde3bce4bc0cfae007433d280f239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="#ad11bde3bce4bc0cfae007433d280f239">More...</a><br /></td></tr>
<tr class="separator:ad11bde3bce4bc0cfae007433d280f239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5307f92f2750b89a6c708e2aa089474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab5307f92f2750b89a6c708e2aa089474">GetUInt32BE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:ab5307f92f2750b89a6c708e2aa089474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="#ab5307f92f2750b89a6c708e2aa089474">More...</a><br /></td></tr>
<tr class="separator:ab5307f92f2750b89a6c708e2aa089474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad4a5525afda4d4444ec7fa91816f9cf9">GetUInt32LE</a> (const void *p)</td></tr>
<tr class="memdesc:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation.  <a href="#ad4a5525afda4d4444ec7fa91816f9cf9">More...</a><br /></td></tr>
<tr class="separator:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4ec83efdcf4e64a1ede8fc6f2440e38a">GetUInt32LE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation.  <a href="#a4ec83efdcf4e64a1ede8fc6f2440e38a">More...</a><br /></td></tr>
<tr class="separator:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d8f836756fd5acb9ec38c0732fb15b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a34d8f836756fd5acb9ec38c0732fb15b">GetUInt64</a> (const void *p)</td></tr>
<tr class="memdesc:a34d8f836756fd5acb9ec38c0732fb15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="#a34d8f836756fd5acb9ec38c0732fb15b">More...</a><br /></td></tr>
<tr class="separator:a34d8f836756fd5acb9ec38c0732fb15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818fee94510087611afa73a9d365c585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a818fee94510087611afa73a9d365c585">GetUInt64</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:a818fee94510087611afa73a9d365c585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="#a818fee94510087611afa73a9d365c585">More...</a><br /></td></tr>
<tr class="separator:a818fee94510087611afa73a9d365c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c9bc167b8cc7b75ac8acfcf475a655d">GetUInt64BE</a> (const void *p)</td></tr>
<tr class="memdesc:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="#a1c9bc167b8cc7b75ac8acfcf475a655d">More...</a><br /></td></tr>
<tr class="separator:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba89ecf66ba17985d47ee587027d14ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aba89ecf66ba17985d47ee587027d14ea">GetUInt64BE</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:aba89ecf66ba17985d47ee587027d14ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="#aba89ecf66ba17985d47ee587027d14ea">More...</a><br /></td></tr>
<tr class="separator:aba89ecf66ba17985d47ee587027d14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1ae6fc9b599b7a479b3b4c059e27e2b2">GetUInt64LE</a> (const void *p)</td></tr>
<tr class="memdesc:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation.  <a href="#a1ae6fc9b599b7a479b3b4c059e27e2b2">More...</a><br /></td></tr>
<tr class="separator:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9099fb920e9cd1ba4f0b80070556757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad9099fb920e9cd1ba4f0b80070556757">GetUInt64LE</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:ad9099fb920e9cd1ba4f0b80070556757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation.  <a href="#ad9099fb920e9cd1ba4f0b80070556757">More...</a><br /></td></tr>
<tr class="separator:ad9099fb920e9cd1ba4f0b80070556757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a36e4b522c105fa6ee6706cb14bc1c77a">GetUInt8</a> (const void *p)</td></tr>
<tr class="memdesc:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit unsigned integer from serialized data.  <a href="#a36e4b522c105fa6ee6706cb14bc1c77a">More...</a><br /></td></tr>
<tr class="separator:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6099795b2a30ac243a548217568231b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6099795b2a30ac243a548217568231b7">GetUInt8</a> (const void *p, uint8_t &amp;i)</td></tr>
<tr class="memdesc:a6099795b2a30ac243a548217568231b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit unsigned integer from serialized data.  <a href="#a6099795b2a30ac243a548217568231b7">More...</a><br /></td></tr>
<tr class="separator:a6099795b2a30ac243a548217568231b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c8d044d7cd371d0da9fc1043420325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a24c8d044d7cd371d0da9fc1043420325">GetVersion</a> (<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa">VersionFormat</a> format=<a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faaba95baa6c3dc575f82d5ced4879619d7">VERSION_SHORT</a>, const std::string &amp;applicationName=std::string(), const std::string &amp;revisionFile=std::string())</td></tr>
<tr class="memdesc:a24c8d044d7cd371d0da9fc1043420325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TSDuck formatted version number.  <a href="#a24c8d044d7cd371d0da9fc1043420325">More...</a><br /></td></tr>
<tr class="separator:a24c8d044d7cd371d0da9fc1043420325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d6e6634b1f01dec5973105da80a7b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a39d6e6634b1f01dec5973105da80a7b5">GuardIntervalDivider</a> (<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">GuardInterval</a> g)</td></tr>
<tr class="memdesc:a39d6e6634b1f01dec5973105da80a7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divider of a guard interval value.  <a href="#a39d6e6634b1f01dec5973105da80a7b5">More...</a><br /></td></tr>
<tr class="separator:a39d6e6634b1f01dec5973105da80a7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84c96c83e1ba8c8190aaadaceb8c298"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa84c96c83e1ba8c8190aaadaceb8c298">GuardIntervalMultiplier</a> (<a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">GuardInterval</a> g)</td></tr>
<tr class="memdesc:aa84c96c83e1ba8c8190aaadaceb8c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the multiplier of a guard interval value.  <a href="#aa84c96c83e1ba8c8190aaadaceb8c298">More...</a><br /></td></tr>
<tr class="separator:aa84c96c83e1ba8c8190aaadaceb8c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518c3129e643fa3c679f061fcfcf271f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a518c3129e643fa3c679f061fcfcf271f">Hexa</a> (const void *data, size_t size, uint32_t flags=<a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a>, size_t indent=0, size_t line_width=<a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a>, size_t init_offset=0, size_t inner_indent=0)</td></tr>
<tr class="memdesc:a518c3129e643fa3c679f061fcfcf271f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a multi-line string containing the hexadecimal dump of a memory area.  <a href="#a518c3129e643fa3c679f061fcfcf271f">More...</a><br /></td></tr>
<tr class="separator:a518c3129e643fa3c679f061fcfcf271f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f40d1dde25f4d00aaf466483bf334f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a53f40d1dde25f4d00aaf466483bf334f">Hexa</a> (const std::string &amp;str, uint32_t flags=<a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a>, size_t indent=0, size_t line_width=<a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a>, size_t init_offset=0, size_t inner_indent=0)</td></tr>
<tr class="memdesc:a53f40d1dde25f4d00aaf466483bf334f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a multi-line string containing the hexadecimal dump of a memory area.  <a href="#a53f40d1dde25f4d00aaf466483bf334f">More...</a><br /></td></tr>
<tr class="separator:a53f40d1dde25f4d00aaf466483bf334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87da430dda0a1f7b381eabba762d48da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a87da430dda0a1f7b381eabba762d48da">Hexa</a> (const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;bb, uint32_t flags=<a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a>, size_t indent=0, size_t line_width=<a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a>, size_t init_offset=0, size_t inner_indent=0)</td></tr>
<tr class="memdesc:a87da430dda0a1f7b381eabba762d48da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a multi-line string containing the hexadecimal dump of a memory area.  <a href="#a87da430dda0a1f7b381eabba762d48da">More...</a><br /></td></tr>
<tr class="separator:a87da430dda0a1f7b381eabba762d48da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d283185f503c985d9ac0dd8049e2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acd7d283185f503c985d9ac0dd8049e2d">HexaDecode</a> (std::vector&lt; uint8_t &gt; &amp;result, const char *hexa_string)</td></tr>
<tr class="memdesc:acd7d283185f503c985d9ac0dd8049e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a sequence of hexadecimal digits (ignore blanks).  <a href="#acd7d283185f503c985d9ac0dd8049e2d">More...</a><br /></td></tr>
<tr class="separator:acd7d283185f503c985d9ac0dd8049e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a51962a177e62402915c9aedd6724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1d4a51962a177e62402915c9aedd6724">HexaDecode</a> (std::vector&lt; uint8_t &gt; &amp;result, const std::string &amp;hexa_string)</td></tr>
<tr class="memdesc:a1d4a51962a177e62402915c9aedd6724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a sequence of hexadecimal digits (ignore blanks).  <a href="#a1d4a51962a177e62402915c9aedd6724">More...</a><br /></td></tr>
<tr class="separator:a1d4a51962a177e62402915c9aedd6724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30dd41c88e3c79134b27e3e95ba7962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af30dd41c88e3c79134b27e3e95ba7962">HexaDecodeAndAppend</a> (std::vector&lt; uint8_t &gt; &amp;result, const char *hexa_string)</td></tr>
<tr class="memdesc:af30dd41c88e3c79134b27e3e95ba7962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a sequence of hexadecimal digits (ignore blanks).  <a href="#af30dd41c88e3c79134b27e3e95ba7962">More...</a><br /></td></tr>
<tr class="separator:af30dd41c88e3c79134b27e3e95ba7962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94866a95881571f8a34510e89e152c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a94866a95881571f8a34510e89e152c71">HexaDecodeAndAppend</a> (std::vector&lt; uint8_t &gt; &amp;result, const std::string &amp;hexa_string)</td></tr>
<tr class="memdesc:a94866a95881571f8a34510e89e152c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a sequence of hexadecimal digits (ignore blanks).  <a href="#a94866a95881571f8a34510e89e152c71">More...</a><br /></td></tr>
<tr class="separator:a94866a95881571f8a34510e89e152c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7898369b6ffa64d96dabd6762f3137"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0e7898369b6ffa64d96dabd6762f3137">HostName</a> ()</td></tr>
<tr class="memdesc:a0e7898369b6ffa64d96dabd6762f3137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the system host.  <a href="#a0e7898369b6ffa64d96dabd6762f3137">More...</a><br /></td></tr>
<tr class="separator:a0e7898369b6ffa64d96dabd6762f3137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab29fca47e41a41feec37fa8317215d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0ab29fca47e41a41feec37fa8317215d">IgnorePipeSignal</a> ()</td></tr>
<tr class="memdesc:a0ab29fca47e41a41feec37fa8317215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that writing to a broken pipe does not kill the current process.  <a href="#a0ab29fca47e41a41feec37fa8317215d">More...</a><br /></td></tr>
<tr class="separator:a0ab29fca47e41a41feec37fa8317215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039ec21e77be08c539c60c1c796e4494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a039ec21e77be08c539c60c1c796e4494">InitMediaType</a> (::AM_MEDIA_TYPE &amp;media_type)</td></tr>
<tr class="memdesc:a039ec21e77be08c539c60c1c796e4494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a media type with "null" values (Windows-specific).  <a href="#a039ec21e77be08c539c60c1c796e4494">More...</a><br /></td></tr>
<tr class="separator:a039ec21e77be08c539c60c1c796e4494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2277992c53ededdc67aad35fb3e0a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4b2277992c53ededdc67aad35fb3e0a2">IPInitialize</a> (<a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;=(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>()))</td></tr>
<tr class="memdesc:a4b2277992c53ededdc67aad35fb3e0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the IP libraries in the current process.  <a href="#a4b2277992c53ededdc67aad35fb3e0a2">More...</a><br /></td></tr>
<tr class="separator:a4b2277992c53ededdc67aad35fb3e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1689d90f2a19242bd4c659734971e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7b1689d90f2a19242bd4c659734971e2">IsAudioSID</a> (uint8_t sid)</td></tr>
<tr class="memdesc:a7b1689d90f2a19242bd4c659734971e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a stream id value indicates an audio stream.  <a href="#a7b1689d90f2a19242bd4c659734971e2">More...</a><br /></td></tr>
<tr class="separator:a7b1689d90f2a19242bd4c659734971e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5d9524f27c4af27d49827e1a1e1a77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aad5d9524f27c4af27d49827e1a1e1a77">IsAudioST</a> (uint8_t st)</td></tr>
<tr class="memdesc:aad5d9524f27c4af27d49827e1a1e1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an stream type value indicates an audio stream.  <a href="#aad5d9524f27c4af27d49827e1a1e1a77">More...</a><br /></td></tr>
<tr class="separator:aad5d9524f27c4af27d49827e1a1e1a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c35820651b762dde155b395d59af8d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2c35820651b762dde155b395d59af8d3">IsDirectory</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a2c35820651b762dde155b395d59af8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a path exists and is a directory.  <a href="#a2c35820651b762dde155b395d59af8d3">More...</a><br /></td></tr>
<tr class="separator:a2c35820651b762dde155b395d59af8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad781da44b42d0a87b25127108d9fe5fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad781da44b42d0a87b25127108d9fe5fa">IsLocalIPAddress</a> (const <a class="el" href="classts_1_1_i_p_address.html">IPAddress</a> &amp;address)</td></tr>
<tr class="memdesc:ad781da44b42d0a87b25127108d9fe5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a local system interface has a specified IP address.  <a href="#ad781da44b42d0a87b25127108d9fe5fa">More...</a><br /></td></tr>
<tr class="separator:ad781da44b42d0a87b25127108d9fe5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c718addb2facbf7dbb99fe0c38fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac67c718addb2facbf7dbb99fe0c38fb7">IsLongHeaderSID</a> (uint8_t sid)</td></tr>
<tr class="memdesc:ac67c718addb2facbf7dbb99fe0c38fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a stream id value indicates a PES packet with long header.  <a href="#ac67c718addb2facbf7dbb99fe0c38fb7">More...</a><br /></td></tr>
<tr class="separator:ac67c718addb2facbf7dbb99fe0c38fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b64d63b82990b3e2f0f2b637c35d1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa9b64d63b82990b3e2f0f2b637c35d1c">IsPES</a> (uint8_t st)</td></tr>
<tr class="memdesc:aa9b64d63b82990b3e2f0f2b637c35d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an stream type value indicates a PES stream.  <a href="#aa9b64d63b82990b3e2f0f2b637c35d1c">More...</a><br /></td></tr>
<tr class="separator:aa9b64d63b82990b3e2f0f2b637c35d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee27fac7041403178f5dceb53fb721b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aee27fac7041403178f5dceb53fb721b8">IsPrintable</a> (int c)</td></tr>
<tr class="memdesc:aee27fac7041403178f5dceb53fb721b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure european characters are detected as printable, even if isprint(3) does not.  <a href="#aee27fac7041403178f5dceb53fb721b8">More...</a><br /></td></tr>
<tr class="separator:aee27fac7041403178f5dceb53fb721b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ce043219049a0ad153a92d9df2be6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab3ce043219049a0ad153a92d9df2be6f">IsSectionST</a> (uint8_t st)</td></tr>
<tr class="memdesc:ab3ce043219049a0ad153a92d9df2be6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an stream type value indicates a stream carrying sections.  <a href="#ab3ce043219049a0ad153a92d9df2be6f">More...</a><br /></td></tr>
<tr class="separator:ab3ce043219049a0ad153a92d9df2be6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18700ff6227513eb587f3af1bb5767f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a18700ff6227513eb587f3af1bb5767f1">IsSpace</a> (int c)</td></tr>
<tr class="memdesc:a18700ff6227513eb587f3af1bb5767f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a character is a space.  <a href="#a18700ff6227513eb587f3af1bb5767f1">More...</a><br /></td></tr>
<tr class="separator:a18700ff6227513eb587f3af1bb5767f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc03c60ce8759943ed1ed873c30edfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4cc03c60ce8759943ed1ed873c30edfc">IsVideoSID</a> (uint8_t sid)</td></tr>
<tr class="memdesc:a4cc03c60ce8759943ed1ed873c30edfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a stream id value indicates a video stream.  <a href="#a4cc03c60ce8759943ed1ed873c30edfc">More...</a><br /></td></tr>
<tr class="separator:a4cc03c60ce8759943ed1ed873c30edfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af327ff80e50ad9fcd5b37b01ff002e3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af327ff80e50ad9fcd5b37b01ff002e3c">IsVideoST</a> (uint8_t st)</td></tr>
<tr class="memdesc:af327ff80e50ad9fcd5b37b01ff002e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an stream type value indicates a video stream.  <a href="#af327ff80e50ad9fcd5b37b01ff002e3c">More...</a><br /></td></tr>
<tr class="separator:af327ff80e50ad9fcd5b37b01ff002e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb698f50941b427f5edeb93f24f1a05"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:accb698f50941b427f5edeb93f24f1a05"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#accb698f50941b427f5edeb93f24f1a05">JoinStrings</a> (ITERATOR begin, ITERATOR end, const std::string &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:accb698f50941b427f5edeb93f24f1a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a part of a container of strings into one big string.  <a href="#accb698f50941b427f5edeb93f24f1a05">More...</a><br /></td></tr>
<tr class="separator:accb698f50941b427f5edeb93f24f1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae3999ebda5c36c9b12205527307b16"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:adae3999ebda5c36c9b12205527307b16"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#adae3999ebda5c36c9b12205527307b16">JoinStrings</a> (const CONTAINER &amp;container, const std::string &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:adae3999ebda5c36c9b12205527307b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a container of strings into one big string.  <a href="#adae3999ebda5c36c9b12205527307b16">More...</a><br /></td></tr>
<tr class="separator:adae3999ebda5c36c9b12205527307b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d1288481242c9392726062a9bc8c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a912d1288481242c9392726062a9bc8c4">Justify</a> (const std::string &amp;left, const std::string &amp;right, size_t width, char pad=' ')</td></tr>
<tr class="memdesc:a912d1288481242c9392726062a9bc8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a justified string, pad in the middle.  <a href="#a912d1288481242c9392726062a9bc8c4">More...</a><br /></td></tr>
<tr class="separator:a912d1288481242c9392726062a9bc8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5962b91c1219cc2969210911be0ced9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad5962b91c1219cc2969210911be0ced9">JustifyCentered</a> (const std::string &amp;str, size_t width, char pad=' ', bool truncate=false)</td></tr>
<tr class="memdesc:ad5962b91c1219cc2969210911be0ced9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a centered-justified (padded and optionally truncated) string.  <a href="#ad5962b91c1219cc2969210911be0ced9">More...</a><br /></td></tr>
<tr class="separator:ad5962b91c1219cc2969210911be0ced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab831b156e2633695c1152110edca118d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab831b156e2633695c1152110edca118d">JustifyLeft</a> (const std::string &amp;str, size_t width, char pad=' ', bool truncate=false)</td></tr>
<tr class="memdesc:ab831b156e2633695c1152110edca118d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a left-justified (padded and optionally truncated) string.  <a href="#ab831b156e2633695c1152110edca118d">More...</a><br /></td></tr>
<tr class="separator:ab831b156e2633695c1152110edca118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b47ed835d84c03dac56a6b33ee6e35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a99b47ed835d84c03dac56a6b33ee6e35">JustifyRight</a> (const std::string &amp;str, size_t width, char pad=' ', bool truncate=false)</td></tr>
<tr class="memdesc:a99b47ed835d84c03dac56a6b33ee6e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a right-justified (padded and optionally truncated) string.  <a href="#a99b47ed835d84c03dac56a6b33ee6e35">More...</a><br /></td></tr>
<tr class="separator:a99b47ed835d84c03dac56a6b33ee6e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c92f5de6d04087bd9e9183fbe6648b"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a55c92f5de6d04087bd9e9183fbe6648b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a55c92f5de6d04087bd9e9183fbe6648b">LargestLength</a> (const CONTAINER &amp;container)</td></tr>
<tr class="memdesc:a55c92f5de6d04087bd9e9183fbe6648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the longest string in a container of strings.  <a href="#a55c92f5de6d04087bd9e9183fbe6648b">More...</a><br /></td></tr>
<tr class="separator:a55c92f5de6d04087bd9e9183fbe6648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa816d1f04480538021fee6d480570238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa816d1f04480538021fee6d480570238">LastErrorCode</a> ()</td></tr>
<tr class="memdesc:aa816d1f04480538021fee6d480570238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of the last operating system call.  <a href="#aa816d1f04480538021fee6d480570238">More...</a><br /></td></tr>
<tr class="separator:aa816d1f04480538021fee6d480570238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2268d9defcbb4b19c04791493a616ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a5346c902c2c02fd7fdf27ecbd67e0d7e">SocketErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2268d9defcbb4b19c04791493a616ad5">LastSocketErrorCode</a> ()</td></tr>
<tr class="memdesc:a2268d9defcbb4b19c04791493a616ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of the last socket system call.  <a href="#a2268d9defcbb4b19c04791493a616ad5">More...</a><br /></td></tr>
<tr class="separator:a2268d9defcbb4b19c04791493a616ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae191ded5f90ee4a10ebdf42e127c2269"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ae191ded5f90ee4a10ebdf42e127c2269"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ae191ded5f90ee4a10ebdf42e127c2269">LoadAppendStrings</a> (CONTAINER &amp;container, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:ae191ded5f90ee4a10ebdf42e127c2269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file as strings and append them at the end of a container.  <a href="#ae191ded5f90ee4a10ebdf42e127c2269">More...</a><br /></td></tr>
<tr class="separator:ae191ded5f90ee4a10ebdf42e127c2269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa176777d53302df102a85c1f6d138c32"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:aa176777d53302df102a85c1f6d138c32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa176777d53302df102a85c1f6d138c32">LoadStrings</a> (CONTAINER &amp;container, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:aa176777d53302df102a85c1f6d138c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file as strings into a container.  <a href="#aa176777d53302df102a85c1f6d138c32">More...</a><br /></td></tr>
<tr class="separator:aa176777d53302df102a85c1f6d138c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d108b4eca6c486c304a6557daee280"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a41d108b4eca6c486c304a6557daee280">LocatePattern</a> (const void *area, size_t area_size, const void *pattern, size_t pattern_size)</td></tr>
<tr class="memdesc:a41d108b4eca6c486c304a6557daee280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a pattern into a memory area.  <a href="#a41d108b4eca6c486c304a6557daee280">More...</a><br /></td></tr>
<tr class="separator:a41d108b4eca6c486c304a6557daee280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a774ecfc4c9d96443b20df10ba22b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a14a774ecfc4c9d96443b20df10ba22b2">LowerCaseValue</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a14a774ecfc4c9d96443b20df10ba22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lowercase copy of a string.  <a href="#a14a774ecfc4c9d96443b20df10ba22b2">More...</a><br /></td></tr>
<tr class="separator:a14a774ecfc4c9d96443b20df10ba22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c295dd82cb73c63d7d728bdfca3f38d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8c295dd82cb73c63d7d728bdfca3f38d">MaxDecimalWidth</a> (size_t typeSize, size_t digitSeparatorSize=0)</td></tr>
<tr class="memdesc:a8c295dd82cb73c63d7d728bdfca3f38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum width of the decimal representation of an integer type.  <a href="#a8c295dd82cb73c63d7d728bdfca3f38d">More...</a><br /></td></tr>
<tr class="separator:a8c295dd82cb73c63d7d728bdfca3f38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebd618d1519a261d2bd1a165abdaa1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9ebd618d1519a261d2bd1a165abdaa1d">MaxHexaWidth</a> (size_t typeSize, size_t digitSeparatorSize=0)</td></tr>
<tr class="memdesc:a9ebd618d1519a261d2bd1a165abdaa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum width of the hexadecimal representation of an integer type.  <a href="#a9ebd618d1519a261d2bd1a165abdaa1d">More...</a><br /></td></tr>
<tr class="separator:a9ebd618d1519a261d2bd1a165abdaa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d47fa7b363d53756b3ee588ae06e0b"><td class="memItemLeft" align="right" valign="top"><a id="a10d47fa7b363d53756b3ee588ae06e0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a10d47fa7b363d53756b3ee588ae06e0b">MemoryBarrier</a> (void)</td></tr>
<tr class="memdesc:a10d47fa7b363d53756b3ee588ae06e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined C function performing a CPU/compiler dependent memory barrier. <br /></td></tr>
<tr class="separator:a10d47fa7b363d53756b3ee588ae06e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bce33bd7308fbf637d689cc4a6601b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab5bce33bd7308fbf637d689cc4a6601b">MemoryPageSize</a> ()</td></tr>
<tr class="memdesc:ab5bce33bd7308fbf637d689cc4a6601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get system memory page size.  <a href="#ab5bce33bd7308fbf637d689cc4a6601b">More...</a><br /></td></tr>
<tr class="separator:ab5bce33bd7308fbf637d689cc4a6601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4297db0eda62aaabe34c3b7ce24cd438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4297db0eda62aaabe34c3b7ce24cd438">NameGUID</a> (const ::GUID &amp;guid)</td></tr>
<tr class="memdesc:a4297db0eda62aaabe34c3b7ce24cd438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a GUID as string and resolve a few known names (Windows-specific).  <a href="#a4297db0eda62aaabe34c3b7ce24cd438">More...</a><br /></td></tr>
<tr class="separator:a4297db0eda62aaabe34c3b7ce24cd438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab101089c688f3dc2d73c9e715242e151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab101089c688f3dc2d73c9e715242e151">NetworkProviderToTunerType</a> (const ::GUID provider_clsid, <a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2">TunerType</a> &amp;tuner_type)</td></tr>
<tr class="memdesc:ab101089c688f3dc2d73c9e715242e151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a DirectShow network provider class id into a TSDuck tuner type (Windows-specific).  <a href="#ab101089c688f3dc2d73c9e715242e151">More...</a><br /></td></tr>
<tr class="separator:ab101089c688f3dc2d73c9e715242e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbc8576c34486ae43e406b3631121ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3cbc8576c34486ae43e406b3631121ae">NotifySettingChange</a> ()</td></tr>
<tr class="memdesc:a3cbc8576c34486ae43e406b3631121ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all applications of a setting change (Windows-specific).  <a href="#a3cbc8576c34486ae43e406b3631121ae">More...</a><br /></td></tr>
<tr class="separator:a3cbc8576c34486ae43e406b3631121ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf6b498027908f096a0f9162897912e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8cf6b498027908f096a0f9162897912e">OnOff</a> (bool b)</td></tr>
<tr class="memdesc:a8cf6b498027908f096a0f9162897912e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "on" or "off".  <a href="#a8cf6b498027908f096a0f9162897912e">More...</a><br /></td></tr>
<tr class="separator:a8cf6b498027908f096a0f9162897912e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8837ea36e9e2a5555db18d880d660f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acc8837ea36e9e2a5555db18d880d660f">operator!=</a> (uint32_t c1, const <a class="el" href="classts_1_1_c_r_c32.html">CRC32</a> &amp;c2)</td></tr>
<tr class="memdesc:acc8837ea36e9e2a5555db18d880d660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance and a 32-bit integer.  <a href="#acc8837ea36e9e2a5555db18d880d660f">More...</a><br /></td></tr>
<tr class="separator:acc8837ea36e9e2a5555db18d880d660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b687ea0feac92c5c08f3d006c28cce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8b687ea0feac92c5c08f3d006c28cce3">operator==</a> (uint32_t c1, const <a class="el" href="classts_1_1_c_r_c32.html">CRC32</a> &amp;c2)</td></tr>
<tr class="memdesc:a8b687ea0feac92c5c08f3d006c28cce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance and a 32-bit integer.  <a href="#a8b687ea0feac92c5c08f3d006c28cce3">More...</a><br /></td></tr>
<tr class="separator:a8b687ea0feac92c5c08f3d006c28cce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d740a7e88454fbd55f924d9cc2d9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac3d740a7e88454fbd55f924d9cc2d9f8">PacketDistance</a> (<a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> bitrate, <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a> duration)</td></tr>
<tr class="memdesc:ac3d740a7e88454fbd55f924d9cc2d9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of packets transmitted during a given duration in milliseconds.  <a href="#ac3d740a7e88454fbd55f924d9cc2d9f8">More...</a><br /></td></tr>
<tr class="separator:ac3d740a7e88454fbd55f924d9cc2d9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7840cb2a5119860dc7e0757c3e71821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae7840cb2a5119860dc7e0757c3e71821">PacketInterval</a> (<a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> bitrate, <a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a> distance=1)</td></tr>
<tr class="memdesc:ae7840cb2a5119860dc7e0757c3e71821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interval, in milliseconds, between two packets.  <a href="#ae7840cb2a5119860dc7e0757c3e71821">More...</a><br /></td></tr>
<tr class="separator:ae7840cb2a5119860dc7e0757c3e71821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca04bf40c24a4469afab720302f1589e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aca04bf40c24a4469afab720302f1589e">PathPrefix</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:aca04bf40c24a4469afab720302f1589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the prefix of a file path ("dir/foo.bar" =&gt; "dir/foo").  <a href="#aca04bf40c24a4469afab720302f1589e">More...</a><br /></td></tr>
<tr class="separator:aca04bf40c24a4469afab720302f1589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8326c599b8c65d4f12fcbd3a5b38b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0e8326c599b8c65d4f12fcbd3a5b38b6">PathSuffix</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a0e8326c599b8c65d4f12fcbd3a5b38b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the suffix of a file path ("dir/foo.bar" =&gt; ".bar").  <a href="#a0e8326c599b8c65d4f12fcbd3a5b38b6">More...</a><br /></td></tr>
<tr class="separator:a0e8326c599b8c65d4f12fcbd3a5b38b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92d4bead498ab54f7e99a780e1d1419"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa92d4bead498ab54f7e99a780e1d1419"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa92d4bead498ab54f7e99a780e1d1419">PercentageString</a> (INT value, INT total)</td></tr>
<tr class="memdesc:aa92d4bead498ab54f7e99a780e1d1419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a percentage string.  <a href="#aa92d4bead498ab54f7e99a780e1d1419">More...</a><br /></td></tr>
<tr class="separator:aa92d4bead498ab54f7e99a780e1d1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae930748c773797e40b2c4d80163509"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5ae930748c773797e40b2c4d80163509">Printable</a> (const std::string &amp;s, char replacement='.')</td></tr>
<tr class="memdesc:a5ae930748c773797e40b2c4d80163509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a printable version of a string.  <a href="#a5ae930748c773797e40b2c4d80163509">More...</a><br /></td></tr>
<tr class="separator:a5ae930748c773797e40b2c4d80163509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a245fbc25ba78e9512b6c473ccae6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a105a245fbc25ba78e9512b6c473ccae6">Printable</a> (const void *data, size_t size, char replacement='.')</td></tr>
<tr class="memdesc:a105a245fbc25ba78e9512b6c473ccae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a printable version of a string.  <a href="#a105a245fbc25ba78e9512b6c473ccae6">More...</a><br /></td></tr>
<tr class="separator:a105a245fbc25ba78e9512b6c473ccae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aeb825a99d11021d5b9fb46fd09d847ab">PutInt</a> (void *p, INT i)</td></tr>
<tr class="memdesc:aeb825a99d11021d5b9fb46fd09d847ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in big endian representation.  <a href="#aeb825a99d11021d5b9fb46fd09d847ab">More...</a><br /></td></tr>
<tr class="separator:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a53cfe7ccf881f48abb903fad0ce5eba4">PutInt16</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in big endian representation.  <a href="#a53cfe7ccf881f48abb903fad0ce5eba4">More...</a><br /></td></tr>
<tr class="separator:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a93ea4cfd4f900ead4b28b38c1b5c86c3">PutInt16BE</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in big endian representation.  <a href="#a93ea4cfd4f900ead4b28b38c1b5c86c3">More...</a><br /></td></tr>
<tr class="separator:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74ec8e23311e6160103e721af9b1d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae74ec8e23311e6160103e721af9b1d5b">PutInt16LE</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:ae74ec8e23311e6160103e721af9b1d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in little endian representation.  <a href="#ae74ec8e23311e6160103e721af9b1d5b">More...</a><br /></td></tr>
<tr class="separator:ae74ec8e23311e6160103e721af9b1d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4dad66d4d0f6bd8b5b996a33078da03a">PutInt24</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in big endian representation.  <a href="#a4dad66d4d0f6bd8b5b996a33078da03a">More...</a><br /></td></tr>
<tr class="separator:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683c99580e91b2adff0b3097d0332d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0683c99580e91b2adff0b3097d0332d9">PutInt24BE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a0683c99580e91b2adff0b3097d0332d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in big endian representation.  <a href="#a0683c99580e91b2adff0b3097d0332d9">More...</a><br /></td></tr>
<tr class="separator:a0683c99580e91b2adff0b3097d0332d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae07fa62ef736da28b1075a4a58dc6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aae07fa62ef736da28b1075a4a58dc6e6">PutInt24LE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:aae07fa62ef736da28b1075a4a58dc6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in little endian representation.  <a href="#aae07fa62ef736da28b1075a4a58dc6e6">More...</a><br /></td></tr>
<tr class="separator:aae07fa62ef736da28b1075a4a58dc6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4420be5d849abb7c099a35f192a85b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4420be5d849abb7c099a35f192a85b57">PutInt32</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a4420be5d849abb7c099a35f192a85b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in big endian representation.  <a href="#a4420be5d849abb7c099a35f192a85b57">More...</a><br /></td></tr>
<tr class="separator:a4420be5d849abb7c099a35f192a85b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6dd0238df9158bc987a2df603ee8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae4b6dd0238df9158bc987a2df603ee8f">PutInt32BE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:ae4b6dd0238df9158bc987a2df603ee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in big endian representation.  <a href="#ae4b6dd0238df9158bc987a2df603ee8f">More...</a><br /></td></tr>
<tr class="separator:ae4b6dd0238df9158bc987a2df603ee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3a56ef6cccf4ad5fc2db2bdb9145b341">PutInt32LE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in little endian representation.  <a href="#a3a56ef6cccf4ad5fc2db2bdb9145b341">More...</a><br /></td></tr>
<tr class="separator:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0b07e8dadad2b6d5c1a32ccc6a9396ee">PutInt64</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in big endian representation.  <a href="#a0b07e8dadad2b6d5c1a32ccc6a9396ee">More...</a><br /></td></tr>
<tr class="separator:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205bd79cdf6c8821774624c63f2c563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6205bd79cdf6c8821774624c63f2c563">PutInt64BE</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a6205bd79cdf6c8821774624c63f2c563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in big endian representation.  <a href="#a6205bd79cdf6c8821774624c63f2c563">More...</a><br /></td></tr>
<tr class="separator:a6205bd79cdf6c8821774624c63f2c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9b487302b87e7419da6928a574107b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2a9b487302b87e7419da6928a574107b">PutInt64LE</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a2a9b487302b87e7419da6928a574107b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in little endian representation.  <a href="#a2a9b487302b87e7419da6928a574107b">More...</a><br /></td></tr>
<tr class="separator:a2a9b487302b87e7419da6928a574107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609f2d6182dfbf69356a50b4840ad5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab609f2d6182dfbf69356a50b4840ad5a">PutInt8</a> (void *p, int8_t i)</td></tr>
<tr class="memdesc:ab609f2d6182dfbf69356a50b4840ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing an 8-bit signed integer data.  <a href="#ab609f2d6182dfbf69356a50b4840ad5a">More...</a><br /></td></tr>
<tr class="separator:ab609f2d6182dfbf69356a50b4840ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c976028b433f728b45103ea1c331e6"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:af7c976028b433f728b45103ea1c331e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#af7c976028b433f728b45103ea1c331e6">PutIntBE</a> (void *p, INT i)</td></tr>
<tr class="memdesc:af7c976028b433f728b45103ea1c331e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in big endian representation.  <a href="#af7c976028b433f728b45103ea1c331e6">More...</a><br /></td></tr>
<tr class="separator:af7c976028b433f728b45103ea1c331e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae1747799a404d1b992b36e4dad6f62"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:abae1747799a404d1b992b36e4dad6f62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#abae1747799a404d1b992b36e4dad6f62">PutIntLE</a> (void *p, INT i)</td></tr>
<tr class="memdesc:abae1747799a404d1b992b36e4dad6f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in little endian representation.  <a href="#abae1747799a404d1b992b36e4dad6f62">More...</a><br /></td></tr>
<tr class="separator:abae1747799a404d1b992b36e4dad6f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56efbbc13dd286af2da95348d9f27f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a56efbbc13dd286af2da95348d9f27f04">PutPCR</a> (uint8_t *b, const uint64_t &amp;pcr)</td></tr>
<tr class="memdesc:a56efbbc13dd286af2da95348d9f27f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine inserts a PCR in a stream.  <a href="#a56efbbc13dd286af2da95348d9f27f04">More...</a><br /></td></tr>
<tr class="separator:a56efbbc13dd286af2da95348d9f27f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a305fe98ef80b1759d8576b06f67c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8a305fe98ef80b1759d8576b06f67c59">PutUInt16</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a8a305fe98ef80b1759d8576b06f67c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in big endian representation.  <a href="#a8a305fe98ef80b1759d8576b06f67c59">More...</a><br /></td></tr>
<tr class="separator:a8a305fe98ef80b1759d8576b06f67c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a24f8f07a858bb7c998fd49e0ab5c2936">PutUInt16BE</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in big endian representation.  <a href="#a24f8f07a858bb7c998fd49e0ab5c2936">More...</a><br /></td></tr>
<tr class="separator:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bca47bda40cfd63c54acceafd8c9720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0bca47bda40cfd63c54acceafd8c9720">PutUInt16LE</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a0bca47bda40cfd63c54acceafd8c9720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in little endian representation.  <a href="#a0bca47bda40cfd63c54acceafd8c9720">More...</a><br /></td></tr>
<tr class="separator:a0bca47bda40cfd63c54acceafd8c9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3d9ddad30e3e50702cc7fcd19a6e8c97">PutUInt24</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in big endian representation.  <a href="#a3d9ddad30e3e50702cc7fcd19a6e8c97">More...</a><br /></td></tr>
<tr class="separator:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9edaf6a54326bf4a0ece6d642a81e1a6">PutUInt24BE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in big endian representation.  <a href="#a9edaf6a54326bf4a0ece6d642a81e1a6">More...</a><br /></td></tr>
<tr class="separator:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78420230afab2dda2251c77a64f0a42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a78420230afab2dda2251c77a64f0a42f">PutUInt24LE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a78420230afab2dda2251c77a64f0a42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in little endian representation.  <a href="#a78420230afab2dda2251c77a64f0a42f">More...</a><br /></td></tr>
<tr class="separator:a78420230afab2dda2251c77a64f0a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ebe5e56895037b713f551b84b20d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab8ebe5e56895037b713f551b84b20d26">PutUInt32</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:ab8ebe5e56895037b713f551b84b20d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in big endian representation.  <a href="#ab8ebe5e56895037b713f551b84b20d26">More...</a><br /></td></tr>
<tr class="separator:ab8ebe5e56895037b713f551b84b20d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706da0714b173a86e1d3453b296f809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1706da0714b173a86e1d3453b296f809">PutUInt32BE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a1706da0714b173a86e1d3453b296f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in big endian representation.  <a href="#a1706da0714b173a86e1d3453b296f809">More...</a><br /></td></tr>
<tr class="separator:a1706da0714b173a86e1d3453b296f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecae3276848613afd48ca0e86fe0612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acecae3276848613afd48ca0e86fe0612">PutUInt32LE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:acecae3276848613afd48ca0e86fe0612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in little endian representation.  <a href="#acecae3276848613afd48ca0e86fe0612">More...</a><br /></td></tr>
<tr class="separator:acecae3276848613afd48ca0e86fe0612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78a8326b8a5742aeec60b9f625149f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8d78a8326b8a5742aeec60b9f625149f">PutUInt64</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a8d78a8326b8a5742aeec60b9f625149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in big endian representation.  <a href="#a8d78a8326b8a5742aeec60b9f625149f">More...</a><br /></td></tr>
<tr class="separator:a8d78a8326b8a5742aeec60b9f625149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55984dfbb23eadbafe471c519bb141a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a55984dfbb23eadbafe471c519bb141a2">PutUInt64BE</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a55984dfbb23eadbafe471c519bb141a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in big endian representation.  <a href="#a55984dfbb23eadbafe471c519bb141a2">More...</a><br /></td></tr>
<tr class="separator:a55984dfbb23eadbafe471c519bb141a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a256ffe0e0d15f20904ccc77b5b015e4c">PutUInt64LE</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in little endian representation.  <a href="#a256ffe0e0d15f20904ccc77b5b015e4c">More...</a><br /></td></tr>
<tr class="separator:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2da9f1234257162bc54cdc7f14577d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5d2da9f1234257162bc54cdc7f14577d">PutUInt8</a> (void *p, uint8_t i)</td></tr>
<tr class="memdesc:a5d2da9f1234257162bc54cdc7f14577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing an 8-bit unsigned integer data.  <a href="#a5d2da9f1234257162bc54cdc7f14577d">More...</a><br /></td></tr>
<tr class="separator:a5d2da9f1234257162bc54cdc7f14577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63069e9073c0b2a0261ebe1d8e7909a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae63069e9073c0b2a0261ebe1d8e7909a">RemoveCharacter</a> (std::string &amp;s, char c)</td></tr>
<tr class="memdesc:ae63069e9073c0b2a0261ebe1d8e7909a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of character c in string s.  <a href="#ae63069e9073c0b2a0261ebe1d8e7909a">More...</a><br /></td></tr>
<tr class="separator:ae63069e9073c0b2a0261ebe1d8e7909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf11fa7933c08cd5863597bb9e9bf47"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#addf11fa7933c08cd5863597bb9e9bf47">RemovePrefix</a> (std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:addf11fa7933c08cd5863597bb9e9bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#addf11fa7933c08cd5863597bb9e9bf47">More...</a><br /></td></tr>
<tr class="separator:addf11fa7933c08cd5863597bb9e9bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42422894b047910ea84ae5569a15abf6"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a42422894b047910ea84ae5569a15abf6">RemoveSubstring</a> (std::string &amp;str, const char *substr)</td></tr>
<tr class="memdesc:a42422894b047910ea84ae5569a15abf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#a42422894b047910ea84ae5569a15abf6">More...</a><br /></td></tr>
<tr class="separator:a42422894b047910ea84ae5569a15abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286b27824b61d0cdedb03dd5adf865ee"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a286b27824b61d0cdedb03dd5adf865ee">RemoveSubstring</a> (std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:a286b27824b61d0cdedb03dd5adf865ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#a286b27824b61d0cdedb03dd5adf865ee">More...</a><br /></td></tr>
<tr class="separator:a286b27824b61d0cdedb03dd5adf865ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e582bc1154c776bf39bbbdb2a82cd3"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac8e582bc1154c776bf39bbbdb2a82cd3">RemoveSuffix</a> (std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ac8e582bc1154c776bf39bbbdb2a82cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#ac8e582bc1154c776bf39bbbdb2a82cd3">More...</a><br /></td></tr>
<tr class="separator:ac8e582bc1154c776bf39bbbdb2a82cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78dad2dfbfc59bacd7d7103b6ae394d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae78dad2dfbfc59bacd7d7103b6ae394d">RenameFile</a> (const std::string &amp;old_path, const std::string &amp;new_path)</td></tr>
<tr class="memdesc:ae78dad2dfbfc59bacd7d7103b6ae394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename / move a file or directory.  <a href="#ae78dad2dfbfc59bacd7d7103b6ae394d">More...</a><br /></td></tr>
<tr class="separator:ae78dad2dfbfc59bacd7d7103b6ae394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92609fc21b3ff43cbd411a71864b620"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab92609fc21b3ff43cbd411a71864b620">ReturnRemovePrefix</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ab92609fc21b3ff43cbd411a71864b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#ab92609fc21b3ff43cbd411a71864b620">More...</a><br /></td></tr>
<tr class="separator:ab92609fc21b3ff43cbd411a71864b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5388748dd6d6f913357717d24b7cd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aea5388748dd6d6f913357717d24b7cd2">ReturnRemoveSubstring</a> (const std::string &amp;str, const char *substr)</td></tr>
<tr class="memdesc:aea5388748dd6d6f913357717d24b7cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#aea5388748dd6d6f913357717d24b7cd2">More...</a><br /></td></tr>
<tr class="separator:aea5388748dd6d6f913357717d24b7cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350c867cc5c3841da86284dbde958ee4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a350c867cc5c3841da86284dbde958ee4">ReturnRemoveSubstring</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:a350c867cc5c3841da86284dbde958ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#a350c867cc5c3841da86284dbde958ee4">More...</a><br /></td></tr>
<tr class="separator:a350c867cc5c3841da86284dbde958ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d11256c6de3fbaac1e0fc3d7544d225"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1d11256c6de3fbaac1e0fc3d7544d225">ReturnRemoveSuffix</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a1d11256c6de3fbaac1e0fc3d7544d225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#a1d11256c6de3fbaac1e0fc3d7544d225">More...</a><br /></td></tr>
<tr class="separator:a1d11256c6de3fbaac1e0fc3d7544d225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94466636c79bbfd8808c670c69006138"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a94466636c79bbfd8808c670c69006138">ReturnSubstituteAll</a> (const std::string &amp;str, const std::string &amp;value, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a94466636c79bbfd8808c670c69006138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of a string where all occurences of a string are substituted with another one.  <a href="#a94466636c79bbfd8808c670c69006138">More...</a><br /></td></tr>
<tr class="separator:a94466636c79bbfd8808c670c69006138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3578dc1ee3136b0c040aab4848608036"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3578dc1ee3136b0c040aab4848608036">ReturnTrim</a> (const std::string &amp;str, bool leading=true, bool trailing=true)</td></tr>
<tr class="memdesc:a3578dc1ee3136b0c040aab4848608036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of a string where leading and / or trailing spaces are trimmed.  <a href="#a3578dc1ee3136b0c040aab4848608036">More...</a><br /></td></tr>
<tr class="separator:a3578dc1ee3136b0c040aab4848608036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1511582799a25d3ca0889391ef6cdd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acc1511582799a25d3ca0889391ef6cdd">ROL</a> (uint32_t word, int i)</td></tr>
<tr class="memdesc:acc1511582799a25d3ca0889391ef6cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit left-rotate.  <a href="#acc1511582799a25d3ca0889391ef6cdd">More...</a><br /></td></tr>
<tr class="separator:acc1511582799a25d3ca0889391ef6cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57151094cdd98106fb52d244ab77512a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a57151094cdd98106fb52d244ab77512a">ROL64</a> (uint64_t word, int i)</td></tr>
<tr class="memdesc:a57151094cdd98106fb52d244ab77512a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit left-rotate.  <a href="#a57151094cdd98106fb52d244ab77512a">More...</a><br /></td></tr>
<tr class="separator:a57151094cdd98106fb52d244ab77512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693f2485d1a42ed33214a7d04d4421d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad693f2485d1a42ed33214a7d04d4421d">ROL64c</a> (uint64_t word, const int i)</td></tr>
<tr class="memdesc:ad693f2485d1a42ed33214a7d04d4421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit left-rotate with a constant value in the range 0..63 for index.  <a href="#ad693f2485d1a42ed33214a7d04d4421d">More...</a><br /></td></tr>
<tr class="separator:ad693f2485d1a42ed33214a7d04d4421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aebdf2fed7c021b5f0ed05991aea8c9b2">ROR</a> (uint32_t word, int i)</td></tr>
<tr class="memdesc:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit right-rotate.  <a href="#aebdf2fed7c021b5f0ed05991aea8c9b2">More...</a><br /></td></tr>
<tr class="separator:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea56cdee827d08793a5f9b9c608ff787"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aea56cdee827d08793a5f9b9c608ff787">ROR64</a> (uint64_t word, int i)</td></tr>
<tr class="memdesc:aea56cdee827d08793a5f9b9c608ff787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit right-rotate.  <a href="#aea56cdee827d08793a5f9b9c608ff787">More...</a><br /></td></tr>
<tr class="separator:aea56cdee827d08793a5f9b9c608ff787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6d0521f51487a0d59c3f36fc6f2d8cfe">ROR64c</a> (uint64_t word, const int i)</td></tr>
<tr class="memdesc:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit right-rotate with a constant value in the range 0..63 for index.  <a href="#a6d0521f51487a0d59c3f36fc6f2d8cfe">More...</a><br /></td></tr>
<tr class="separator:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd41a7d2a6ef91744555d603accea06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1bd41a7d2a6ef91744555d603accea06">RORc</a> (uint32_t word, const int i)</td></tr>
<tr class="memdesc:a1bd41a7d2a6ef91744555d603accea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit left-rotate with a constant value in the range 0..31 for index.  <a href="#a1bd41a7d2a6ef91744555d603accea06">More...</a><br /></td></tr>
<tr class="separator:a1bd41a7d2a6ef91744555d603accea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9301b5fe5b626fcde7937191ddcf0a79"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a9301b5fe5b626fcde7937191ddcf0a79"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a9301b5fe5b626fcde7937191ddcf0a79">RoundDown</a> (INT x, INT f)</td></tr>
<tr class="memdesc:a9301b5fe5b626fcde7937191ddcf0a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <em>x</em> down to previous multiple of a factor <em>f</em>.  <a href="#a9301b5fe5b626fcde7937191ddcf0a79">More...</a><br /></td></tr>
<tr class="separator:a9301b5fe5b626fcde7937191ddcf0a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac059d29061522705dfad72fa6b6b8fa1"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:ac059d29061522705dfad72fa6b6b8fa1"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ac059d29061522705dfad72fa6b6b8fa1">RoundUp</a> (INT x, INT f)</td></tr>
<tr class="memdesc:ac059d29061522705dfad72fa6b6b8fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round <em>x</em> up to next multiple of a factor <em>f</em>.  <a href="#ac059d29061522705dfad72fa6b6b8fa1">More...</a><br /></td></tr>
<tr class="separator:ac059d29061522705dfad72fa6b6b8fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c069b088781066598fa644830e9f84"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:a97c069b088781066598fa644830e9f84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a97c069b088781066598fa644830e9f84">SaveStrings</a> (ITERATOR begin, ITERATOR end, const std::string &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:a97c069b088781066598fa644830e9f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, one per line.  <a href="#a97c069b088781066598fa644830e9f84">More...</a><br /></td></tr>
<tr class="separator:a97c069b088781066598fa644830e9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfe3605604a4fe9c52d644912977a70"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a2dfe3605604a4fe9c52d644912977a70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a2dfe3605604a4fe9c52d644912977a70">SaveStrings</a> (const CONTAINER &amp;container, const std::string &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:a2dfe3605604a4fe9c52d644912977a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, one per line.  <a href="#a2dfe3605604a4fe9c52d644912977a70">More...</a><br /></td></tr>
<tr class="separator:a2dfe3605604a4fe9c52d644912977a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77da02aa4068409cbb3cf797de782021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a77da02aa4068409cbb3cf797de782021">SectionPacketCount</a> (size_t section_size)</td></tr>
<tr class="memdesc:a77da02aa4068409cbb3cf797de782021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum number of TS packets required to transport a section.  <a href="#a77da02aa4068409cbb3cf797de782021">More...</a><br /></td></tr>
<tr class="separator:a77da02aa4068409cbb3cf797de782021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92b1ce1e3abaf6202b9415f58102b56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab92b1ce1e3abaf6202b9415f58102b56">SequencedPTS</a> (uint64_t pts1, uint64_t pts2)</td></tr>
<tr class="memdesc:ab92b1ce1e3abaf6202b9415f58102b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two Presentation <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> Stamp are in sequence.  <a href="#ab92b1ce1e3abaf6202b9415f58102b56">More...</a><br /></td></tr>
<tr class="separator:ab92b1ce1e3abaf6202b9415f58102b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79c94e4ddee6770dcf6a43b88c7174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abe79c94e4ddee6770dcf6a43b88c7174">SetBinaryModeStdin</a> (<a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report=(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>()))</td></tr>
<tr class="memdesc:abe79c94e4ddee6770dcf6a43b88c7174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the standard input stream in binary mode.  <a href="#abe79c94e4ddee6770dcf6a43b88c7174">More...</a><br /></td></tr>
<tr class="separator:abe79c94e4ddee6770dcf6a43b88c7174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507c176a2cc25838661a9674d45dbc2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a507c176a2cc25838661a9674d45dbc2f">SetBinaryModeStdout</a> (<a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;report=(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>()))</td></tr>
<tr class="memdesc:a507c176a2cc25838661a9674d45dbc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the standard output stream in binary mode.  <a href="#a507c176a2cc25838661a9674d45dbc2f">More...</a><br /></td></tr>
<tr class="separator:a507c176a2cc25838661a9674d45dbc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205c3371a5ac31b772a0b350a025f5f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a205c3371a5ac31b772a0b350a025f5f9">SetEnvironment</a> (const std::string &amp;name, const std::string &amp;value)</td></tr>
<tr class="memdesc:a205c3371a5ac31b772a0b350a025f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an environment variable.  <a href="#a205c3371a5ac31b772a0b350a025f5f9">More...</a><br /></td></tr>
<tr class="separator:a205c3371a5ac31b772a0b350a025f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311d88ca573af86ea3e127361811fd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a311d88ca573af86ea3e127361811fd59">SetRegistryValue</a> (const std::string &amp;key, const std::string &amp;value_name, const std::string &amp;value, bool expandable=false)</td></tr>
<tr class="memdesc:a311d88ca573af86ea3e127361811fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a registry key (Windows-specific).  <a href="#a311d88ca573af86ea3e127361811fd59">More...</a><br /></td></tr>
<tr class="separator:a311d88ca573af86ea3e127361811fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c78d9775369814fbdf0fa1db2ee3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a573c78d9775369814fbdf0fa1db2ee3f">SetRegistryValue</a> (const std::string &amp;key, const std::string &amp;value_name, ::DWORD value)</td></tr>
<tr class="memdesc:a573c78d9775369814fbdf0fa1db2ee3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a registry key (Windows-specific).  <a href="#a573c78d9775369814fbdf0fa1db2ee3f">More...</a><br /></td></tr>
<tr class="separator:a573c78d9775369814fbdf0fa1db2ee3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6eea3582f5368a84f08aa6512942a3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5d6eea3582f5368a84f08aa6512942a3">SignExtend24</a> (int32_t x)</td></tr>
<tr class="memdesc:a5d6eea3582f5368a84f08aa6512942a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sign extension on 24 bit integers.  <a href="#a5d6eea3582f5368a84f08aa6512942a3">More...</a><br /></td></tr>
<tr class="separator:a5d6eea3582f5368a84f08aa6512942a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8264fdcc13f105f5b88ed29a1f5c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aab8264fdcc13f105f5b88ed29a1f5c14">SimilarStrings</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:aab8264fdcc13f105f5b88ed29a1f5c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#aab8264fdcc13f105f5b88ed29a1f5c14">More...</a><br /></td></tr>
<tr class="separator:aab8264fdcc13f105f5b88ed29a1f5c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8157d774bb7d87d33a907874e575630a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8157d774bb7d87d33a907874e575630a">SimilarStrings</a> (const std::string &amp;a, const void *b, size_t bsize)</td></tr>
<tr class="memdesc:a8157d774bb7d87d33a907874e575630a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#a8157d774bb7d87d33a907874e575630a">More...</a><br /></td></tr>
<tr class="separator:a8157d774bb7d87d33a907874e575630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c8b8b3091d0e281fdf0f52ce50e3c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a02c8b8b3091d0e281fdf0f52ce50e3c9">SleepThread</a> (<a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a> delay)</td></tr>
<tr class="memdesc:a02c8b8b3091d0e281fdf0f52ce50e3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the current thread for the specified period.  <a href="#a02c8b8b3091d0e281fdf0f52ce50e3c9">More...</a><br /></td></tr>
<tr class="separator:a02c8b8b3091d0e281fdf0f52ce50e3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa865450711be59bc301cdb10982373"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3fa865450711be59bc301cdb10982373">SocketErrorCodeMessage</a> (<a class="el" href="namespacets.html#a5346c902c2c02fd7fdf27ecbd67e0d7e">SocketErrorCode</a> code=<a class="el" href="namespacets.html#a2268d9defcbb4b19c04791493a616ad5">LastSocketErrorCode</a>())</td></tr>
<tr class="memdesc:a3fa865450711be59bc301cdb10982373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a socket error code into a string.  <a href="#a3fa865450711be59bc301cdb10982373">More...</a><br /></td></tr>
<tr class="separator:a3fa865450711be59bc301cdb10982373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fb18e3c49571263b63f5abed843c3c"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a86fb18e3c49571263b63f5abed843c3c"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a86fb18e3c49571263b63f5abed843c3c">SplitBlocks</a> (CONTAINER &amp;container, const char *input, char startWith='[', char endWith=']', bool trimSpaces=true)</td></tr>
<tr class="memdesc:a86fb18e3c49571263b63f5abed843c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default).  <a href="#a86fb18e3c49571263b63f5abed843c3c">More...</a><br /></td></tr>
<tr class="separator:a86fb18e3c49571263b63f5abed843c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff97eeaa3c005db1fb62a8fe91b44d"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a91ff97eeaa3c005db1fb62a8fe91b44d"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a91ff97eeaa3c005db1fb62a8fe91b44d">SplitBlocks</a> (CONTAINER &amp;container, const std::string &amp;input, char startWith='[', char endWith=']', bool trimSpaces=true)</td></tr>
<tr class="memdesc:a91ff97eeaa3c005db1fb62a8fe91b44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments based on a separator character (comma by default).  <a href="#a91ff97eeaa3c005db1fb62a8fe91b44d">More...</a><br /></td></tr>
<tr class="separator:a91ff97eeaa3c005db1fb62a8fe91b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b74c0c8707ab08243759c4210424dcf"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a7b74c0c8707ab08243759c4210424dcf"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a7b74c0c8707ab08243759c4210424dcf">SplitLines</a> (CONTAINER &amp;container, const std::string &amp;str, size_t maxWidth, const std::string &amp;otherSeparators=&quot;&quot;, const std::string &amp;nextMargin=&quot;&quot;, bool forceSplit=false)</td></tr>
<tr class="memdesc:a7b74c0c8707ab08243759c4210424dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into multiple lines which are not longer than a specified maximum width.  <a href="#a7b74c0c8707ab08243759c4210424dcf">More...</a><br /></td></tr>
<tr class="separator:a7b74c0c8707ab08243759c4210424dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6489166bbdba4193977b020ec4b8385e"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a6489166bbdba4193977b020ec4b8385e"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a6489166bbdba4193977b020ec4b8385e">SplitString</a> (CONTAINER &amp;container, const char *input, char separator=',', bool trimSpaces=true)</td></tr>
<tr class="memdesc:a6489166bbdba4193977b020ec4b8385e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments based on a separator character (comma by default).  <a href="#a6489166bbdba4193977b020ec4b8385e">More...</a><br /></td></tr>
<tr class="separator:a6489166bbdba4193977b020ec4b8385e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bf411bef1fb0ae4d01bc1c049f73d"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a272bf411bef1fb0ae4d01bc1c049f73d"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a272bf411bef1fb0ae4d01bc1c049f73d">SplitString</a> (CONTAINER &amp;container, const std::string &amp;input, char separator=',', bool trimSpaces=true)</td></tr>
<tr class="memdesc:a272bf411bef1fb0ae4d01bc1c049f73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments based on a separator character (comma by default).  <a href="#a272bf411bef1fb0ae4d01bc1c049f73d">More...</a><br /></td></tr>
<tr class="separator:a272bf411bef1fb0ae4d01bc1c049f73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed6b39ed58cb2b9fa6e33e1b8626a4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2ed6b39ed58cb2b9fa6e33e1b8626a4b">StartsWith</a> (const void *area, size_t area_size, const void *prefix, size_t prefix_size)</td></tr>
<tr class="memdesc:a2ed6b39ed58cb2b9fa6e33e1b8626a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a memory area starts with the specified prefix.  <a href="#a2ed6b39ed58cb2b9fa6e33e1b8626a4b">More...</a><br /></td></tr>
<tr class="separator:a2ed6b39ed58cb2b9fa6e33e1b8626a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7fd59b1897788309e19f2e7b9bfcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a61e7fd59b1897788309e19f2e7b9bfcd">StartWith</a> (const std::string &amp;s, const char *prefix)</td></tr>
<tr class="memdesc:a61e7fd59b1897788309e19f2e7b9bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with a specified prefix.  <a href="#a61e7fd59b1897788309e19f2e7b9bfcd">More...</a><br /></td></tr>
<tr class="separator:a61e7fd59b1897788309e19f2e7b9bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4526d2f0dde97eea9132047ea1dc5bf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4526d2f0dde97eea9132047ea1dc5bf9">StartWith</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a4526d2f0dde97eea9132047ea1dc5bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with a specified prefix.  <a href="#a4526d2f0dde97eea9132047ea1dc5bf9">More...</a><br /></td></tr>
<tr class="separator:a4526d2f0dde97eea9132047ea1dc5bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb6bf8a7cbfa70fb3e2dc943d379b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aefdb6bf8a7cbfa70fb3e2dc943d379b0">StartWithInsensitive</a> (const std::string &amp;s, const char *prefix)</td></tr>
<tr class="memdesc:aefdb6bf8a7cbfa70fb3e2dc943d379b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with a specified prefix, case-insensitive.  <a href="#aefdb6bf8a7cbfa70fb3e2dc943d379b0">More...</a><br /></td></tr>
<tr class="separator:aefdb6bf8a7cbfa70fb3e2dc943d379b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ad577f8980175a649df52aaaec1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a379ad577f8980175a649df52aaaec1c3">StartWithInsensitive</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a379ad577f8980175a649df52aaaec1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with a specified prefix, case-insensitive.  <a href="#a379ad577f8980175a649df52aaaec1c3">More...</a><br /></td></tr>
<tr class="separator:a379ad577f8980175a649df52aaaec1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9d029d4b1bc55e2ba770a8320617fb"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3d9d029d4b1bc55e2ba770a8320617fb">SubstituteAll</a> (std::string &amp;str, const std::string &amp;value, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a3d9d029d4b1bc55e2ba770a8320617fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all occurences of a string with another one.  <a href="#a3d9d029d4b1bc55e2ba770a8320617fb">More...</a><br /></td></tr>
<tr class="separator:a3d9d029d4b1bc55e2ba770a8320617fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff0f6fd630e4975f1af2816b9b183dc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0ff0f6fd630e4975f1af2816b9b183dc">TempDirectory</a> ()</td></tr>
<tr class="memdesc:a0ff0f6fd630e4975f1af2816b9b183dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of a directory for temporary files.  <a href="#a0ff0f6fd630e4975f1af2816b9b183dc">More...</a><br /></td></tr>
<tr class="separator:a0ff0f6fd630e4975f1af2816b9b183dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548a6055eeb4a2acf4a8b45d94483ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1548a6055eeb4a2acf4a8b45d94483ad">TempFile</a> (const std::string &amp;suffix=&quot;.tmp&quot;)</td></tr>
<tr class="memdesc:a1548a6055eeb4a2acf4a8b45d94483ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of a unique temporary file.  <a href="#a1548a6055eeb4a2acf4a8b45d94483ad">More...</a><br /></td></tr>
<tr class="separator:a1548a6055eeb4a2acf4a8b45d94483ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0a50ad635fadd171e9c3552bd03a4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc0a50ad635fadd171e9c3552bd03a4d">ToBitrate188</a> (<a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> bitrate204)</td></tr>
<tr class="memdesc:afc0a50ad635fadd171e9c3552bd03a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 204-byte packet bitrate into 188-byte packet bitrate.  <a href="#afc0a50ad635fadd171e9c3552bd03a4d">More...</a><br /></td></tr>
<tr class="separator:afc0a50ad635fadd171e9c3552bd03a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc5cded24e3c2859043129e1f66092b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6dc5cded24e3c2859043129e1f66092b">ToBitrate204</a> (<a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> bitrate188)</td></tr>
<tr class="memdesc:a6dc5cded24e3c2859043129e1f66092b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 188-byte packet bitrate into 204-byte packet bitrate.  <a href="#a6dc5cded24e3c2859043129e1f66092b">More...</a><br /></td></tr>
<tr class="separator:a6dc5cded24e3c2859043129e1f66092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeead29b0f6ee4348b34750bb720dd2"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aedeead29b0f6ee4348b34750bb720dd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aedeead29b0f6ee4348b34750bb720dd2">ToInteger</a> (INT &amp;value, const char *from, size_t length, const char *thousandSeparators=&quot;&quot;)</td></tr>
<tr class="memdesc:aedeead29b0f6ee4348b34750bb720dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into an integer.  <a href="#aedeead29b0f6ee4348b34750bb720dd2">More...</a><br /></td></tr>
<tr class="separator:aedeead29b0f6ee4348b34750bb720dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3271bf4f7fc74063f8ebdc7089a148"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a8f3271bf4f7fc74063f8ebdc7089a148"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a8f3271bf4f7fc74063f8ebdc7089a148">ToInteger</a> (INT &amp;value, const char *from, const char *thousandSeparators=&quot;&quot;)</td></tr>
<tr class="memdesc:a8f3271bf4f7fc74063f8ebdc7089a148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into an integer.  <a href="#a8f3271bf4f7fc74063f8ebdc7089a148">More...</a><br /></td></tr>
<tr class="separator:a8f3271bf4f7fc74063f8ebdc7089a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78ab9da22e14746ce87b385b226ccca"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa78ab9da22e14746ce87b385b226ccca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa78ab9da22e14746ce87b385b226ccca">ToInteger</a> (INT &amp;value, const std::string &amp;from, const char *thousandSeparators=&quot;&quot;)</td></tr>
<tr class="memdesc:aa78ab9da22e14746ce87b385b226ccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into an integer.  <a href="#aa78ab9da22e14746ce87b385b226ccca">More...</a><br /></td></tr>
<tr class="separator:aa78ab9da22e14746ce87b385b226ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11de7b466e0fbf2759d7cb1820242130"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a11de7b466e0fbf2759d7cb1820242130">ToIntegerDigit</a> (char c, int base=10, int defaultValue=-1)</td></tr>
<tr class="memdesc:a11de7b466e0fbf2759d7cb1820242130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character representing a multi-base integer digit into the corresponding integer value.  <a href="#a11de7b466e0fbf2759d7cb1820242130">More...</a><br /></td></tr>
<tr class="separator:a11de7b466e0fbf2759d7cb1820242130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab506bc57d5f6261a6b32aa548cec7c50"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ab506bc57d5f6261a6b32aa548cec7c50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ab506bc57d5f6261a6b32aa548cec7c50">ToIntegers</a> (CONTAINER &amp;container, const char *from, size_t length, const char *thousandSeparators=&quot;&quot;, const char *listSeparators=&quot;, &quot;)</td></tr>
<tr class="memdesc:ab506bc57d5f6261a6b32aa548cec7c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing a list of integers into a container of integers.  <a href="#ab506bc57d5f6261a6b32aa548cec7c50">More...</a><br /></td></tr>
<tr class="separator:ab506bc57d5f6261a6b32aa548cec7c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1986b0b72815d041b92189026b8b14ec"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a1986b0b72815d041b92189026b8b14ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a1986b0b72815d041b92189026b8b14ec">ToIntegers</a> (CONTAINER &amp;container, const char *from, const char *thousandSeparators=&quot;&quot;, const char *listSeparators=&quot;, &quot;)</td></tr>
<tr class="memdesc:a1986b0b72815d041b92189026b8b14ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing a list of integers into a container of integers.  <a href="#a1986b0b72815d041b92189026b8b14ec">More...</a><br /></td></tr>
<tr class="separator:a1986b0b72815d041b92189026b8b14ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4f9078f7a6ac87b521825fcd115bca"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:abe4f9078f7a6ac87b521825fcd115bca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#abe4f9078f7a6ac87b521825fcd115bca">ToIntegers</a> (CONTAINER &amp;container, const std::string &amp;from, const char *thousandSeparators=&quot;&quot;, const char *listSeparators=&quot;, &quot;)</td></tr>
<tr class="memdesc:abe4f9078f7a6ac87b521825fcd115bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing a list of integers into a container of integers.  <a href="#abe4f9078f7a6ac87b521825fcd115bca">More...</a><br /></td></tr>
<tr class="separator:abe4f9078f7a6ac87b521825fcd115bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e55c368064694ae66e6fa3454180ed"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a64e55c368064694ae66e6fa3454180ed">ToLower</a> (char c)</td></tr>
<tr class="memdesc:a64e55c368064694ae66e6fa3454180ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to lowercase.  <a href="#a64e55c368064694ae66e6fa3454180ed">More...</a><br /></td></tr>
<tr class="separator:a64e55c368064694ae66e6fa3454180ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd44c62e7b82e60cf923994a89caa096"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abd44c62e7b82e60cf923994a89caa096">ToLowerCase</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:abd44c62e7b82e60cf923994a89caa096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a string to lowercase.  <a href="#abd44c62e7b82e60cf923994a89caa096">More...</a><br /></td></tr>
<tr class="separator:abd44c62e7b82e60cf923994a89caa096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3964d8d1482f927971bb2bd106ec3e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3964d8d1482f927971bb2bd106ec3e0d">ToString</a> (const ::VARIANT &amp;s)</td></tr>
<tr class="memdesc:a3964d8d1482f927971bb2bd106ec3e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string to std::string (Windows-specific).  <a href="#a3964d8d1482f927971bb2bd106ec3e0d">More...</a><br /></td></tr>
<tr class="separator:a3964d8d1482f927971bb2bd106ec3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6e0a3b92162a15392c66e5998470a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4e6e0a3b92162a15392c66e5998470a0">ToString</a> (const ::BSTR s)</td></tr>
<tr class="memdesc:a4e6e0a3b92162a15392c66e5998470a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string to std::string (Windows-specific).  <a href="#a4e6e0a3b92162a15392c66e5998470a0">More...</a><br /></td></tr>
<tr class="separator:a4e6e0a3b92162a15392c66e5998470a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7e96e9a9eef01004dfbdc14431dfb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5f7e96e9a9eef01004dfbdc14431dfb3">ToString</a> (const ::WCHAR *s)</td></tr>
<tr class="memdesc:a5f7e96e9a9eef01004dfbdc14431dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Unicode string to std::string (Windows-specific).  <a href="#a5f7e96e9a9eef01004dfbdc14431dfb3">More...</a><br /></td></tr>
<tr class="separator:a5f7e96e9a9eef01004dfbdc14431dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae6f5cf0f1bfd1300f69104a46c512b"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acae6f5cf0f1bfd1300f69104a46c512b">ToUpper</a> (char c)</td></tr>
<tr class="memdesc:acae6f5cf0f1bfd1300f69104a46c512b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to uppercase.  <a href="#acae6f5cf0f1bfd1300f69104a46c512b">More...</a><br /></td></tr>
<tr class="separator:acae6f5cf0f1bfd1300f69104a46c512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4a092f09455169cfa57a8951bac3e"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acdf4a092f09455169cfa57a8951bac3e">ToUpperCase</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:acdf4a092f09455169cfa57a8951bac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a string to uppercase.  <a href="#acdf4a092f09455169cfa57a8951bac3e">More...</a><br /></td></tr>
<tr class="separator:acdf4a092f09455169cfa57a8951bac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83331155a2f7f09c1d919ba570cc263"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac83331155a2f7f09c1d919ba570cc263">Trim</a> (std::string &amp;str, bool leading=true, bool trailing=true)</td></tr>
<tr class="memdesc:ac83331155a2f7f09c1d919ba570cc263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and / or trailing space characters in a string.  <a href="#ac83331155a2f7f09c1d919ba570cc263">More...</a><br /></td></tr>
<tr class="separator:ac83331155a2f7f09c1d919ba570cc263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905341d5e67049eca079b9730d229797"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a905341d5e67049eca079b9730d229797">TrueFalse</a> (bool b)</td></tr>
<tr class="memdesc:a905341d5e67049eca079b9730d229797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "true" or "false".  <a href="#a905341d5e67049eca079b9730d229797">More...</a><br /></td></tr>
<tr class="separator:a905341d5e67049eca079b9730d229797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cabb9f3d1331e509c3bbe4a38b0fba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2cabb9f3d1331e509c3bbe4a38b0fba3">TruncateFile</a> (const std::string &amp;path, uint64_t size)</td></tr>
<tr class="memdesc:a2cabb9f3d1331e509c3bbe4a38b0fba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a file to the specified size.  <a href="#a2cabb9f3d1331e509c3bbe4a38b0fba3">More...</a><br /></td></tr>
<tr class="separator:a2cabb9f3d1331e509c3bbe4a38b0fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109c37b26251bd268a268d566743076c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a109c37b26251bd268a268d566743076c">UpperCaseValue</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a109c37b26251bd268a268d566743076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uppercase copy of a string.  <a href="#a109c37b26251bd268a268d566743076c">More...</a><br /></td></tr>
<tr class="separator:a109c37b26251bd268a268d566743076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c83d83ca1de817a6df4f30c056615"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a710c83d83ca1de817a6df4f30c056615">UserHomeDirectory</a> ()</td></tr>
<tr class="memdesc:a710c83d83ca1de817a6df4f30c056615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current user's home directory.  <a href="#a710c83d83ca1de817a6df4f30c056615">More...</a><br /></td></tr>
<tr class="separator:a710c83d83ca1de817a6df4f30c056615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b6fa8094989e30357301a679aa7a79"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af2b6fa8094989e30357301a679aa7a79">VernacularFilePath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:af2b6fa8094989e30357301a679aa7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a "vernacular" version of a file path.  <a href="#af2b6fa8094989e30357301a679aa7a79">More...</a><br /></td></tr>
<tr class="separator:af2b6fa8094989e30357301a679aa7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732dbdcd93f1b6cec64fe0496c76c5ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a732dbdcd93f1b6cec64fe0496c76c5ec">WrapUpPTS</a> (uint64_t pts1, uint64_t pts2)</td></tr>
<tr class="memdesc:a732dbdcd93f1b6cec64fe0496c76c5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if PTS2 follows PTS1 after wrap up.  <a href="#a732dbdcd93f1b6cec64fe0496c76c5ec">More...</a><br /></td></tr>
<tr class="separator:a732dbdcd93f1b6cec64fe0496c76c5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd917f9a32dab4b5f8d0adfb66356e0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5bd917f9a32dab4b5f8d0adfb66356e0">YesNo</a> (bool b)</td></tr>
<tr class="memdesc:a5bd917f9a32dab4b5f8d0adfb66356e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "yes" or "no".  <a href="#a5bd917f9a32dab4b5f8d0adfb66356e0">More...</a><br /></td></tr>
<tr class="separator:a5bd917f9a32dab4b5f8d0adfb66356e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e14fcda16e3d54676261db8d3a77953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4e14fcda16e3d54676261db8d3a77953">Zero</a> (void *addr, size_t size)</td></tr>
<tr class="memdesc:a4e14fcda16e3d54676261db8d3a77953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeroing a memory area.  <a href="#a4e14fcda16e3d54676261db8d3a77953">More...</a><br /></td></tr>
<tr class="separator:a4e14fcda16e3d54676261db8d3a77953"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa4445372617efb25a60af9ffeaca65f2"><td class="memItemLeft" align="right" valign="top"><a id="aa4445372617efb25a60af9ffeaca65f2"></a>
const <a class="el" href="namespacets.html#ab1d1f2460b477bc70d2e394204a2c09b">PIDSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa4445372617efb25a60af9ffeaca65f2">AllPIDs</a></td></tr>
<tr class="memdesc:aa4445372617efb25a60af9ffeaca65f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">PIDSet constant with all PID's set. <br /></td></tr>
<tr class="separator:aa4445372617efb25a60af9ffeaca65f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74c1bbf55da052525039a4dcd57281c"><td class="memItemLeft" align="right" valign="top"><a id="ae74c1bbf55da052525039a4dcd57281c"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae74c1bbf55da052525039a4dcd57281c">BandWidthEnum</a></td></tr>
<tr class="memdesc:ae74c1bbf55da052525039a4dcd57281c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31" title="Bandwidth (OFDM) ">ts::BandWidth</a>. <br /></td></tr>
<tr class="separator:ae74c1bbf55da052525039a4dcd57281c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b44a2eda0c3f3a4641948be29eb95fb"><td class="memItemLeft" align="right" valign="top"><a id="a1b44a2eda0c3f3a4641948be29eb95fb"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1b44a2eda0c3f3a4641948be29eb95fb">CC_BITS</a> = 4</td></tr>
<tr class="memdesc:a1b44a2eda0c3f3a4641948be29eb95fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size (in bits) of a Continuity Counter (CC) field. <br /></td></tr>
<tr class="separator:a1b44a2eda0c3f3a4641948be29eb95fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636e5b0b20d954dbf3426647e24799c9"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a636e5b0b20d954dbf3426647e24799c9">CC_MASK</a> = 0x0F</td></tr>
<tr class="memdesc:a636e5b0b20d954dbf3426647e24799c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to wrap a Continuity Counter (CC) value.  <a href="#a636e5b0b20d954dbf3426647e24799c9">More...</a><br /></td></tr>
<tr class="separator:a636e5b0b20d954dbf3426647e24799c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55a169e153bd77c1579abc033a10415"><td class="memItemLeft" align="right" valign="top"><a id="ac55a169e153bd77c1579abc033a10415"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac55a169e153bd77c1579abc033a10415">CC_MAX</a> = 1 &lt;&lt; <a class="el" href="namespacets.html#a1b44a2eda0c3f3a4641948be29eb95fb">CC_BITS</a></td></tr>
<tr class="memdesc:ac55a169e153bd77c1579abc033a10415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of a Continuity Counter (CC). <br /></td></tr>
<tr class="separator:ac55a169e153bd77c1579abc033a10415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb235de8cba6067ccd189dadfaceb70"><td class="memItemLeft" align="right" valign="top"><a id="abeb235de8cba6067ccd189dadfaceb70"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abeb235de8cba6067ccd189dadfaceb70">CW_BITS</a> = 64</td></tr>
<tr class="memdesc:abeb235de8cba6067ccd189dadfaceb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bits of a DVB Common <a class="el" href="classts_1_1_scrambling.html" title="DVB-CSA (Digital Video Broadcasting Common Scrambling Algorithm). ">Scrambling</a> (DVB-CS) Control Word (CW). <br /></td></tr>
<tr class="separator:abeb235de8cba6067ccd189dadfaceb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743c706866100a9d7c5b151d382706a7"><td class="memItemLeft" align="right" valign="top"><a id="a743c706866100a9d7c5b151d382706a7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a743c706866100a9d7c5b151d382706a7">CW_BYTES</a> = <a class="el" href="namespacets.html#abeb235de8cba6067ccd189dadfaceb70">CW_BITS</a> / 8</td></tr>
<tr class="memdesc:a743c706866100a9d7c5b151d382706a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a DVB Common <a class="el" href="classts_1_1_scrambling.html" title="DVB-CSA (Digital Video Broadcasting Common Scrambling Algorithm). ">Scrambling</a> (DVB-CS) Control Word (CW). <br /></td></tr>
<tr class="separator:a743c706866100a9d7c5b151d382706a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08728d90fb4a941abcd87daf268e519"><td class="memItemLeft" align="right" valign="top"><a id="aa08728d90fb4a941abcd87daf268e519"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa08728d90fb4a941abcd87daf268e519">DektecDVBTProperty</a></td></tr>
<tr class="memdesc:aa08728d90fb4a941abcd87daf268e519"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> (names/values) for Dektec DVB-T properties constants (DTAPI_MOD_DVBT_*, etc). <br /></td></tr>
<tr class="separator:aa08728d90fb4a941abcd87daf268e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd900aa7cc13578b437a3cbf8edbba4"><td class="memItemLeft" align="right" valign="top"><a id="a8bd900aa7cc13578b437a3cbf8edbba4"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8bd900aa7cc13578b437a3cbf8edbba4">DektecFEC</a></td></tr>
<tr class="memdesc:a8bd900aa7cc13578b437a3cbf8edbba4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> (names/values) for Dektec FEC constants (DTAPI_MOD_1_2, etc). <br /></td></tr>
<tr class="separator:a8bd900aa7cc13578b437a3cbf8edbba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834647b37ef41481815814f163ca8403"><td class="memItemLeft" align="right" valign="top"><a id="a834647b37ef41481815814f163ca8403"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a834647b37ef41481815814f163ca8403">DektecInversion</a></td></tr>
<tr class="memdesc:a834647b37ef41481815814f163ca8403"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> (names/values) for Dektec spectral inversion constants (DTAPI_MOD_SPECNONINV, etc). <br /></td></tr>
<tr class="separator:a834647b37ef41481815814f163ca8403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1eae956174efc9f1fd78f11b1dfd06"><td class="memItemLeft" align="right" valign="top"><a id="a0f1eae956174efc9f1fd78f11b1dfd06"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0f1eae956174efc9f1fd78f11b1dfd06">DektecModulationTypes</a></td></tr>
<tr class="memdesc:a0f1eae956174efc9f1fd78f11b1dfd06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> (names/values) for Dektec modulation constants (DTAPI_MOD_DVBS_QPSK, etc). <br /></td></tr>
<tr class="separator:a0f1eae956174efc9f1fd78f11b1dfd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a999baf2589a45014d0b6debbca25ab"><td class="memItemLeft" align="right" valign="top"><a id="a7a999baf2589a45014d0b6debbca25ab"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7a999baf2589a45014d0b6debbca25ab">DektecVSB</a></td></tr>
<tr class="memdesc:a7a999baf2589a45014d0b6debbca25ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> (names/values) for Dektec VSB constants (DTAPI_MOD_ATSC_VSB8, etc). <br /></td></tr>
<tr class="separator:a7a999baf2589a45014d0b6debbca25ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b1531a06ffa714192fb25eab8706e"><td class="memItemLeft" align="right" valign="top"><a id="ae08b1531a06ffa714192fb25eab8706e"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae08b1531a06ffa714192fb25eab8706e">DeliverySystemEnum</a></td></tr>
<tr class="memdesc:ae08b1531a06ffa714192fb25eab8706e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af" title="Delivery systems. ">ts::DeliverySystem</a>. <br /></td></tr>
<tr class="separator:ae08b1531a06ffa714192fb25eab8706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2fc9b02b88f7718d8f9a6a4d95d405"><td class="memItemLeft" align="right" valign="top"><a id="a1c2fc9b02b88f7718d8f9a6a4d95d405"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c2fc9b02b88f7718d8f9a6a4d95d405">DTA_FIFO_SIZE</a> = 8 * 1024 * 1024</td></tr>
<tr class="memdesc:a1c2fc9b02b88f7718d8f9a6a4d95d405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe size in bytes of the FIFO of DTA devices. <br /></td></tr>
<tr class="separator:a1c2fc9b02b88f7718d8f9a6a4d95d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7856250798a1a9f61be7f18869bb10b"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa7856250798a1a9f61be7f18869bb10b">DTA_MAX_HW_FUNC</a> = 75</td></tr>
<tr class="memdesc:aa7856250798a1a9f61be7f18869bb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of "hardware functions" per Dektec device.  <a href="#aa7856250798a1a9f61be7f18869bb10b">More...</a><br /></td></tr>
<tr class="separator:aa7856250798a1a9f61be7f18869bb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb82b6cb4a761e4fc84a9b6bc7cca42"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7bb82b6cb4a761e4fc84a9b6bc7cca42">DTA_MAX_IO_SIZE</a> = 6 * 1024 * 1024</td></tr>
<tr class="memdesc:a7bb82b6cb4a761e4fc84a9b6bc7cca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum I/O size in bytes of DTA devices.  <a href="#a7bb82b6cb4a761e4fc84a9b6bc7cca42">More...</a><br /></td></tr>
<tr class="separator:a7bb82b6cb4a761e4fc84a9b6bc7cca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772207b2b6d2c9383cf2ede5069ee5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structts_1_1_t_s_packet.html">TSPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab772207b2b6d2c9383cf2ede5069ee5d">EmptyPacket</a></td></tr>
<tr class="memdesc:ab772207b2b6d2c9383cf2ede5069ee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant is an empty packet (no payload).  <a href="#ab772207b2b6d2c9383cf2ede5069ee5d">More...</a><br /></td></tr>
<tr class="separator:ab772207b2b6d2c9383cf2ede5069ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8ea915908150d34fdf7c7ee6eaa946"><td class="memItemLeft" align="right" valign="top"><a id="a8d8ea915908150d34fdf7c7ee6eaa946"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8d8ea915908150d34fdf7c7ee6eaa946">GuardIntervalEnum</a></td></tr>
<tr class="memdesc:a8d8ea915908150d34fdf7c7ee6eaa946"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184" title="Guard interval (OFDM) ">ts::GuardInterval</a>. <br /></td></tr>
<tr class="separator:a8d8ea915908150d34fdf7c7ee6eaa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ce2ddca6b111b1f6f2ec2815a964c9"><td class="memItemLeft" align="right" valign="top"><a id="ab1ce2ddca6b111b1f6f2ec2815a964c9"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab1ce2ddca6b111b1f6f2ec2815a964c9">HierarchyEnum</a></td></tr>
<tr class="memdesc:ab1ce2ddca6b111b1f6f2ec2815a964c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350" title="Hierarchy (OFDM) ">ts::Hierarchy</a>. <br /></td></tr>
<tr class="separator:ab1ce2ddca6b111b1f6f2ec2815a964c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b91ccf90475c62f610ea549f69d8544"><td class="memItemLeft" align="right" valign="top"><a id="a6b91ccf90475c62f610ea549f69d8544"></a>
const <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6b91ccf90475c62f610ea549f69d8544">Infinite</a> =</td></tr>
<tr class="memdesc:a6b91ccf90475c62f610ea549f69d8544"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant shall be used by convention to express an infinite number of sub-quantities of seconds. <br /></td></tr>
<tr class="separator:a6b91ccf90475c62f610ea549f69d8544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edc929fa68aa96cd87ddab0edfe2143"><td class="memItemLeft" align="right" valign="top"><a id="a7edc929fa68aa96cd87ddab0edfe2143"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a7edc929fa68aa96cd87ddab0edfe2143">InnerFECEnum</a></td></tr>
<tr class="memdesc:a7edc929fa68aa96cd87ddab0edfe2143"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e" title="Inner Forward Error Correction. ">ts::InnerFEC</a>. <br /></td></tr>
<tr class="separator:a7edc929fa68aa96cd87ddab0edfe2143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca1a0c82a63583f56aab8f16f80278e"><td class="memItemLeft" align="right" valign="top"><a id="a3ca1a0c82a63583f56aab8f16f80278e"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3ca1a0c82a63583f56aab8f16f80278e">LONG_SECTION_HEADER_SIZE</a> = 8</td></tr>
<tr class="memdesc:a3ca1a0c82a63583f56aab8f16f80278e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header size of a long section. <br /></td></tr>
<tr class="separator:a3ca1a0c82a63583f56aab8f16f80278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515d4bd016eab6e66aec798058a3647"><td class="memItemLeft" align="right" valign="top"><a id="a8515d4bd016eab6e66aec798058a3647"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8515d4bd016eab6e66aec798058a3647">M2TS_HEADER_SIZE</a> = 4</td></tr>
<tr class="memdesc:a8515d4bd016eab6e66aec798058a3647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a timestamp preceeding a TS packet in M2TS files (Blu-ray disc). <br /></td></tr>
<tr class="separator:a8515d4bd016eab6e66aec798058a3647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034991316d5f718760e9cc0d96a6af1"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4034991316d5f718760e9cc0d96a6af1">MACROBLOCK_HEIGHT</a> = 16</td></tr>
<tr class="memdesc:a4034991316d5f718760e9cc0d96a6af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video macroblock height in pixels.  <a href="#a4034991316d5f718760e9cc0d96a6af1">More...</a><br /></td></tr>
<tr class="separator:a4034991316d5f718760e9cc0d96a6af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44869d633531ce62b6eb349395334b8b"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a44869d633531ce62b6eb349395334b8b">MACROBLOCK_WIDTH</a> = 16</td></tr>
<tr class="memdesc:a44869d633531ce62b6eb349395334b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video macroblock width in pixels.  <a href="#a44869d633531ce62b6eb349395334b8b">More...</a><br /></td></tr>
<tr class="separator:a44869d633531ce62b6eb349395334b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4151e444b31c1528b4022e199c11ae34"><td class="memItemLeft" align="right" valign="top"><a id="a4151e444b31c1528b4022e199c11ae34"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4151e444b31c1528b4022e199c11ae34">MAX_DESCRIPTOR_SIZE</a> = 257</td></tr>
<tr class="memdesc:a4151e444b31c1528b4022e199c11ae34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a descriptor (255 + 2-byte header). <br /></td></tr>
<tr class="separator:a4151e444b31c1528b4022e199c11ae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab542768b0b6e0c23c2eb8b8e3288e8"><td class="memItemLeft" align="right" valign="top"><a id="a1ab542768b0b6e0c23c2eb8b8e3288e8"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1ab542768b0b6e0c23c2eb8b8e3288e8">MAX_PRIVATE_LONG_SECTION_PAYLOAD_SIZE</a> = <a class="el" href="namespacets.html#ad58378ccdab287948940c8d120127cf7">MAX_PRIVATE_SECTION_SIZE</a> - <a class="el" href="namespacets.html#a3ca1a0c82a63583f56aab8f16f80278e">LONG_SECTION_HEADER_SIZE</a> - <a class="el" href="namespacets.html#a1e81aabdd7c062365378a3248b24a6ae">SECTION_CRC32_SIZE</a></td></tr>
<tr class="memdesc:a1ab542768b0b6e0c23c2eb8b8e3288e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the payload of a private long section. <br /></td></tr>
<tr class="separator:a1ab542768b0b6e0c23c2eb8b8e3288e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58378ccdab287948940c8d120127cf7"><td class="memItemLeft" align="right" valign="top"><a id="ad58378ccdab287948940c8d120127cf7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad58378ccdab287948940c8d120127cf7">MAX_PRIVATE_SECTION_SIZE</a> = 4096</td></tr>
<tr class="memdesc:ad58378ccdab287948940c8d120127cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a private section (including DVB-defined sections). <br /></td></tr>
<tr class="separator:ad58378ccdab287948940c8d120127cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca784a567721a90afb61f163bb8f728f"><td class="memItemLeft" align="right" valign="top"><a id="aca784a567721a90afb61f163bb8f728f"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aca784a567721a90afb61f163bb8f728f">MAX_PRIVATE_SHORT_SECTION_PAYLOAD_SIZE</a> = <a class="el" href="namespacets.html#ad58378ccdab287948940c8d120127cf7">MAX_PRIVATE_SECTION_SIZE</a> - <a class="el" href="namespacets.html#a13a01fc014e898f1f518e9ad828305bb">SHORT_SECTION_HEADER_SIZE</a></td></tr>
<tr class="memdesc:aca784a567721a90afb61f163bb8f728f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the payload of a private short section. <br /></td></tr>
<tr class="separator:aca784a567721a90afb61f163bb8f728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf4df8ac2396dbc2f3fc9211451325"><td class="memItemLeft" align="right" valign="top"><a id="a9dbf4df8ac2396dbc2f3fc9211451325"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9dbf4df8ac2396dbc2f3fc9211451325">MAX_PSI_LONG_SECTION_PAYLOAD_SIZE</a> = <a class="el" href="namespacets.html#a834064d29ff78658ed2c6af46e140953">MAX_PSI_SECTION_SIZE</a> - <a class="el" href="namespacets.html#a3ca1a0c82a63583f56aab8f16f80278e">LONG_SECTION_HEADER_SIZE</a> - <a class="el" href="namespacets.html#a1e81aabdd7c062365378a3248b24a6ae">SECTION_CRC32_SIZE</a></td></tr>
<tr class="memdesc:a9dbf4df8ac2396dbc2f3fc9211451325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the payload of a PSI long section. <br /></td></tr>
<tr class="separator:a9dbf4df8ac2396dbc2f3fc9211451325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834064d29ff78658ed2c6af46e140953"><td class="memItemLeft" align="right" valign="top"><a id="a834064d29ff78658ed2c6af46e140953"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a834064d29ff78658ed2c6af46e140953">MAX_PSI_SECTION_SIZE</a> = 1024</td></tr>
<tr class="memdesc:a834064d29ff78658ed2c6af46e140953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a PSI section (MPEG-defined). <br /></td></tr>
<tr class="separator:a834064d29ff78658ed2c6af46e140953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15d5086d8e3e1b4d826a5823b7a8cf"><td class="memItemLeft" align="right" valign="top"><a id="aaa15d5086d8e3e1b4d826a5823b7a8cf"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aaa15d5086d8e3e1b4d826a5823b7a8cf">MAX_PSI_SHORT_SECTION_PAYLOAD_SIZE</a> = <a class="el" href="namespacets.html#a834064d29ff78658ed2c6af46e140953">MAX_PSI_SECTION_SIZE</a> - <a class="el" href="namespacets.html#a13a01fc014e898f1f518e9ad828305bb">SHORT_SECTION_HEADER_SIZE</a></td></tr>
<tr class="memdesc:aaa15d5086d8e3e1b4d826a5823b7a8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the payload of a short section. <br /></td></tr>
<tr class="separator:aaa15d5086d8e3e1b4d826a5823b7a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf3f54f6cf6cb9586933ff8399d674b"><td class="memItemLeft" align="right" valign="top"><a id="abcf3f54f6cf6cb9586933ff8399d674b"></a>
const <a class="el" href="namespacets.html#ae996c4337196115e063c7b91bf79510e">MicroSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abcf3f54f6cf6cb9586933ff8399d674b">MicroSecPerMilliSec</a> = 1000</td></tr>
<tr class="memdesc:abcf3f54f6cf6cb9586933ff8399d674b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of microseconds per millisecond. <br /></td></tr>
<tr class="separator:abcf3f54f6cf6cb9586933ff8399d674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6679c4a9aba952879b7da520646198"><td class="memItemLeft" align="right" valign="top"><a id="ace6679c4a9aba952879b7da520646198"></a>
const <a class="el" href="namespacets.html#ae996c4337196115e063c7b91bf79510e">MicroSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ace6679c4a9aba952879b7da520646198">MicroSecPerSec</a> = 1000000</td></tr>
<tr class="memdesc:ace6679c4a9aba952879b7da520646198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of microseconds per second. <br /></td></tr>
<tr class="separator:ace6679c4a9aba952879b7da520646198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1261ea5ea24a0b939aad378855c9d5"><td class="memItemLeft" align="right" valign="top"><a id="a3b1261ea5ea24a0b939aad378855c9d5"></a>
const <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b1261ea5ea24a0b939aad378855c9d5">MilliSecPerDay</a> = 1000 * 60 * 60 * 24</td></tr>
<tr class="memdesc:a3b1261ea5ea24a0b939aad378855c9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per day. <br /></td></tr>
<tr class="separator:a3b1261ea5ea24a0b939aad378855c9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada065f3612eab8e440bf264dce8f0c41"><td class="memItemLeft" align="right" valign="top"><a id="ada065f3612eab8e440bf264dce8f0c41"></a>
const <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ada065f3612eab8e440bf264dce8f0c41">MilliSecPerHour</a> = 1000 * 60 * 60</td></tr>
<tr class="memdesc:ada065f3612eab8e440bf264dce8f0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per hour. <br /></td></tr>
<tr class="separator:ada065f3612eab8e440bf264dce8f0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550e2239393917c1e0f11aa6b5677e5"><td class="memItemLeft" align="right" valign="top"><a id="ab550e2239393917c1e0f11aa6b5677e5"></a>
const <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab550e2239393917c1e0f11aa6b5677e5">MilliSecPerMin</a> = 1000 * 60</td></tr>
<tr class="memdesc:ab550e2239393917c1e0f11aa6b5677e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per minute. <br /></td></tr>
<tr class="separator:ab550e2239393917c1e0f11aa6b5677e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527aa0a05bca6431521cf655a1edc8e"><td class="memItemLeft" align="right" valign="top"><a id="a8527aa0a05bca6431521cf655a1edc8e"></a>
const <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8527aa0a05bca6431521cf655a1edc8e">MilliSecPerSec</a> = 1000</td></tr>
<tr class="memdesc:a8527aa0a05bca6431521cf655a1edc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per second. <br /></td></tr>
<tr class="separator:a8527aa0a05bca6431521cf655a1edc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385020f9808698e1ca7ba6ea15c6bebe"><td class="memItemLeft" align="right" valign="top"><a id="a385020f9808698e1ca7ba6ea15c6bebe"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a385020f9808698e1ca7ba6ea15c6bebe">MIN_LONG_SECTION_SIZE</a> = <a class="el" href="namespacets.html#a3ca1a0c82a63583f56aab8f16f80278e">LONG_SECTION_HEADER_SIZE</a> + <a class="el" href="namespacets.html#a1e81aabdd7c062365378a3248b24a6ae">SECTION_CRC32_SIZE</a></td></tr>
<tr class="memdesc:a385020f9808698e1ca7ba6ea15c6bebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of a long section. <br /></td></tr>
<tr class="separator:a385020f9808698e1ca7ba6ea15c6bebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0d2d8098a57026bcedf1e2a2e8aefa"><td class="memItemLeft" align="right" valign="top"><a id="a1c0d2d8098a57026bcedf1e2a2e8aefa"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c0d2d8098a57026bcedf1e2a2e8aefa">MIN_SHORT_SECTION_SIZE</a> = <a class="el" href="namespacets.html#a13a01fc014e898f1f518e9ad828305bb">SHORT_SECTION_HEADER_SIZE</a></td></tr>
<tr class="memdesc:a1c0d2d8098a57026bcedf1e2a2e8aefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of a short section. <br /></td></tr>
<tr class="separator:a1c0d2d8098a57026bcedf1e2a2e8aefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791105205bda054589f97061752ee029"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a791105205bda054589f97061752ee029">MJD_EPOCH</a> = 40587</td></tr>
<tr class="memdesc:a791105205bda054589f97061752ee029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Origin of Modified Julian Dates (MJD).  <a href="#a791105205bda054589f97061752ee029">More...</a><br /></td></tr>
<tr class="separator:a791105205bda054589f97061752ee029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aabb15437c766330177f7f4336d894"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a89aabb15437c766330177f7f4336d894">MJD_MIN_SIZE</a> = 2</td></tr>
<tr class="memdesc:a89aabb15437c766330177f7f4336d894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal size in bytes of an encoded Modified Julian Date (MJD), ie.  <a href="#a89aabb15437c766330177f7f4336d894">More...</a><br /></td></tr>
<tr class="separator:a89aabb15437c766330177f7f4336d894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192899c7f25c8326fb9cb167714eeb8"><td class="memItemLeft" align="right" valign="top"><a id="a3192899c7f25c8326fb9cb167714eeb8"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3192899c7f25c8326fb9cb167714eeb8">MJD_SIZE</a> = 5</td></tr>
<tr class="memdesc:a3192899c7f25c8326fb9cb167714eeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of an encoded complete Modified Julian Date (MJD). <br /></td></tr>
<tr class="separator:a3192899c7f25c8326fb9cb167714eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8537017088d4075f48cc18895a21f947"><td class="memItemLeft" align="right" valign="top"><a id="a8537017088d4075f48cc18895a21f947"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8537017088d4075f48cc18895a21f947">ModulationEnum</a></td></tr>
<tr class="memdesc:a8537017088d4075f48cc18895a21f947"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58" title="Modulation types. ">ts::Modulation</a>. <br /></td></tr>
<tr class="separator:a8537017088d4075f48cc18895a21f947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5026fdf7e76abd5ddc916485aee90d3"><td class="memItemLeft" align="right" valign="top"><a id="aa5026fdf7e76abd5ddc916485aee90d3"></a>
const <a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">NanoSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa5026fdf7e76abd5ddc916485aee90d3">NanoSecPerMicroSec</a> = 1000</td></tr>
<tr class="memdesc:aa5026fdf7e76abd5ddc916485aee90d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per microsecond. <br /></td></tr>
<tr class="separator:aa5026fdf7e76abd5ddc916485aee90d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6152f80180efe63539259baba67b6b"><td class="memItemLeft" align="right" valign="top"><a id="a1e6152f80180efe63539259baba67b6b"></a>
const <a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">NanoSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1e6152f80180efe63539259baba67b6b">NanoSecPerMilliSec</a> = 1000000</td></tr>
<tr class="memdesc:a1e6152f80180efe63539259baba67b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per millisecond. <br /></td></tr>
<tr class="separator:a1e6152f80180efe63539259baba67b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07088c08e01c6a37d53a9dda4d053560"><td class="memItemLeft" align="right" valign="top"><a id="a07088c08e01c6a37d53a9dda4d053560"></a>
const <a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">NanoSecond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a07088c08e01c6a37d53a9dda4d053560">NanoSecPerSec</a> = 1000000000</td></tr>
<tr class="memdesc:a07088c08e01c6a37d53a9dda4d053560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per second. <br /></td></tr>
<tr class="separator:a07088c08e01c6a37d53a9dda4d053560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38c792159073aeb903a73f38eef3519"><td class="memItemLeft" align="right" valign="top"><a id="aa38c792159073aeb903a73f38eef3519"></a>
const <a class="el" href="namespacets.html#ab1d1f2460b477bc70d2e394204a2c09b">PIDSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa38c792159073aeb903a73f38eef3519">NoPID</a></td></tr>
<tr class="memdesc:aa38c792159073aeb903a73f38eef3519"><td class="mdescLeft">&#160;</td><td class="mdescRight">PIDSet constant with no PID set. <br /></td></tr>
<tr class="separator:aa38c792159073aeb903a73f38eef3519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c1c5cc3f330f73c01f467bf1bf07f"><td class="memItemLeft" align="right" valign="top"><a id="aef0c1c5cc3f330f73c01f467bf1bf07f"></a>
const <a class="el" href="structts_1_1_t_s_packet.html">TSPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aef0c1c5cc3f330f73c01f467bf1bf07f">NullPacket</a></td></tr>
<tr class="memdesc:aef0c1c5cc3f330f73c01f467bf1bf07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant is a null (or stuffing) packet. <br /></td></tr>
<tr class="separator:aef0c1c5cc3f330f73c01f467bf1bf07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5180615eff4262fa0148f665c523991"><td class="memItemLeft" align="right" valign="top"><a id="ae5180615eff4262fa0148f665c523991"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae5180615eff4262fa0148f665c523991">PathSeparator</a> = platform_specific ('/', '\\')</td></tr>
<tr class="memdesc:ae5180615eff4262fa0148f665c523991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directory separator character in file paths. <br /></td></tr>
<tr class="separator:ae5180615eff4262fa0148f665c523991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab426d495151a075de18d2c11793d746c"><td class="memItemLeft" align="right" valign="top"><a id="ab426d495151a075de18d2c11793d746c"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab426d495151a075de18d2c11793d746c">PCR_SIZE</a> = 6</td></tr>
<tr class="memdesc:ab426d495151a075de18d2c11793d746c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a Program Clock Reference (PCR). <br /></td></tr>
<tr class="separator:ab426d495151a075de18d2c11793d746c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c477541f098e5872c177c2aa1e680ca"><td class="memItemLeft" align="right" valign="top"><a id="a0c477541f098e5872c177c2aa1e680ca"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0c477541f098e5872c177c2aa1e680ca">PES_START</a> = 0x000001</td></tr>
<tr class="memdesc:a0c477541f098e5872c177c2aa1e680ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">PES packet start code prefix (24 bits). <br /></td></tr>
<tr class="separator:a0c477541f098e5872c177c2aa1e680ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718650e4fb8f881426c4ef517b29e43"><td class="memItemLeft" align="right" valign="top"><a id="af718650e4fb8f881426c4ef517b29e43"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af718650e4fb8f881426c4ef517b29e43">PID_BITS</a> = 13</td></tr>
<tr class="memdesc:af718650e4fb8f881426c4ef517b29e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size (in bits) of a PID field. <br /></td></tr>
<tr class="separator:af718650e4fb8f881426c4ef517b29e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81895f76b9b59ec18ee3205408aa5e4"><td class="memItemLeft" align="right" valign="top"><a id="aa81895f76b9b59ec18ee3205408aa5e4"></a>
const <a class="el" href="namespacets.html#a90e2f5f7d7011d87cc23a8fef31958dc">PID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa81895f76b9b59ec18ee3205408aa5e4">PID_MAX</a> = 1 &lt;&lt; <a class="el" href="namespacets.html#af718650e4fb8f881426c4ef517b29e43">PID_BITS</a></td></tr>
<tr class="memdesc:aa81895f76b9b59ec18ee3205408aa5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of PID's (8192). <br /></td></tr>
<tr class="separator:aa81895f76b9b59ec18ee3205408aa5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a7804baff7cb169e9f4b06a9db542"><td class="memItemLeft" align="right" valign="top"><a id="a8b9a7804baff7cb169e9f4b06a9db542"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8b9a7804baff7cb169e9f4b06a9db542">PilotEnum</a></td></tr>
<tr class="memdesc:a8b9a7804baff7cb169e9f4b06a9db542"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538d" title="Pilot (DVB-S2) ">ts::Pilot</a>. <br /></td></tr>
<tr class="separator:a8b9a7804baff7cb169e9f4b06a9db542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfcd0a5c6d992829a38268acacd3827"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1dfcd0a5c6d992829a38268acacd3827">PKT_M2TS_SIZE</a> = <a class="el" href="namespacets.html#a8515d4bd016eab6e66aec798058a3647">M2TS_HEADER_SIZE</a> + <a class="el" href="namespacets.html#a29cecff9c6ed61e3cf69a84301b5483b">PKT_SIZE</a></td></tr>
<tr class="memdesc:a1dfcd0a5c6d992829a38268acacd3827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of an TS packet in M2TS files (Blu-ray disc).  <a href="#a1dfcd0a5c6d992829a38268acacd3827">More...</a><br /></td></tr>
<tr class="separator:a1dfcd0a5c6d992829a38268acacd3827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11467ab50c441d2ed5cc8869506a51d"><td class="memItemLeft" align="right" valign="top"><a id="ac11467ab50c441d2ed5cc8869506a51d"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac11467ab50c441d2ed5cc8869506a51d">PKT_RS_SIZE</a> = <a class="el" href="namespacets.html#a29cecff9c6ed61e3cf69a84301b5483b">PKT_SIZE</a> + <a class="el" href="namespacets.html#abf0f257912dcfc16c5df6ca735ac95a4">RS_SIZE</a></td></tr>
<tr class="memdesc:ac11467ab50c441d2ed5cc8869506a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a TS packet with trailing Reed-Solomon outer FEC. <br /></td></tr>
<tr class="separator:ac11467ab50c441d2ed5cc8869506a51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cecff9c6ed61e3cf69a84301b5483b"><td class="memItemLeft" align="right" valign="top"><a id="a29cecff9c6ed61e3cf69a84301b5483b"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a29cecff9c6ed61e3cf69a84301b5483b">PKT_SIZE</a> = 188</td></tr>
<tr class="memdesc:a29cecff9c6ed61e3cf69a84301b5483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG TS packet size in bytes. <br /></td></tr>
<tr class="separator:a29cecff9c6ed61e3cf69a84301b5483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae056c4f98896e847774492c513c12ee5"><td class="memItemLeft" align="right" valign="top"><a id="ae056c4f98896e847774492c513c12ee5"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae056c4f98896e847774492c513c12ee5">PolarizationEnum</a></td></tr>
<tr class="memdesc:ae056c4f98896e847774492c513c12ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90" title="Polarization. ">ts::Polarization</a>. <br /></td></tr>
<tr class="separator:ae056c4f98896e847774492c513c12ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916f9655725a5d7a628b3fb3a112a88e"><td class="memItemLeft" align="right" valign="top"><a id="a916f9655725a5d7a628b3fb3a112a88e"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a916f9655725a5d7a628b3fb3a112a88e">PTS_DTS_MASK</a> =</td></tr>
<tr class="memdesc:a916f9655725a5d7a628b3fb3a112a88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for PTS and DTS values (wrap up at 2**33). <br /></td></tr>
<tr class="separator:a916f9655725a5d7a628b3fb3a112a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa658a655007efb1a7387c2f459686a34"><td class="memItemLeft" align="right" valign="top"><a id="aa658a655007efb1a7387c2f459686a34"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa658a655007efb1a7387c2f459686a34">PTS_DTS_SCALE</a> =</td></tr>
<tr class="memdesc:aa658a655007efb1a7387c2f459686a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale factor for PTS and DTS values (wrap up at 2**33). <br /></td></tr>
<tr class="separator:aa658a655007efb1a7387c2f459686a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab758471be44b695330f04987b17b76ee"><td class="memItemLeft" align="right" valign="top"><a id="ab758471be44b695330f04987b17b76ee"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab758471be44b695330f04987b17b76ee">RollOffEnum</a></td></tr>
<tr class="memdesc:ab758471be44b695330f04987b17b76ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201f" title="Roll-off (DVB-S2) ">ts::RollOff</a>. <br /></td></tr>
<tr class="separator:ab758471be44b695330f04987b17b76ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0f257912dcfc16c5df6ca735ac95a4"><td class="memItemLeft" align="right" valign="top"><a id="abf0f257912dcfc16c5df6ca735ac95a4"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abf0f257912dcfc16c5df6ca735ac95a4">RS_SIZE</a> = 16</td></tr>
<tr class="memdesc:abf0f257912dcfc16c5df6ca735ac95a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a Reed-Solomon outer FEC. <br /></td></tr>
<tr class="separator:abf0f257912dcfc16c5df6ca735ac95a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bfbacd579a23b09e4b6d9d14ae9d7b"><td class="memItemLeft" align="right" valign="top"><a id="a61bfbacd579a23b09e4b6d9d14ae9d7b"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a61bfbacd579a23b09e4b6d9d14ae9d7b">SearchPathSeparator</a> = platform_specific (':', ';')</td></tr>
<tr class="memdesc:a61bfbacd579a23b09e4b6d9d14ae9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character in search paths. <br /></td></tr>
<tr class="separator:a61bfbacd579a23b09e4b6d9d14ae9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e81aabdd7c062365378a3248b24a6ae"><td class="memItemLeft" align="right" valign="top"><a id="a1e81aabdd7c062365378a3248b24a6ae"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1e81aabdd7c062365378a3248b24a6ae">SECTION_CRC32_SIZE</a> = 4</td></tr>
<tr class="memdesc:a1e81aabdd7c062365378a3248b24a6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> field in a long section. <br /></td></tr>
<tr class="separator:a1e81aabdd7c062365378a3248b24a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a01fc014e898f1f518e9ad828305bb"><td class="memItemLeft" align="right" valign="top"><a id="a13a01fc014e898f1f518e9ad828305bb"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a13a01fc014e898f1f518e9ad828305bb">SHORT_SECTION_HEADER_SIZE</a> = 3</td></tr>
<tr class="memdesc:a13a01fc014e898f1f518e9ad828305bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header size of a short section. <br /></td></tr>
<tr class="separator:a13a01fc014e898f1f518e9ad828305bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3bffd5e915197fd7407e42be2e11e"><td class="memItemLeft" align="right" valign="top"><a id="a54b3bffd5e915197fd7407e42be2e11e"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a54b3bffd5e915197fd7407e42be2e11e">SpectralInversionEnum</a></td></tr>
<tr class="memdesc:a54b3bffd5e915197fd7407e42be2e11e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6" title="Spectral inversion. ">ts::SpectralInversion</a>. <br /></td></tr>
<tr class="separator:a54b3bffd5e915197fd7407e42be2e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa837151f28a957bbe15910280206c3b0"><td class="memItemLeft" align="right" valign="top"><a id="aa837151f28a957bbe15910280206c3b0"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa837151f28a957bbe15910280206c3b0">SVERSION_BITS</a> = 5</td></tr>
<tr class="memdesc:aa837151f28a957bbe15910280206c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size (in bits) of a section version field. <br /></td></tr>
<tr class="separator:aa837151f28a957bbe15910280206c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c4762bb3ca7b93157c4c7dc4f6430a"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a83c4762bb3ca7b93157c4c7dc4f6430a">SVERSION_MASK</a> = 0x1F</td></tr>
<tr class="memdesc:a83c4762bb3ca7b93157c4c7dc4f6430a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to wrap a section version value.  <a href="#a83c4762bb3ca7b93157c4c7dc4f6430a">More...</a><br /></td></tr>
<tr class="separator:a83c4762bb3ca7b93157c4c7dc4f6430a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a1b4522d200cfb5ce3a8927fd7ad26"><td class="memItemLeft" align="right" valign="top"><a id="aa3a1b4522d200cfb5ce3a8927fd7ad26"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa3a1b4522d200cfb5ce3a8927fd7ad26">SVERSION_MAX</a> = 1 &lt;&lt; <a class="el" href="namespacets.html#aa837151f28a957bbe15910280206c3b0">SVERSION_BITS</a></td></tr>
<tr class="memdesc:aa3a1b4522d200cfb5ce3a8927fd7ad26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of a section version. <br /></td></tr>
<tr class="separator:aa3a1b4522d200cfb5ce3a8927fd7ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ade20f1fcc7b100d0148bb6b12eadf"><td class="memItemLeft" align="right" valign="top"><a id="af3ade20f1fcc7b100d0148bb6b12eadf"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af3ade20f1fcc7b100d0148bb6b12eadf">SYNC_BYTE</a> = 0x47</td></tr>
<tr class="memdesc:af3ade20f1fcc7b100d0148bb6b12eadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of a sync byte (first byte in a TS packet). <br /></td></tr>
<tr class="separator:af3ade20f1fcc7b100d0148bb6b12eadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67013ae18c714713055aa25de3a24568"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a67013ae18c714713055aa25de3a24568">SYS_DATA_ERROR</a> = platform_specific</td></tr>
<tr class="memdesc:a67013ae18c714713055aa25de3a24568"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating a generic data error.  <a href="#a67013ae18c714713055aa25de3a24568">More...</a><br /></td></tr>
<tr class="separator:a67013ae18c714713055aa25de3a24568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5c31a3d1b0122eb8863cc6feaef7df44">SYS_SUCCESS</a> = platform_specific</td></tr>
<tr class="memdesc:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating success.  <a href="#a5c31a3d1b0122eb8863cc6feaef7df44">More...</a><br /></td></tr>
<tr class="separator:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eea8e0ad4391f9497e2378b6200b924"><td class="memItemLeft" align="right" valign="top"><a id="a3eea8e0ad4391f9497e2378b6200b924"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3eea8e0ad4391f9497e2378b6200b924">SYSTEM_CLOCK_FREQ</a> = 27000000</td></tr>
<tr class="memdesc:a3eea8e0ad4391f9497e2378b6200b924"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG-2 System Clock frequency in Hz, used by PCR (27 Mb/s). <br /></td></tr>
<tr class="separator:a3eea8e0ad4391f9497e2378b6200b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7100987f607b9ccfe240b17d733e7"><td class="memItemLeft" align="right" valign="top"><a id="a41a7100987f607b9ccfe240b17d733e7"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a41a7100987f607b9ccfe240b17d733e7">SYSTEM_CLOCK_SUBFACTOR</a> = 300</td></tr>
<tr class="memdesc:a41a7100987f607b9ccfe240b17d733e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subfactor of MPEG-2 System Clock subfrequency, used by PTS and DTS. <br /></td></tr>
<tr class="separator:a41a7100987f607b9ccfe240b17d733e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf43004a770968750aa113c7aa1c050"><td class="memItemLeft" align="right" valign="top"><a id="a8cf43004a770968750aa113c7aa1c050"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8cf43004a770968750aa113c7aa1c050">SYSTEM_CLOCK_SUBFREQ</a> = <a class="el" href="namespacets.html#a3eea8e0ad4391f9497e2378b6200b924">SYSTEM_CLOCK_FREQ</a> / <a class="el" href="namespacets.html#a41a7100987f607b9ccfe240b17d733e7">SYSTEM_CLOCK_SUBFACTOR</a></td></tr>
<tr class="memdesc:a8cf43004a770968750aa113c7aa1c050"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG-2 System Clock subfrequency in Hz, used by PTS and DTS (90 Kb/s). <br /></td></tr>
<tr class="separator:a8cf43004a770968750aa113c7aa1c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2161295533c01929c92498205b010bf2"><td class="memItemLeft" align="right" valign="top"><a id="a2161295533c01929c92498205b010bf2"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2161295533c01929c92498205b010bf2">TID_MAX</a> = 0x100</td></tr>
<tr class="memdesc:a2161295533c01929c92498205b010bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of TID values. <br /></td></tr>
<tr class="separator:a2161295533c01929c92498205b010bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0248dd6d8c1c999af4911223a11f9f78"><td class="memItemLeft" align="right" valign="top"><a id="a0248dd6d8c1c999af4911223a11f9f78"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0248dd6d8c1c999af4911223a11f9f78">TransmissionModeEnum</a></td></tr>
<tr class="memdesc:a0248dd6d8c1c999af4911223a11f9f78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5" title="Transmission mode (OFDM) ">ts::TransmissionMode</a>. <br /></td></tr>
<tr class="separator:a0248dd6d8c1c999af4911223a11f9f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59984c0cf744eace5b5958139c28651"><td class="memItemLeft" align="right" valign="top"><a id="ac59984c0cf744eace5b5958139c28651"></a>
const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac59984c0cf744eace5b5958139c28651">TunerTypeEnum</a></td></tr>
<tr class="memdesc:ac59984c0cf744eace5b5958139c28651"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2" title="Known tuner types. ">ts::TunerType</a>. <br /></td></tr>
<tr class="separator:ac59984c0cf744eace5b5958139c28651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afcbbc5e6e8a897709aa196e0b87559"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4afcbbc5e6e8a897709aa196e0b87559">VersionFormatEnum</a></td></tr>
<tr class="memdesc:a4afcbbc5e6e8a897709aa196e0b87559"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa" title="Types of version formatting, for predefined option –version. ">ts::VersionFormat</a>.  <a href="#a4afcbbc5e6e8a897709aa196e0b87559">More...</a><br /></td></tr>
<tr class="separator:a4afcbbc5e6e8a897709aa196e0b87559"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TSDuck namespace, containing all TSDuck classes and functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a56c2950340ed7ec04326cd8c1827bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c2950340ed7ec04326cd8c1827bccd">&#9670;&nbsp;</a></span>NewGenTabPluginProfile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classts_1_1_gen_tab_plugin.html">GenTabPlugin</a>*(* ts::NewGenTabPluginProfile) ()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tsgentab plugin interface profile. </p>
<p>All shared libraries providing a tsgentab plugin shall export a global function named <code>tsgentabNewPlugin</code> with the following profile.</p>
<dl class="section return"><dt>Returns</dt><dd>A new allocated object implementing <a class="el" href="classts_1_1_gen_tab_plugin.html" title="Abstract base class of all tsgentab plugins. ">ts::GenTabPlugin</a>. </dd></dl>

</div>
</div>
<a id="af043fba2c2a5edefb756223dd56ffa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af043fba2c2a5edefb756223dd56ffa96">&#9670;&nbsp;</a></span>DeliverySystemSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bitset&lt;size_t(<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94afabb6e9da27299136faabde20bc6f7b0c5">DS_COUNT</a>)&gt; <a class="el" href="namespacets.html#af043fba2c2a5edefb756223dd56ffa96">ts::DeliverySystemSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of delivery system values (<a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af" title="Delivery systems. ">ts::DeliverySystem</a>). </p>
<p>Typically used to indicate the list of standards which are supported by a tuner. </p>

</div>
</div>
<a id="a9cdec7a120783847f53fbf71e5eb49f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdec7a120783847f53fbf71e5eb49f6">&#9670;&nbsp;</a></span>PacketCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">ts::PacketCounter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of Transport Stream packets. </p>
<p>TS packets are counted using 64-bit integers. Thus, PacketCounter will never overflow: at 100 Mb/s, 2^64 188-byte packets will take 8.7 million years to transmit. No process will ever run that long. On the contrary, using 32-bit integer would be insufficient: at 100 Mb/s, 2^32 188-byte packets will take only 17 hours to transmit. </p>

</div>
</div>
<a id="ab1d1f2460b477bc70d2e394204a2c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1f2460b477bc70d2e394204a2c09b">&#9670;&nbsp;</a></span>PIDSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bitset&lt;<a class="el" href="namespacets.html#aa81895f76b9b59ec18ee3205408aa5e4">PID_MAX</a>&gt; <a class="el" href="namespacets.html#ab1d1f2460b477bc70d2e394204a2c09b">ts::PIDSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bit mask for PID values. </p>
<p>Useful to implement PID filtering. </p>

</div>
</div>
<a id="ab310e3cadb18cb3e6e7d1e7bb403d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab310e3cadb18cb3e6e7d1e7bb403d4d8">&#9670;&nbsp;</a></span>SubSecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">ts::SubSecond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer type is used to represent any sub-quantity of seconds. </p>
<p>This type is mostly used as parent for all other representations of sub-quantities of seconds (<a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>, <a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">NanoSecond</a>, etc.) Although these types are all identical, they should be used explicitely for clarity. Thus, when reading some code, it the variable for a duration has type MilliSecond, it is clear that it contains a number of milliseconds, not seconds or microseconds.</p>
<p>Note that this is a signed type. A number of sub-quantities of seconds can be negative, indicating a duration backward. </p>

</div>
</div>
<a id="a38592708fbf21dafd004afa1136586c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38592708fbf21dafd004afa1136586c7">&#9670;&nbsp;</a></span>Second</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a> <a class="el" href="namespacets.html#a38592708fbf21dafd004afa1136586c7">ts::Second</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer type is used to represent a number of seconds. </p>
<p>Should be explicitely used for clarity when a variable contains a number of seconds. </p>

</div>
</div>
<a id="a2c690abc5d90fe5ba7c3ec0237afc348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c690abc5d90fe5ba7c3ec0237afc348">&#9670;&nbsp;</a></span>MilliSecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a> <a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">ts::MilliSecond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer type is used to represent a number of milliseconds. </p>
<p>Should be explicitely used for clarity when a variable contains a number of milliseconds. </p>

</div>
</div>
<a id="ae996c4337196115e063c7b91bf79510e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae996c4337196115e063c7b91bf79510e">&#9670;&nbsp;</a></span>MicroSecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a> <a class="el" href="namespacets.html#ae996c4337196115e063c7b91bf79510e">ts::MicroSecond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer type is used to represent a number of microseconds. </p>
<p>Should be explicitely used for clarity when a variable contains a number of microseconds. </p>

</div>
</div>
<a id="acd890ba84c12ced734201afae32a3e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd890ba84c12ced734201afae32a3e95">&#9670;&nbsp;</a></span>NanoSecond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">SubSecond</a> <a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">ts::NanoSecond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer type is used to represent a number of nanoseconds. </p>
<p>Should be explicitely used for clarity when a variable contains a number of nanoseconds. </p>

</div>
</div>
<a id="ac0db0ec9658176bb813bf254c58f2250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0db0ec9658176bb813bf254c58f2250">&#9670;&nbsp;</a></span>NewInputProfile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classts_1_1_input_plugin.html">InputPlugin</a>*(* ts::NewInputProfile) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input plugin interface profile. </p>
<p>All shared libraries providing input capability shall export a global function named <code>tspNewInput</code> with the following profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tsp</td><td>Associated callback to <code>tsp</code> executable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new allocated object implementing <a class="el" href="classts_1_1_input_plugin.html" title="Input tsp plugin interface. ">ts::InputPlugin</a>. </dd></dl>

</div>
</div>
<a id="a9749300d3760618455d38fa9d5aac02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9749300d3760618455d38fa9d5aac02b">&#9670;&nbsp;</a></span>NewOutputProfile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classts_1_1_output_plugin.html">OutputPlugin</a>*(* ts::NewOutputProfile) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output plugin interface profile. </p>
<p>All shared libraries providing output capability shall export a global function named <code>tspNewOutput</code> with the following profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tsp</td><td>Associated callback to <code>tsp</code> executable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new allocated object implementing <a class="el" href="classts_1_1_output_plugin.html" title="Output tsp plugin interface. ">ts::OutputPlugin</a>. </dd></dl>

</div>
</div>
<a id="ab4b051128af01bb7efab96954943abc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b051128af01bb7efab96954943abc4">&#9670;&nbsp;</a></span>NewProcessorProfile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classts_1_1_processor_plugin.html">ProcessorPlugin</a>*(* ts::NewProcessorProfile) (const <a class="el" href="classts_1_1_t_s_p.html">TSP</a> *tsp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet processing plugin interface profile. </p>
<p>All shared libraries providing packet processing shall export a global function named <code>tspNewProcessor</code> with the following profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tsp</td><td>Associated callback to <code>tsp</code> executable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new allocated object implementing <a class="el" href="classts_1_1_processor_plugin.html" title="Packet processing tsp plugin interface. ">ts::ProcessorPlugin</a>. </dd></dl>

</div>
</div>
<a id="a193fcb3d69633d775555333ad51c9cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193fcb3d69633d775555333ad51c9cc1">&#9670;&nbsp;</a></span>Environment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::string&gt; <a class="el" href="namespacets.html#a193fcb3d69633d775555333ad51c9cc1">ts::Environment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a container type holding all environment variables. </p>
<p>For each element in the container, the <em>key</em> is the name of an environment variable and the <em>value</em> is the corresponding value of this environment variable. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1de171688c3a6ff71896a8f3e5817c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de171688c3a6ff71896a8f3e5817c11">&#9670;&nbsp;</a></span>CASFamily</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11">ts::CASFamily</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Known Conditional Access Systems families. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11a79bba7cbc9e78632bc132244f9c83d9e"></a>CAS_OTHER&#160;</td><td class="fielddoc"><p>Unknown CAS. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11a34ef926344fa76ad37e4c914225f3086"></a>CAS_MEDIAGUARD&#160;</td><td class="fielddoc"><p>MediaGuard (Canal+ Technologies). </p>
</td></tr>
<tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11a052e2f867595b687b227bb8c3baa9bf7"></a>CAS_NAGRA&#160;</td><td class="fielddoc"><p>Nagravision. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11a31588d8b5cdb65efd8fd6f62e85af5c8"></a>CAS_VIACCESS&#160;</td><td class="fielddoc"><p>Viaccess. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11acd138ce077fb1c0d2b69f7e14c39202c"></a>CAS_THALESCRYPT&#160;</td><td class="fielddoc"><p>ThalesCrypt (for TPS). </p>
</td></tr>
<tr><td class="fieldname"><a id="a1de171688c3a6ff71896a8f3e5817c11a6c7174e9a4df3ea5e3140ecf412de773"></a>CAS_SAFEACCESS&#160;</td><td class="fielddoc"><p>SafeAccess (Logiways). </p>
</td></tr>
</table>

</div>
</div>
<a id="a0bfe51c83f30216c9beaac7fc31f96d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfe51c83f30216c9beaac7fc31f96d2">&#9670;&nbsp;</a></span>TunerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2">ts::TunerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Known tuner types. </p>
<p>"Second generation" tuners are included in their base category: DVB_S includes DVB-S and DVB-S2, DVB_T includes DVB-T and DVB-T2, etc. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0bfe51c83f30216c9beaac7fc31f96d2a8825bfa004ac099ccdc7c26bd8d7ac0e"></a>DVB_S&#160;</td><td class="fielddoc"><p>DVB-S, DVB-S2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0bfe51c83f30216c9beaac7fc31f96d2a432b464338b95b35eb73bffe97bb0ef6"></a>DVB_C&#160;</td><td class="fielddoc"><p>DVB-C, DVB-C2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0bfe51c83f30216c9beaac7fc31f96d2af41860dee15210708765831cace36ed5"></a>DVB_T&#160;</td><td class="fielddoc"><p>DVB-T, DVB-T2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0bfe51c83f30216c9beaac7fc31f96d2a63975afe0cd79887faca5be13bd7d7d0"></a>ATSC&#160;</td><td class="fielddoc"><p>ATSC. </p>
</td></tr>
</table>

</div>
</div>
<a id="af4ee613ab8c2346d8201038e5e9a94af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ee613ab8c2346d8201038e5e9a94af">&#9670;&nbsp;</a></span>DeliverySystem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#af4ee613ab8c2346d8201038e5e9a94af">ts::DeliverySystem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delivery systems. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa2f1c5e247c3b607b53cfea2223d5c872"></a>DS_UNDEFINED&#160;</td><td class="fielddoc"><p>Undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afaa6927162dd347f1a563d7ebc8bbe1f76"></a>DS_DVB_S&#160;</td><td class="fielddoc"><p>DVB-S. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afad9df61967a4d4772edc7da3721154de7"></a>DS_DVB_S2&#160;</td><td class="fielddoc"><p>DVB-S2. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa7abae46347f832d589cef40dba86ea36"></a>DS_DVB_T&#160;</td><td class="fielddoc"><p>DVB-T. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afae5830a58622b59832b0caab25f33c03b"></a>DS_DVB_T2&#160;</td><td class="fielddoc"><p>DVB-T2. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa13bba9106a2cbc87774f879b5557396a"></a>DS_DVB_C&#160;</td><td class="fielddoc"><p>DVB-C. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afae0da8f4f58eaf13645cc958159a3984d"></a>DS_DVB_C_ANNEX_AC&#160;</td><td class="fielddoc"><p>DVB-C Annex A,C. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afad8876364c19ff425828fb9d12b8723de"></a>DS_DVB_C_ANNEX_B&#160;</td><td class="fielddoc"><p>DVB-C Annex B. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afaca24a29fd6f82e999f6638a9259100ce"></a>DS_DVB_C2&#160;</td><td class="fielddoc"><p>DVB-C2. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afac13871f9f0b767fb48f4327a38002aa3"></a>DS_DVB_H&#160;</td><td class="fielddoc"><p>DVB-H. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa6ec1493be9d22b54dcf18ee435d5acb2"></a>DS_ISDB_S&#160;</td><td class="fielddoc"><p>ISDB-S. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afaec66186d59c2aff494119dabe9224130"></a>DS_ISDB_T&#160;</td><td class="fielddoc"><p>ISDB-T. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa4513d5455ee0852588b46b229c7aa749"></a>DS_ISDB_C&#160;</td><td class="fielddoc"><p>ISDB-C. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afab6972a4a69541eec4fc3ec81a422407a"></a>DS_ATSC&#160;</td><td class="fielddoc"><p>ATSC. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa83115f1fa0d48b061f6e02b45db10494"></a>DS_ATSC_MH&#160;</td><td class="fielddoc"><p>ATSC-MH. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afaa644e7f3309f955ce83d448c81c25fb7"></a>DS_DMB_TH&#160;</td><td class="fielddoc"><p>DMB-TH. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afadaee127223e5f9243a7fa2e7bf57d03d"></a>DS_CMMB&#160;</td><td class="fielddoc"><p>CMMB. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa3b7d37c13decc2ba0604ce5ee198684f"></a>DS_DAB&#160;</td><td class="fielddoc"><p>DAB. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afa435c50851a76ccdaae45282a0d35e82e"></a>DS_DSS&#160;</td><td class="fielddoc"><p>DSS. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4ee613ab8c2346d8201038e5e9a94afabb6e9da27299136faabde20bc6f7b0c5"></a>DS_COUNT&#160;</td><td class="fielddoc"><p>Fake value, must be last to get the number of values. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae4e82c198bc4395f3dc9368516da5b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e82c198bc4395f3dc9368516da5b58">&#9670;&nbsp;</a></span>Modulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58">ts::Modulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modulation types. </p>
<p>Support depends on tuner types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a0b582d43d238d99727c306ccad2d9a36"></a>QPSK&#160;</td><td class="fielddoc"><p>QPSK (4-PSK, DVB-S). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58ab2b994d65f7db1767ab53cfb88684134"></a>PSK_8&#160;</td><td class="fielddoc"><p>8-PSK (DVB-S2). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a6807a69c21a498cdd0951c0c05241ad2"></a>QAM_AUTO&#160;</td><td class="fielddoc"><p>Unspecified QAM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58acea9210508939f28b48e4a30a22a56b6"></a>QAM_16&#160;</td><td class="fielddoc"><p>QAM-16. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a0573f6d2156f0dc045477ec99e6dd1c3"></a>QAM_32&#160;</td><td class="fielddoc"><p>QAM-32. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a46861d1e063832e921a2ddeb2da5ebfb"></a>QAM_64&#160;</td><td class="fielddoc"><p>QAM-64. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a39b5f30493274003ec7111514318a8d1"></a>QAM_128&#160;</td><td class="fielddoc"><p>QAM-128. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a881d38d8a438d3b0873b4af375c80d3a"></a>QAM_256&#160;</td><td class="fielddoc"><p>QAM-256. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a3d1005fc3e0b470215083799d8640100"></a>VSB_8&#160;</td><td class="fielddoc"><p>VSB-8. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4e82c198bc4395f3dc9368516da5b58a3df3d7ca662bd00d744619d8b5f5b65a"></a>VSB_16&#160;</td><td class="fielddoc"><p>VSB-16. </p>
</td></tr>
</table>

</div>
</div>
<a id="aef665dc6784989ee4169c6a792999de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef665dc6784989ee4169c6a792999de6">&#9670;&nbsp;</a></span>SpectralInversion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#aef665dc6784989ee4169c6a792999de6">ts::SpectralInversion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spectral inversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef665dc6784989ee4169c6a792999de6ade6f08713a3d3dd389b77bb339694788"></a>SPINV_OFF&#160;</td><td class="fielddoc"><p>Inversion off. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef665dc6784989ee4169c6a792999de6a6da7a9cc1e62915ca3a0713b0351ef4e"></a>SPINV_ON&#160;</td><td class="fielddoc"><p>Inversion on. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef665dc6784989ee4169c6a792999de6a9f96b4a4bf08cb75508f5d8b73da8de9"></a>SPINV_AUTO&#160;</td><td class="fielddoc"><p>Automatic spectral inversion. </p>
</td></tr>
</table>

</div>
</div>
<a id="aba02cdc67c6160675835a56352ee020e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba02cdc67c6160675835a56352ee020e">&#9670;&nbsp;</a></span>InnerFEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">ts::InnerFEC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inner Forward Error Correction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea69a5707f8c4ef024383295b0aaff0193"></a>FEC_NONE&#160;</td><td class="fielddoc"><p>No FEC. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea288026384bfdca7d26e7409462d4397e"></a>FEC_AUTO&#160;</td><td class="fielddoc"><p>Automatic FEC, unspecified. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020eaea4156395c7a42ffcfd54537b3b44cf5"></a>FEC_1_2&#160;</td><td class="fielddoc"><p>FEC 1/2. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea82578220fbfcfce441e3ec59092908a8"></a>FEC_2_3&#160;</td><td class="fielddoc"><p>FEC 2/3. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea20d7cf9c855305d2623d12ed061b428c"></a>FEC_3_4&#160;</td><td class="fielddoc"><p>FEC 3/4. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea9f1789555eb052c9d852a57ba097057a"></a>FEC_4_5&#160;</td><td class="fielddoc"><p>FEC 4/5. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea8b5b735d2e08ea9167842a0f7d109af0"></a>FEC_5_6&#160;</td><td class="fielddoc"><p>FEC 5/6. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020eabae8428fe00a279d4ade696795a76096"></a>FEC_6_7&#160;</td><td class="fielddoc"><p>FEC 6/7. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea63e630fe2a408061fe30cd66e6e04f1d"></a>FEC_7_8&#160;</td><td class="fielddoc"><p>FEC 7/8. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea6ad8fb01826b9bd51fd954af389951d3"></a>FEC_8_9&#160;</td><td class="fielddoc"><p>FEC 8/9. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ead733ffd2bc56c34c8d8f4883f691d74c"></a>FEC_9_10&#160;</td><td class="fielddoc"><p>FEC 9/10. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea2bd8576d53dd516a235776a01024cebb"></a>FEC_3_5&#160;</td><td class="fielddoc"><p>FEC 3/5. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020eaef4f7e3dfc2b6589bc2b7840207ff771"></a>FEC_1_3&#160;</td><td class="fielddoc"><p>FEC 1/3. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ea59db66efc65849a7a363ead9a20a984c"></a>FEC_1_4&#160;</td><td class="fielddoc"><p>FEC 1/4. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020eae042625e679024593de2cffc8d097ab7"></a>FEC_2_5&#160;</td><td class="fielddoc"><p>FEC 2/5. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba02cdc67c6160675835a56352ee020ead25d179ce439b3c6f691a4d0a22e057b"></a>FEC_5_11&#160;</td><td class="fielddoc"><p>FEC 5/11. </p>
</td></tr>
</table>

</div>
</div>
<a id="a251a9b6fe6d16b09d8a76c227cddae90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a9b6fe6d16b09d8a76c227cddae90">&#9670;&nbsp;</a></span>Polarization</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a251a9b6fe6d16b09d8a76c227cddae90">ts::Polarization</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polarization. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90abc89287f3814e55e3929fbbb8cd5503d"></a>POL_NONE&#160;</td><td class="fielddoc"><p>Polarization not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90ab5cf7410eade407781cd1811601a2d39"></a>POL_AUTO&#160;</td><td class="fielddoc"><p>Polarization automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90ab118e0eddc0d17e401f9549eafaaef78"></a>POL_HORIZONTAL&#160;</td><td class="fielddoc"><p>Horizontal linear polarization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90a8286ef50015a093450f60bc3bf0060fd"></a>POL_VERTICAL&#160;</td><td class="fielddoc"><p>Vertical linear polarization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90a900c06ce65eadce5a99c445384c39b45"></a>POL_LEFT&#160;</td><td class="fielddoc"><p>Left circular polarization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a251a9b6fe6d16b09d8a76c227cddae90a042e59aee73c5d6857506d33384b05ed"></a>POL_RIGHT&#160;</td><td class="fielddoc"><p>Right circular polarization. </p>
</td></tr>
</table>

</div>
</div>
<a id="a26ed5958edc396beb6eddd0ffbed538d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ed5958edc396beb6eddd0ffbed538d">&#9670;&nbsp;</a></span>Pilot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a26ed5958edc396beb6eddd0ffbed538d">ts::Pilot</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pilot (DVB-S2) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26ed5958edc396beb6eddd0ffbed538dab958f6c5d72b83b80d2f6ef4a86bffe4"></a>PILOT_AUTO&#160;</td><td class="fielddoc"><p>Pilot automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26ed5958edc396beb6eddd0ffbed538da3ccc710513dc7a9296920c55edf8d7be"></a>PILOT_ON&#160;</td><td class="fielddoc"><p>Pilot on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26ed5958edc396beb6eddd0ffbed538da5ef28bdb9847aedd043b034dea5ff902"></a>PILOT_OFF&#160;</td><td class="fielddoc"><p>Pilot off. </p>
</td></tr>
</table>

</div>
</div>
<a id="aba55fc1506e1299dbed38c039463201f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba55fc1506e1299dbed38c039463201f">&#9670;&nbsp;</a></span>RollOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#aba55fc1506e1299dbed38c039463201f">ts::RollOff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Roll-off (DVB-S2) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba55fc1506e1299dbed38c039463201fa1a8b65ac60553a148ebf03654f31de94"></a>ROLLOFF_AUTO&#160;</td><td class="fielddoc"><p>Automatic rolloff. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba55fc1506e1299dbed38c039463201fab28dd56e0e693f14368c3df73b16c405"></a>ROLLOFF_35&#160;</td><td class="fielddoc"><p>Rolloff 35, implied in DVB-S, default in DVB-S2. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba55fc1506e1299dbed38c039463201fa316d12a94730acabd6d857e0078439d3"></a>ROLLOFF_25&#160;</td><td class="fielddoc"><p>Rolloff 25. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba55fc1506e1299dbed38c039463201fac5b00d68832637ef94352475de399f4c"></a>ROLLOFF_20&#160;</td><td class="fielddoc"><p>Rolloff 20. </p>
</td></tr>
</table>

</div>
</div>
<a id="a14bb51c4b1573092910ab6fdec459e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bb51c4b1573092910ab6fdec459e31">&#9670;&nbsp;</a></span>BandWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">ts::BandWidth</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bandwidth (OFDM) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a14bb51c4b1573092910ab6fdec459e31afb16b9f94267bd78db001355f4b365b1"></a>BW_AUTO&#160;</td><td class="fielddoc"><p>Bandwidth automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14bb51c4b1573092910ab6fdec459e31a9acc07f7aeaf8984f32f381076d1e9c8"></a>BW_8_MHZ&#160;</td><td class="fielddoc"><p>8 MHz bandwidth. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14bb51c4b1573092910ab6fdec459e31a25fe22090defe689c68444ba9d63ec5f"></a>BW_7_MHZ&#160;</td><td class="fielddoc"><p>7 MHz bandwidth. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14bb51c4b1573092910ab6fdec459e31a35a58784bef0d136add5b6ab207f89bb"></a>BW_6_MHZ&#160;</td><td class="fielddoc"><p>6 MHz bandwidth. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14bb51c4b1573092910ab6fdec459e31a48d8795184580cd5ceeee470bf3e8aa0"></a>BW_5_MHZ&#160;</td><td class="fielddoc"><p>5 MHz bandwidth. </p>
</td></tr>
</table>

</div>
</div>
<a id="aee2f4a753d453dd84bab8636dc4b7ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2f4a753d453dd84bab8636dc4b7ba5">&#9670;&nbsp;</a></span>TransmissionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#aee2f4a753d453dd84bab8636dc4b7ba5">ts::TransmissionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmission mode (OFDM) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee2f4a753d453dd84bab8636dc4b7ba5a73a3ae69386c7b74a5557ce789ac3758"></a>TM_AUTO&#160;</td><td class="fielddoc"><p>Transmission mode automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee2f4a753d453dd84bab8636dc4b7ba5aa2722fe11be3cd528403c0cf4f4465ff"></a>TM_2K&#160;</td><td class="fielddoc"><p>2K transmission mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee2f4a753d453dd84bab8636dc4b7ba5a406a117e3e6a9407da9b33b123eeb3e1"></a>TM_4K&#160;</td><td class="fielddoc"><p>4K transmission mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee2f4a753d453dd84bab8636dc4b7ba5a5098fb3b070042eefb1d8ac011647dd0"></a>TM_8K&#160;</td><td class="fielddoc"><p>8K transmission mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a244247a91af4595a95740ef778f85184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244247a91af4595a95740ef778f85184">&#9670;&nbsp;</a></span>GuardInterval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">ts::GuardInterval</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval (OFDM) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a244247a91af4595a95740ef778f85184a2fb0b47db806537c58dab7cedff71112"></a>GUARD_AUTO&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a244247a91af4595a95740ef778f85184a66aa4c8d70c8147728e1ec12de949fb4"></a>GUARD_1_32&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval 1/32. </p>
</td></tr>
<tr><td class="fieldname"><a id="a244247a91af4595a95740ef778f85184ae586b7cf9368a0692c7b7cc4d325dc87"></a>GUARD_1_16&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval 1/16. </p>
</td></tr>
<tr><td class="fieldname"><a id="a244247a91af4595a95740ef778f85184aadab74e89c402061d46911b2d4767b1f"></a>GUARD_1_8&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval 1/8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a244247a91af4595a95740ef778f85184a199309263f4d2d0b4683d1374c710f9c"></a>GUARD_1_4&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval 1/4. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6c9df6e98dda571737595eff7b169350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9df6e98dda571737595eff7b169350">&#9670;&nbsp;</a></span>Hierarchy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a6c9df6e98dda571737595eff7b169350">ts::Hierarchy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hierarchy (OFDM) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c9df6e98dda571737595eff7b169350a0343626c64db75bcfdedf2f7867b35cd"></a>HIERARCHY_AUTO&#160;</td><td class="fielddoc"><p>Hierarchy automatically set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9df6e98dda571737595eff7b169350a06de6d2482ab8c1cd60654c953d08d0b"></a>HIERARCHY_NONE&#160;</td><td class="fielddoc"><p>No hierarchy. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9df6e98dda571737595eff7b169350a8212482c29a1175de4eebd430074cbeb"></a>HIERARCHY_1&#160;</td><td class="fielddoc"><p>Hierarchy 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9df6e98dda571737595eff7b169350a8e57fd00a538280f2d001e8323e932b1"></a>HIERARCHY_2&#160;</td><td class="fielddoc"><p>Hierarchy 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9df6e98dda571737595eff7b169350ac2c674e2a1ea789754b4c247f5995a50"></a>HIERARCHY_4&#160;</td><td class="fielddoc"><p>Hierarchy 4. </p>
</td></tr>
</table>

</div>
</div>
<a id="acb0d05eb5829cfca3e8cbddb3ea5297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0d05eb5829cfca3e8cbddb3ea5297a">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scrambling_control values (used in TS and PES packets headers) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb0d05eb5829cfca3e8cbddb3ea5297aadd865c554e922bc87e46ef506cab65db"></a>SC_CLEAR&#160;</td><td class="fielddoc"><p>Not scrambled (MPEG-defined). </p>
</td></tr>
<tr><td class="fieldname"><a id="acb0d05eb5829cfca3e8cbddb3ea5297aa85da402c9f4f8064bfb39bea12341a87"></a>SC_DVB_RESERVED&#160;</td><td class="fielddoc"><p>Reserved for future use by DVB. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb0d05eb5829cfca3e8cbddb3ea5297aab6c2f8efcd745f940043e66cbfe5b97d"></a>SC_EVEN_KEY&#160;</td><td class="fielddoc"><p>Scrambled with even key (DVB-defined). </p>
</td></tr>
<tr><td class="fieldname"><a id="acb0d05eb5829cfca3e8cbddb3ea5297aaa1b72fa51d8d2cc9b2ea056b807b8635"></a>SC_ODD_KEY&#160;</td><td class="fielddoc"><p>Scrambled with odd key (DVB-defined). </p>
</td></tr>
</table>

</div>
</div>
<a id="aa49ea8a46f549e6396e453119f0e6aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49ea8a46f549e6396e453119f0e6aa2">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="namespacets.html#a90e2f5f7d7011d87cc23a8fef31958dc">PID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined PID values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a247897773bfc216f2c046b38195994aa"></a>PID_PAT&#160;</td><td class="fielddoc"><p>PID for Program Association Table <a class="el" href="classts_1_1_p_a_t.html" title="Representation of a Program Association Table (PAT) ">PAT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2aea1c15792b70c8ac8e0f28d17ad612bb"></a>PID_CAT&#160;</td><td class="fielddoc"><p>PID for Conditional Access Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a95ca43dd7ee5ef20d961951fbab7d5dc"></a>PID_TSDT&#160;</td><td class="fielddoc"><p>PID for Transport Stream Description Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2ada7de7f0f513344653d9796e75a35526"></a>PID_NULL&#160;</td><td class="fielddoc"><p>PID for Null packets (stuffing) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2ad5345e400b662b12eb7e01a7a94faec9"></a>PID_NIT&#160;</td><td class="fielddoc"><p>PID for Network Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2adb0d56a42ecb9459abb3d879dd86687e"></a>PID_SDT&#160;</td><td class="fielddoc"><p>PID for <a class="el" href="classts_1_1_service.html" title="Describe a DVB service. ">Service</a> Description Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a570a262cd09340e12bc8cda912aab4b6"></a>PID_BAT&#160;</td><td class="fielddoc"><p>PID for Bouquet Association Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a3d2139a9d1fba9b0eba928caa6a1dbe7"></a>PID_EIT&#160;</td><td class="fielddoc"><p>PID for Event Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a1c18976f7e482541e859767a00085c87"></a>PID_RST&#160;</td><td class="fielddoc"><p>PID for Running Status Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2ab534380ccdfb86dc5d46d460b3e871aa"></a>PID_TDT&#160;</td><td class="fielddoc"><p>PID for <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> &amp; Date Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2ad8e9dc4f984ab0cb88af7b7ff4372206"></a>PID_TOT&#160;</td><td class="fielddoc"><p>PID for <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> Offset Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2aa7109e1d319b0fea956f476ab640839a"></a>PID_NETSYNC&#160;</td><td class="fielddoc"><p>PID for Network synchronization. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2a8ac76760111c83dc938daeccadccd08e"></a>PID_RNT&#160;</td><td class="fielddoc"><p>PID for TV-Anytime. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2af9dbd0da20bc2607a66da503a6156605"></a>PID_INBSIGN&#160;</td><td class="fielddoc"><p>PID for Inband Signalling. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2aa7cff244b2a603e58dcd764817e791de"></a>PID_MEASURE&#160;</td><td class="fielddoc"><p>PID for Measurement. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2ad09a2808fe0f840cfb7b3cef9613af65"></a>PID_DIT&#160;</td><td class="fielddoc"><p>PID for Discontinuity Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa49ea8a46f549e6396e453119f0e6aa2affc18c13f5e9c7a6b213edc46f57f6e8"></a>PID_SIT&#160;</td><td class="fielddoc"><p>PID for Selection Information Table. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6a2873593dbf2b644a7963a5591fd2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2873593dbf2b644a7963a5591fd2f0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream id values, as used in PES header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0aa0f6a36cc8fbfa2344b3d46e82f7125d"></a>SID_PSMAP&#160;</td><td class="fielddoc"><p>Stream id for Program stream map. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0afd9302672d7e21f88364a8d4091c6269"></a>SID_PRIV1&#160;</td><td class="fielddoc"><p>Stream id for Private stream 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0ab453367700ee8313085b61c2b8a73cc4"></a>SID_PAD&#160;</td><td class="fielddoc"><p>Stream id for Padding stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a9b14161fc30f1cb696c605a22c09d009"></a>SID_PRIV2&#160;</td><td class="fielddoc"><p>Stream id for Private stream 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0aa5ecc6e58134957280e191f33290a84f"></a>SID_AUDIO&#160;</td><td class="fielddoc"><p>Stream id for Audio stream, with number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0af2cc13d3667d6451d3469ab4adf6f0d7"></a>SID_AUDIO_MASK&#160;</td><td class="fielddoc"><p>Stream id for Mask to get audio stream number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a5f96a0ced61943cdc0cc820b51d0c112"></a>SID_VIDEO&#160;</td><td class="fielddoc"><p>Stream id for Video stream, with number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0ab274521e20ec99ccd72a00b710627e0f"></a>SID_VIDEO_MASK&#160;</td><td class="fielddoc"><p>Stream id for Mask to get video stream number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a150cc72663e7aae27f76d6bcbd9b3168"></a>SID_ECM&#160;</td><td class="fielddoc"><p>Stream id for ECM stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a40a18b673f9cb633dfcebbe4c961e0b4"></a>SID_EMM&#160;</td><td class="fielddoc"><p>Stream id for EMM stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0ad77a40f3577f34a9d1fbd0117ab6f0f5"></a>SID_DSMCC&#160;</td><td class="fielddoc"><p>Stream id for DSM-CC data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0aa01ef4c1fc0a755e5d42a12799e3cbfe"></a>SID_ISO13522&#160;</td><td class="fielddoc"><p>Stream id for ISO 13522 (hypermedia) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a5164c28edd8c2102faa4dbae73ff14d1"></a>SID_H222_1_A&#160;</td><td class="fielddoc"><p>Stream id for H.222.1 type A. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a579fa3383c3966ebe8c62a83f4072887"></a>SID_H222_1_B&#160;</td><td class="fielddoc"><p>Stream id for H.222.1 type B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a1fb0d2a298ec82ce5891daa62d0ac52f"></a>SID_H222_1_C&#160;</td><td class="fielddoc"><p>Stream id for H.222.1 type C. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a68df471681803ef2b345592dec12227c"></a>SID_H222_1_D&#160;</td><td class="fielddoc"><p>Stream id for H.222.1 type D. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0ab654873407406b9a14f72aba165fb68b"></a>SID_H222_1_E&#160;</td><td class="fielddoc"><p>Stream id for H.222.1 type E. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a7921b933226968f3a96a736d7617fde3"></a>SID_ANCILLARY&#160;</td><td class="fielddoc"><p>Stream id for Ancillary stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a6b6abcdd9c10f3f4019df7ab02d2dab6"></a>SID_MP4_SLPACK&#160;</td><td class="fielddoc"><p>Stream id for MPEG-4 SL-packetized stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a8104c7a3df9982c4b7d5b67b0b88d2dd"></a>SID_MP4_FLEXM&#160;</td><td class="fielddoc"><p>Stream id for MPEG-4 FlexMux stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a745bb782923faec357f6811b1c743135"></a>SID_METADATA&#160;</td><td class="fielddoc"><p>Stream id for MPEG-7 metadata stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0add4c5e710d0145683c0f831041b08854"></a>SID_EXTENDED&#160;</td><td class="fielddoc"><p>Stream id for Extended stream id. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a4c443b38b1a84e543e20d57264aa6379"></a>SID_RESERVED&#160;</td><td class="fielddoc"><p>Stream id for Reserved value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a2873593dbf2b644a7963a5591fd2f0a45e7a579bfaacc37834b5f3407be2063"></a>SID_PSDIR&#160;</td><td class="fielddoc"><p>Stream id for Program stream directory. </p>
</td></tr>
</table>

</div>
</div>
<a id="a51658c20180539b0acb147d22f9569e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51658c20180539b0acb147d22f9569e0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PES start code values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0aa962c72069b64268132739e60eab63c9"></a>PST_PICTURE&#160;</td><td class="fielddoc"><p>Piscture PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a3b5e2914708829d3bd434c81023e7ddc"></a>PST_SLICE_MIN&#160;</td><td class="fielddoc"><p>First slice PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a171cad75f3c8738857b2da610a53268e"></a>PST_SLICE_MAX&#160;</td><td class="fielddoc"><p>Last slice PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a1280ff628a7287b540621bad1691d8b6"></a>PST_RESERVED_B0&#160;</td><td class="fielddoc"><p>Reserved PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a191bff851eb433c1a2d3e21efe4019c4"></a>PST_RESERVED_B1&#160;</td><td class="fielddoc"><p>Reserved PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a4cbb234c0af12cb05b8bd3785158ffcc"></a>PST_USER_DATA&#160;</td><td class="fielddoc"><p>User data PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0aa5f8b8dbccb4ff0aaf9a97f57e629ee7"></a>PST_SEQUENCE_HEADER&#160;</td><td class="fielddoc"><p>Sequence header PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a19dd228424fd6c05dde1b182cf6f9df1"></a>PST_SEQUENCE_ERROR&#160;</td><td class="fielddoc"><p>Sequence error PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a56e2e7bacda3411efa9b76ca3f0119ab"></a>PST_EXTENSION&#160;</td><td class="fielddoc"><p>Extension PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a921847fca66925f1521d797096eed247"></a>PST_RESERVED_B6&#160;</td><td class="fielddoc"><p>Reserved PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0aba3c3c53ff8e2a07e7d107f4c3347a3f"></a>PST_SEQUENCE_END&#160;</td><td class="fielddoc"><p>End of sequence PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a56d7048b53be3152ec31bfdaa2dde953"></a>PST_GROUP&#160;</td><td class="fielddoc"><p>Group PES start code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a897a95721f8039db7f2ffd85387d7eb5"></a>PST_SYSTEM_MIN&#160;</td><td class="fielddoc"><p>First stream id value (SID_*). </p>
</td></tr>
<tr><td class="fieldname"><a id="a51658c20180539b0acb147d22f9569e0a2b7cebf5cec0991e74c8f60e0c84da31"></a>PST_SYSTEM_MAX&#160;</td><td class="fielddoc"><p>Last stream id value (SID_*). </p>
</td></tr>
</table>

</div>
</div>
<a id="a08350e57208be14f8c0fd69df58b0bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08350e57208be14f8c0fd69df58b0bc4">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aspect ratio values (in MPEG-1/2 video sequence header). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a08350e57208be14f8c0fd69df58b0bc4a71e0c68286f58b045096a9d71bfad098"></a>AR_SQUARE&#160;</td><td class="fielddoc"><p>1/1 MPEG video aspect ratio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08350e57208be14f8c0fd69df58b0bc4a068d038ff6c970bd591096cb3fda415b"></a>AR_4_3&#160;</td><td class="fielddoc"><p>4/3 MPEG video aspect ratio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08350e57208be14f8c0fd69df58b0bc4a9cc48b42ff3e6af9537291dc75b509b1"></a>AR_16_9&#160;</td><td class="fielddoc"><p>16/9 MPEG video aspect ratio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08350e57208be14f8c0fd69df58b0bc4ad6f3b0a4ff44a968d12d334bf6d4d536"></a>AR_221&#160;</td><td class="fielddoc"><p>2.21/1 MPEG video aspect ratio. </p>
</td></tr>
</table>

</div>
</div>
<a id="a59385f479bb35e79a614d5536eb24f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59385f479bb35e79a614d5536eb24f63">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chroma format values (in MPEG-1/2 video sequence header). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59385f479bb35e79a614d5536eb24f63af07e44906f4ddd30d5426619509c9055"></a>CHROMA_MONO&#160;</td><td class="fielddoc"><p>Monochrome MPEG video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a59385f479bb35e79a614d5536eb24f63a4d4a7f5e3c5dd71d078b044f6fac15fc"></a>CHROMA_420&#160;</td><td class="fielddoc"><p>Chroma 4:2:0 MPEG video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a59385f479bb35e79a614d5536eb24f63ad8d76b5e322b2cf47ef3737bf1acbbcb"></a>CHROMA_422&#160;</td><td class="fielddoc"><p>Chroma 4:2:2 MPEG video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a59385f479bb35e79a614d5536eb24f63a6050b95b5f50b87f3719cb5ea914e820"></a>CHROMA_444&#160;</td><td class="fielddoc"><p>Chroma 4:4:4 MPEG video. </p>
</td></tr>
</table>

</div>
</div>
<a id="a422d5160a4aca8802098c55c1f8cdb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422d5160a4aca8802098c55c1f8cdb09">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVC access unit types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09aea4ef7568d2165e29b795ca912ef8895"></a>AVC_AUT_NON_IDR&#160;</td><td class="fielddoc"><p>Coded slice of a non-IDR picture (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09ab3262e1b6c3eb500fe52ba8b30d27542"></a>AVC_AUT_SLICE_A&#160;</td><td class="fielddoc"><p>Coded slice data partition A (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09ae3574939996488e4398da781ef8d9fab"></a>AVC_AUT_SLICE_B&#160;</td><td class="fielddoc"><p>Coded slice data partition B (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09ad72b33048deac1217cfcf4fe7f7b6ad5"></a>AVC_AUT_SLICE_C&#160;</td><td class="fielddoc"><p>Coded slice data partition C (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a33dace0be8904d109a5b29d6ce45dbf9"></a>AVC_AUT_IDR&#160;</td><td class="fielddoc"><p>Coded slice of an IDR picture (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09adeae4a192867c8cdd931f0d88890501f"></a>AVC_AUT_SEI&#160;</td><td class="fielddoc"><p>Supplemental enhancement information (SEI) (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a8ee8b0cb11cc0263177791783fb51222"></a>AVC_AUT_SEQPARAMS&#160;</td><td class="fielddoc"><p>Sequence parameter set (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a22a42c47b94933a9cd3aaaf05f3d8f93"></a>AVC_AUT_PICPARAMS&#160;</td><td class="fielddoc"><p>Picture parameter set (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a85078e1dcebe3ed63ecac0c15785a165"></a>AVC_AUT_DELIMITER&#160;</td><td class="fielddoc"><p>Access unit delimiter (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a5adcd52aea52fd28bdd5f566844130bf"></a>AVC_AUT_END_SEQUENCE&#160;</td><td class="fielddoc"><p>End of sequence (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09aa58989fc6de63c8c58fde91a294498d1"></a>AVC_AUT_END_STREAM&#160;</td><td class="fielddoc"><p>End of stream (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a314551a19951033f2a8ba8415029a59f"></a>AVC_AUT_FILLER&#160;</td><td class="fielddoc"><p>Filler data (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a027db1c293036f157e88e438eea4fa9d"></a>AVC_AUT_SEQPARAMSEXT&#160;</td><td class="fielddoc"><p>Sequence parameter set extension (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a8dbaf70e81b36fc2c896e030f43d8881"></a>AVC_AUT_PREFIX&#160;</td><td class="fielddoc"><p>Prefix NAL unit in scalable extension (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09ac9127980fd6a04367e5515391df4fbd8"></a>AVC_AUT_SUBSETPARAMS&#160;</td><td class="fielddoc"><p>Subset sequence parameter set (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a6dc63bf1cca4f89c74b2d560329b6033"></a>AVC_AUT_SLICE_NOPART&#160;</td><td class="fielddoc"><p>Coded slice without partitioning (NALunit type). </p>
</td></tr>
<tr><td class="fieldname"><a id="a422d5160a4aca8802098c55c1f8cdb09a6f08eaa4eb0ae489a778a012b9517afe"></a>AVC_AUT_SLICE_SCALE&#160;</td><td class="fielddoc"><p>Coded slice in scalable extension (NALunit type). </p>
</td></tr>
</table>

</div>
</div>
<a id="a3707cedfb26068131a6836830eed63cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3707cedfb26068131a6836830eed63cf">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream type values, as used in the <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa4e74688359b33734095fe060587316ff"></a>ST_MPEG1_VIDEO&#160;</td><td class="fielddoc"><p>MPEG-1 Video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa5ea82697b1781cae8923fd879bcf1355"></a>ST_MPEG2_VIDEO&#160;</td><td class="fielddoc"><p>MPEG-2 Video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa141c9f19d26f6c8cafbf9d26666c6b43"></a>ST_MPEG1_AUDIO&#160;</td><td class="fielddoc"><p>MPEG-1 Audio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa59f6537e6a8443cca962fcfd05ebe762"></a>ST_MPEG2_AUDIO&#160;</td><td class="fielddoc"><p>MPEG-2 Audio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa85964257bebdb3664800a2ede56cc4ec"></a>ST_PRIV_SECT&#160;</td><td class="fielddoc"><p>MPEG-2 Private sections. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa49048b6dac3bba964d813c119f3a0e1f"></a>ST_PES_PRIV&#160;</td><td class="fielddoc"><p>MPEG-2 PES private data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfac447f599bc69b47e2948ae391908a7d7"></a>ST_MHEG&#160;</td><td class="fielddoc"><p>MHEG. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa8cb3d0d058ec0e2f8659420490687178"></a>ST_DSMCC&#160;</td><td class="fielddoc"><p>DSM-CC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa263a70d0f816d534387a5396dbddc115"></a>ST_MPEG2_ATM&#160;</td><td class="fielddoc"><p>MPEG-2 over ATM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa31d3b997f9c2a93bfeb60d02303767ae"></a>ST_DSMCC_MPE&#160;</td><td class="fielddoc"><p>DSM-CC Multi-Protocol Encapsulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa481e217bbe53374c523577e8bc791b46"></a>ST_DSMCC_UN&#160;</td><td class="fielddoc"><p>DSM-CC User-to-Network messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa0a73b86aa236c3fb798a441c40afecc6"></a>ST_DSMCC_SD&#160;</td><td class="fielddoc"><p>DSM-CC Stream Descriptors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfaa40f49f97d908544e6151715d35c8e80"></a>ST_DSMCC_SECT&#160;</td><td class="fielddoc"><p>DSM-CC Sections. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa217d57db856a9a7f6339cc1b4cda4679"></a>ST_MPEG2_AUX&#160;</td><td class="fielddoc"><p>MPEG-2 Auxiliary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa75b8b977e1328dc3dd32389758568655"></a>ST_AAC_AUDIO&#160;</td><td class="fielddoc"><p>Advanced Audio Coding (ISO 13818-7) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa2a0650fafce691dde91ed5f70cf15954"></a>ST_MPEG4_VIDEO&#160;</td><td class="fielddoc"><p>MPEG-4 Video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa62c0d21b7ac66b96d5dd0640b1368c15"></a>ST_MPEG4_AUDIO&#160;</td><td class="fielddoc"><p>MPEG-4 Audio. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa191df8b2216a903570ca02d0deb0b4aa"></a>ST_MPEG4_PES&#160;</td><td class="fielddoc"><p>MPEG-4 SL or FlexMux in PES packets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa8c12c6d6550207d3e9f9aaa65b0b884f"></a>ST_MPEG4_SECT&#160;</td><td class="fielddoc"><p>MPEG-4 SL or FlexMux in sections. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa195af2918b26d3e571c2ec348e628d40"></a>ST_DSMCC_DLOAD&#160;</td><td class="fielddoc"><p>DSM-CC Synchronized Download Protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa790a050daa31d07e4a19691c32932bf8"></a>ST_MDATA_PES&#160;</td><td class="fielddoc"><p>MPEG-7 MetaData in PES packets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfac7e7c0be665bfa22a5b096ae7bf72da5"></a>ST_MDATA_SECT&#160;</td><td class="fielddoc"><p>MPEG-7 MetaData in sections. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfac67f05a00ed6984b8c5fe2d46692cbe1"></a>ST_MDATA_DC&#160;</td><td class="fielddoc"><p>MPEG-7 MetaData in DSM-CC Data Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfab1ef8808c0ac4e7ba7eb6ca9b3f6118d"></a>ST_MDATA_OC&#160;</td><td class="fielddoc"><p>MPEG-7 MetaData in DSM-CC <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa17b676250b644a50324b263b686dbbc8"></a>ST_MDATA_DLOAD&#160;</td><td class="fielddoc"><p>MPEG-7 MetaData in DSM-CC Sync Downl Proto. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa88799dd392515afd568d8aa685275941"></a>ST_MPEG2_IPMP&#160;</td><td class="fielddoc"><p>MPEG-2 IPMP stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfae6c2b09e69687b5f7c42807bdcf8412a"></a>ST_AVC_VIDEO&#160;</td><td class="fielddoc"><p>AVC video. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa99b5bbbb706c491a92890b8b08fa1885"></a>ST_IPMP&#160;</td><td class="fielddoc"><p>IPMP stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfaab39beb9e977a34486a82f64bd0b1620"></a>ST_AC3_AUDIO&#160;</td><td class="fielddoc"><p>AC-3 Audio (ATSC only) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3707cedfb26068131a6836830eed63cfa7e763ff014e1ba6e638c423002a71a56"></a>ST_EAC3_AUDIO&#160;</td><td class="fielddoc"><p>Enhanced-AC-3 Audio (ATSC only) </p>
</td></tr>
</table>

</div>
</div>
<a id="ae56343654e2b01380409afc12dd2b037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56343654e2b01380409afc12dd2b037">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="namespacets.html#a3c2cbf0a41a7db2577a737cc9568e3cb">TID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Table identification (TID) values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a96daeb6d4904472be75955446d097f57"></a>TID_PAT&#160;</td><td class="fielddoc"><p>Table id for Program Association Table <a class="el" href="classts_1_1_p_a_t.html" title="Representation of a Program Association Table (PAT) ">PAT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a13cf559a7a67bf284282b36baa648888"></a>TID_CAT&#160;</td><td class="fielddoc"><p>Table id for Conditional Access Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a2b77f31e0fd86def5354eecae304e8b1"></a>TID_PMT&#160;</td><td class="fielddoc"><p>Table id for Program Map Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a617c1d6b0e390b0424d73b867cb14dfb"></a>TID_TSDT&#160;</td><td class="fielddoc"><p>Table id for Transport Stream Description Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037af363a0c30af78a040124226c6618b244"></a>TID_MP4SDT&#160;</td><td class="fielddoc"><p>Table id for MPEG-4 Scene Description Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a232f16adc12ccbb3837421e78564133f"></a>TID_MP4ODT&#160;</td><td class="fielddoc"><p>Table id for MPEG-4 <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> <a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">Descriptor</a> Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a423fddcadbe82585d430a50c0f9da73e"></a>TID_MDT&#160;</td><td class="fielddoc"><p>Table id for MetaData Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a6de8575d697d56a785ed22b09210f5ee"></a>TID_DSMCC_MPE&#160;</td><td class="fielddoc"><p>Table id for DSM-CC Multi-Protocol Encapsulated data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a8b549c5cdb8039f18d5907a9af1b5488"></a>TID_DSMCC_UNM&#160;</td><td class="fielddoc"><p>Table id for DSM-CC User-to-Network Messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a30811e76a364da82f7ad318813bfcb4f"></a>TID_DSMCC_DDM&#160;</td><td class="fielddoc"><p>Table id for DSM-CC Download Data Messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a51c367b7bdf8f263b868a3581c932ba5"></a>TID_DSMCC_SD&#160;</td><td class="fielddoc"><p>Table id for DSM-CC Stream Descriptors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a425ccf991a5f5d1d4889f5cc2c23bb84"></a>TID_DSMCC_PD&#160;</td><td class="fielddoc"><p>Table id for DSM-CC Private Data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ad51c95d1eb15054cb4f69437a5207ecf"></a>TID_NULL&#160;</td><td class="fielddoc"><p>Reserved table id value, end of TS packet PSI payload. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ae15af73528a1290c2e635dc92ea11321"></a>TID_NIT_ACT&#160;</td><td class="fielddoc"><p>Table id for Network Information Table - Actual network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a61be3fb538e1f44da59c03d776ca7543"></a>TID_NIT_OTH&#160;</td><td class="fielddoc"><p>Table id for Network Information Table - Other network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a6a382cc0ea3606e9182985f2a0a473ec"></a>TID_SDT_ACT&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_service.html" title="Describe a DVB service. ">Service</a> Description Table - Actual TS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a46279362a38fea02569cfd5d585e4873"></a>TID_SDT_OTH&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_service.html" title="Describe a DVB service. ">Service</a> Description Table - Other TS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a538224f74a11c7311e8f680ddeb51b8b"></a>TID_BAT&#160;</td><td class="fielddoc"><p>Table id for Bouquet Association Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037aedc0a2ab15b5da31db86c8923a6f0330"></a>TID_EIT_PF_ACT&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> present/following - Actual network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a57d4f3c767d80a3f9f8343bab420a8ac"></a>TID_EIT_PF_OTH&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> present/following - Other network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a27ce235e5cf0a836ffcb4126753e50c6"></a>TID_EIT_S_ACT_MIN&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> schedule - Actual network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a381337a1bbf01e51ef0e2431e3ef70c2"></a>TID_EIT_S_ACT_MAX&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> schedule - Actual network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ad36fe44c7d8976658664551f7dfa5e2e"></a>TID_EIT_S_OTH_MIN&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> schedule - Other network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a69554964cee7a4d4b93aadde5e9d455f"></a>TID_EIT_S_OTH_MAX&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a> schedule - Other network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a617c3c6ac3e77d5121946eccd271d99f"></a>TID_TDT&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> &amp; Date Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a89e79cab11caf0e845495b30e022b983"></a>TID_RST&#160;</td><td class="fielddoc"><p>Table id for Running Status Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037af4a9feb0ac3b9335cc0c021853e48680"></a>TID_ST&#160;</td><td class="fielddoc"><p>Table id for Stuffing Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ae0198dc094ad69c878d148b71987e91f"></a>TID_TOT&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> Offset Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a2ea0d009e91c6184e63015ae1f94b061"></a>TID_RNT&#160;</td><td class="fielddoc"><p>Table id for Resolution Notification (TV-Anytime) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a99a760333f8cf8d185d25c3e5efc8806"></a>TID_CT&#160;</td><td class="fielddoc"><p>Table id for Container Table (TV-Anytime) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a6d67a7350927e8a6d29ceb4d5b8f85f0"></a>TID_RCT&#160;</td><td class="fielddoc"><p>Table id for Related Content Table (TV-Anytime) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a12e2a44d0812596db1eca6f58b6a9da7"></a>TID_CIT&#160;</td><td class="fielddoc"><p>Table id for Content Identifier Table (TV-Anytime) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ab7e93acd478597b74674f5f03a96a264"></a>TID_MPE_FEC&#160;</td><td class="fielddoc"><p>Table id for MPE-FEC Table (Data Broadcasting) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037afd2b8c258ccb9b80357554ae44da2e0d"></a>TID_DIT&#160;</td><td class="fielddoc"><p>Table id for Discontinuity Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037abeb80c4db361666798ad4671ca063827"></a>TID_SIT&#160;</td><td class="fielddoc"><p>Table id for Selection Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a81b2bf38d5f812962790904e880edbbb"></a>TID_ECM_80&#160;</td><td class="fielddoc"><p>Table id for ECM 80. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a660d47458af8a9270911eaaf4dda73a4"></a>TID_ECM_81&#160;</td><td class="fielddoc"><p>Table id for ECM 81. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a757f75e7ce72d3dda6ff995aaaf96983"></a>TID_EMM_FIRST&#160;</td><td class="fielddoc"><p>Start of Table id range for EMM's. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037aaa2c1268627471242ad87af69cc5f5ac"></a>TID_EMM_LAST&#160;</td><td class="fielddoc"><p>End of Table id range for EMM's. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a34248b172138c98d222e4e91b9dcdcdd"></a>TID_EIT_MIN&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a>, first TID. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037af163086650d5e6df407e29b04c20e310"></a>TID_EIT_MAX&#160;</td><td class="fielddoc"><p>Table id for <a class="el" href="classts_1_1_e_i_t.html" title="Representation of an Event Information Table (EIT) ">EIT</a>, last TID. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ad7334af40fe461845b49c7cefecf72a5"></a>TID_CAS_FIRST&#160;</td><td class="fielddoc"><p>Start of Table id range for CAS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a3cf423368589ea4bd3385a0b08dce31f"></a>TID_CAS_LAST&#160;</td><td class="fielddoc"><p>End of Table id range for CAS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a08261a38571b8197c70e4cc919bdf615"></a>TID_SA_CECM_82&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Complementary ECM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a64d930c0b8a8ca179d92b8821ea3763e"></a>TID_SA_CECM_83&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Complementary ECM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037aa9467e645ccfc85d6ab4467eed8ea1cd"></a>TID_SA_EMM_STB_U&#160;</td><td class="fielddoc"><p>Table id for SafeAccess STB or CI-CAM unique EMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a44ed883496756248f997aedb0c077365"></a>TID_SA_EMM_STB_G&#160;</td><td class="fielddoc"><p>Table id for SafeAccess STB global EMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037adbd56fbf54d9778c732c804b3f932bd1"></a>TID_SA_EMM_A&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Global EMM ("all") </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a968214a88cb501e18da563ea2b17b3ee"></a>TID_SA_EMM_U&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Unique EMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a1e658e728fc1dcb7fb141eaec86bd241"></a>TID_SA_EMM_S&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Group EMM ("shared") </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a2f77365ddc3d2a702cb76d38c1f4ed66"></a>TID_SA_EMM_CAM_G&#160;</td><td class="fielddoc"><p>Table id for SafeAccess CI-CAM global EMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a63f25024bdf3c2820a7510e11e586259"></a>TID_SA_RECM_8A&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Record ECM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037acafbfe8a4f206706abc244408d494dbc"></a>TID_SA_RECM_8B&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Record ECM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a8880841dac861d2dc6a53218892a8aa5"></a>TID_SA_EMM_T&#160;</td><td class="fielddoc"><p>Table id for SafeAccess Technical EMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a29ef90c143b1790cc89f3aeac9032e28"></a>TID_LW_DMT&#160;</td><td class="fielddoc"><p>Table id for Logiways Download Marker Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a00c56af4e53ec8ef9a5ba09348c48b86"></a>TID_LW_BDT&#160;</td><td class="fielddoc"><p>Table id for Logiways Binary Data Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a240fcbd4f14cf4d6cdedcb2235fff240"></a>TID_LW_VIT&#160;</td><td class="fielddoc"><p>Table id for Logiways VoD Information Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a28bc4d5dbe3222ea2eaa37177a735bfd"></a>TID_LW_VCT&#160;</td><td class="fielddoc"><p>Table id for Logiways VoD Command Table. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a018312c97c14c5d163bf66708e888548"></a>TID_VIA_EMM_U&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-U and EMM-D-U. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ad919c1ad1a6155232b520613ab346f28"></a>TID_VIA_EMM_GA_E&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-GA and EMM-D-GA (even) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ae23861252812d3d1780f5f17024f5c77"></a>TID_VIA_EMM_GA_O&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-GA and EMM-D-GA (odd) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037adb28248a89a10cf1673156b391b46a27"></a>TID_VIA_EMM_GH_E&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-GH (even) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037afa006554c228affa735a95012afec86c"></a>TID_VIA_EMM_GH_O&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-GH (odd) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a6b7fa003abdc5bcda776f4c25ee3fc44"></a>TID_VIA_EMM_S&#160;</td><td class="fielddoc"><p>Table id for Viaccess EMM-S. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037af9e7a0c60353fc9de9397be664c12d9d"></a>TID_MG_EMM_U&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-U. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037ab6bf9ae0f8f2e4e34cd330d56cc4a5b5"></a>TID_MG_EMM_A&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-A. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a87842feaec3068fd54862a4e88a6c5c5"></a>TID_MG_EMM_I&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-I. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a9d4f38a721605ea7f49a177964447f5a"></a>TID_MG_EMM_G&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-G. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a9c13db3b04a7feb291a11732b1e8df46"></a>TID_MG_EMM_C&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-C. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae56343654e2b01380409afc12dd2b037a6cd215233ac84a1c86bfe9a9e1e5db08"></a>TID_MG_EMM_CG&#160;</td><td class="fielddoc"><p>Table id for MediaGuard EMM-CG. </p>
</td></tr>
</table>

</div>
</div>
<a id="af527bab7b821ddcd06cec9ee953c67f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af527bab7b821ddcd06cec9ee953c67f3">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Private data specifier (PDS) values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a8fb8f085bba8e86e7a051bc7ef647985"></a>PDS_NAGRA&#160;</td><td class="fielddoc"><p>Private data specifier for Nagra (1). </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a6b556756a51afa9aa9c5af408ad58e5e"></a>PDS_NAGRA_2&#160;</td><td class="fielddoc"><p>Private data specifier for Nagra (2). </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a9f082e0dbb08a7d81a3baf51146118d0"></a>PDS_NAGRA_3&#160;</td><td class="fielddoc"><p>Private data specifier for Nagra (3). </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a02fc87186aa6ef5e13115ecd095a5fc0"></a>PDS_NAGRA_4&#160;</td><td class="fielddoc"><p>Private data specifier for Nagra (4). </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a5919a56e77b3c760c45d62e3a7863a54"></a>PDS_NAGRA_5&#160;</td><td class="fielddoc"><p>Private data specifier for Nagra (5). </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a998ec8c870daf1febc31daada13fc47f"></a>PDS_TPS&#160;</td><td class="fielddoc"><p>Private data specifier for TPS. </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3aa7935f7e276a52d3185fc6b7f67fe46e"></a>PDS_EACEM&#160;</td><td class="fielddoc"><p>Private data specifier for EACEM / EICTA. </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a58039b6e3fc4749508e7d9b918d88938"></a>PDS_EICTA&#160;</td><td class="fielddoc"><p>Private data specifier for EACEM / EICTA. </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a75148d08d494405942f8716665f175c2"></a>PDS_LOGIWAYS&#160;</td><td class="fielddoc"><p>Private data specifier for Logiways. </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a5ba212c1c98888b29fa6e0de352c978a"></a>PDS_CANALPLUS&#160;</td><td class="fielddoc"><p>Private data specifier for Canal+. </p>
</td></tr>
<tr><td class="fieldname"><a id="af527bab7b821ddcd06cec9ee953c67f3a5d46f2f177335db690b080c7094688b6"></a>PDS_EUTELSAT&#160;</td><td class="fielddoc"><p>Private data specifier for EutelSat. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad86644912ed316d3a3109e2c313bf797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86644912ed316d3a3109e2c313bf797">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="namespacets.html#a6d34ed2bcf670e7b2a310f660ca900ee">DID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">Descriptor</a> tag values (descriptor identification, DID) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab2effbf25052322ca83820e2057ccd8e"></a>DID_VIDEO&#160;</td><td class="fielddoc"><p>DID for video_stream_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a1bc31446e45db604f42d40c8b4a3610b"></a>DID_AUDIO&#160;</td><td class="fielddoc"><p>DID for audio_stream_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2a82ef43f5886937eb14fd035925034b"></a>DID_HIERARCHY&#160;</td><td class="fielddoc"><p>DID for hierarchy_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797add70fd64756039ba418c23f1e05b63df"></a>DID_REGISTRATION&#160;</td><td class="fielddoc"><p>DID for registration_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac5288d63c27f32913565f42a7cd1b975"></a>DID_DATA_ALIGN&#160;</td><td class="fielddoc"><p>DID for data_stream_alignment_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac473c5df3d67cded130240f0414ad0e2"></a>DID_TGT_BG_GRID&#160;</td><td class="fielddoc"><p>DID for target_background_grid_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac5b80f99116d302d0a07ab3156f08a20"></a>DID_VIDEO_WIN&#160;</td><td class="fielddoc"><p>DID for video_window_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8a86521d8862cc5acb467ca9557c0328"></a>DID_CA&#160;</td><td class="fielddoc"><p>DID for CA_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a80bc68e5a5986bce274fd3032be9c208"></a>DID_LANGUAGE&#160;</td><td class="fielddoc"><p>DID for ISO_639_language_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae29909d938f2f477f1bb943b82ca1ab4"></a>DID_SYS_CLOCK&#160;</td><td class="fielddoc"><p>DID for system_clock_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af2f648264d4a0ea40419b6d81f690e6b"></a>DID_MUX_BUF_USE&#160;</td><td class="fielddoc"><p>DID for multiplex_buffer_utilization_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad81cf58fc33b84f1972ffbc4a08ef3b8"></a>DID_COPYRIGHT&#160;</td><td class="fielddoc"><p>DID for copyright_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a70a93a464bf67da6fc2b89157d524690"></a>DID_MAX_BITRATE&#160;</td><td class="fielddoc"><p>DID for maximum bitrate descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad717b0f8ca18789e9b26a3c2da1c509a"></a>DID_PRIV_DATA_IND&#160;</td><td class="fielddoc"><p>DID for private data indicator descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a10c7eb2671a73cb4c77a060396fc8831"></a>DID_SMOOTH_BUF&#160;</td><td class="fielddoc"><p>DID for smoothing buffer descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5cbcacf1153ca8056638401567b43283"></a>DID_STD&#160;</td><td class="fielddoc"><p>DID for STD_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac9c051117dbd60673517d8360440058a"></a>DID_IBP&#160;</td><td class="fielddoc"><p>DID for IBP descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6bc7153b7a2aad94f57df9cbed7e10d7"></a>DID_MPEG4_VIDEO&#160;</td><td class="fielddoc"><p>DID for MPEG-4_video_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a4dd60f11476e7d65d0d1d3637a07d59e"></a>DID_MPEG4_AUDIO&#160;</td><td class="fielddoc"><p>DID for MPEG-4_audio_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad09aa07136333b7ca19e0c62dabb417c"></a>DID_IOD&#160;</td><td class="fielddoc"><p>DID for IOD_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa9e52524f5966f47daa52c6891dc9dc4"></a>DID_SL&#160;</td><td class="fielddoc"><p>DID for SL_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a104a61f8b90ef5c6d4051360b3bdf46c"></a>DID_FMC&#160;</td><td class="fielddoc"><p>DID for FMC_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aacc8a98e295fce907e8d29cc053ea419"></a>DID_EXT_ES_ID&#160;</td><td class="fielddoc"><p>DID for External_ES_id_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2c5998e74614ede3310e131ad3293a40"></a>DID_MUXCODE&#160;</td><td class="fielddoc"><p>DID for MuxCode_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2f9bd96fab7fd6af98bfa09bdca58f57"></a>DID_FMX_BUFFER_SIZE&#160;</td><td class="fielddoc"><p>DID for FmxBufferSize_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8fa0e448959220d3eb3e5335bbf316db"></a>DID_MUX_BUFFER&#160;</td><td class="fielddoc"><p>DID for MultiplexBuffer_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abf4bbe1f169c2572cbd1e9a77922f1c2"></a>DID_CONTENT_LABELING&#160;</td><td class="fielddoc"><p>DID for Content_labeling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad9d7e0029141deee84af5e40d0d25f64"></a>DID_METADATA_ASSOC&#160;</td><td class="fielddoc"><p>DID for Metadata_association_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad5d91308ac7ee7622686473462f9338b"></a>DID_METADATA&#160;</td><td class="fielddoc"><p>DID for Metadata_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5745172f79735da29b2122c3cf92a603"></a>DID_METADATA_STD&#160;</td><td class="fielddoc"><p>DID for Metadata_STD_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac2da933b4b7bba785aa319691bcaab7c"></a>DID_AVC_VIDEO&#160;</td><td class="fielddoc"><p>DID for AVC_video_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0624bacbfb038371a9e6e557f16bce1b"></a>DID_MPEG2_IPMP&#160;</td><td class="fielddoc"><p>DID for MPEG-2_IPMP_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa956ff09455f3cd52015e73b2edb31f7"></a>DID_AVC_TIMING_HRD&#160;</td><td class="fielddoc"><p>DID for AVC_timing_and_HRD_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a272d2353115c65eef5e6430692850fdd"></a>DID_NETWORK_NAME&#160;</td><td class="fielddoc"><p>DID for DVB network_name_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797afd40c0e6746750b47a889a7f8b87db10"></a>DID_SERVICE_LIST&#160;</td><td class="fielddoc"><p>DID for DVB service_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6ba3b888ddd63bd6eb37f95f0623341c"></a>DID_STUFFING&#160;</td><td class="fielddoc"><p>DID for DVB stuffing_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7a5f26296d5c60bc41095c7bfb04771d"></a>DID_SAT_DELIVERY&#160;</td><td class="fielddoc"><p>DID for DVB satellite_delivery_system_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac34d6f896236bb18906079bdeb2f94dc"></a>DID_CABLE_DELIVERY&#160;</td><td class="fielddoc"><p>DID for DVB cable_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6b555c15e21a2807f3b9124af39da486"></a>DID_VBI_DATA&#160;</td><td class="fielddoc"><p>DID for DVB VBI_data_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a269e89bcc524d433b193f8138e2c2f8e"></a>DID_VBI_TELETEXT&#160;</td><td class="fielddoc"><p>DID for DVB VBI_teletext_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a3b711279dc3c5e2b14ff30fbfe1067c7"></a>DID_BOUQUET_NAME&#160;</td><td class="fielddoc"><p>DID for DVB bouquet_name_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a9e8ed5f3efdf5ef376f8904422c354ae"></a>DID_SERVICE&#160;</td><td class="fielddoc"><p>DID for DVB service_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7f846280672cc3f82d21753bbad71fd5"></a>DID_COUNTRY_AVAIL&#160;</td><td class="fielddoc"><p>DID for DVB country_availability_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab32d8c68f070879da2143ebb4e6598f0"></a>DID_LINKAGE&#160;</td><td class="fielddoc"><p>DID for DVB linkage_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a568a3891c1511c225a7faa20427105bd"></a>DID_NVOD_REFERENCE&#160;</td><td class="fielddoc"><p>DID for DVB NVOD_reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2af1d6c31d8836d4c5fbc77a6ce3e229"></a>DID_TIME_SHIFT_SERVICE&#160;</td><td class="fielddoc"><p>DID for DVB time_shifted_service_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797acbaa405744d6e79072c4c16cab6d27fb"></a>DID_SHORT_EVENT&#160;</td><td class="fielddoc"><p>DID for DVB short_event_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abecac052f6146fa5112c1e7e817dcf20"></a>DID_EXTENDED_EVENT&#160;</td><td class="fielddoc"><p>DID for DVB extended_event_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad7a1e105be7cd9a403d1e0e851c40e07"></a>DID_TIME_SHIFT_EVENT&#160;</td><td class="fielddoc"><p>DID for DVB time_shifted_event_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8d04e00d78658868fc9d7cd384402b0b"></a>DID_COMPONENT&#160;</td><td class="fielddoc"><p>DID for DVB component_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a3661962fe63b2ee19c40de0b44f7568a"></a>DID_MOSAIC&#160;</td><td class="fielddoc"><p>DID for DVB mosaic_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab42fa3f6be42e0c46e83cb6b1c5db24b"></a>DID_STREAM_ID&#160;</td><td class="fielddoc"><p>DID for DVB stream_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af4d04064001533408cdf256aa3cfd44c"></a>DID_CA_ID&#160;</td><td class="fielddoc"><p>DID for DVB CA_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad4d2f30eacc75143ef65900317a1c504"></a>DID_CONTENT&#160;</td><td class="fielddoc"><p>DID for DVB content_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a371432833e8fa2f302ebb438b37ffbed"></a>DID_PARENTAL_RATING&#160;</td><td class="fielddoc"><p>DID for DVB parental_rating_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab711e704b83c2e6cebf975e860519414"></a>DID_TELETEXT&#160;</td><td class="fielddoc"><p>DID for DVB teletext_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa75e6cdf963c6c7d2740367a1db59894"></a>DID_TELEPHONE&#160;</td><td class="fielddoc"><p>DID for DVB telephone_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a85b6dd671003c7243fb4d550010febc0"></a>DID_LOCAL_TIME_OFFSET&#160;</td><td class="fielddoc"><p>DID for DVB local_time_offset_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a23e74855e386c285c340c9f54c85d919"></a>DID_SUBTITLING&#160;</td><td class="fielddoc"><p>DID for DVB subtitling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a41e190ae11ec3be18423079683e8cdd6"></a>DID_TERREST_DELIVERY&#160;</td><td class="fielddoc"><p>DID for DVB terrestrial_delivery_system_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a09178207ef07a2a31b749b0e89e025fe"></a>DID_MLINGUAL_NETWORK&#160;</td><td class="fielddoc"><p>DID for DVB multilingual_network_name_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8a211c58e2ea2116e97bf0a55f6bf112"></a>DID_MLINGUAL_BOUQUET&#160;</td><td class="fielddoc"><p>DID for DVB multilingual_bouquet_name_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad1c90fbcaa307e57d313b8d2f196a70a"></a>DID_MLINGUAL_SERVICE&#160;</td><td class="fielddoc"><p>DID for DVB multilingual_service_name_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797acbb9004b2d83226e7a559687c9937af4"></a>DID_MLINGUAL_COMPONENT&#160;</td><td class="fielddoc"><p>DID for DVB multilingual_component_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7bb89e2ec8e56da6bf019dcd7feaaa37"></a>DID_PRIV_DATA_SPECIF&#160;</td><td class="fielddoc"><p>DID for DVB private_data_specifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac62508a1790b47ac49680a94eb9d0cb7"></a>DID_SERVICE_MOVE&#160;</td><td class="fielddoc"><p>DID for DVB service_move_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae4bd47f9991a7c4ec5508ce619a9e766"></a>DID_SHORT_SMOOTH_BUF&#160;</td><td class="fielddoc"><p>DID for DVB short_smoothing_buffer_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac10736a8898885043d0203b6b0a50c41"></a>DID_FREQUENCY_LIST&#160;</td><td class="fielddoc"><p>DID for DVB frequency_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa01adab187fc896205a0ba58ebaac167"></a>DID_PARTIAL_TS&#160;</td><td class="fielddoc"><p>DID for DVB partial_transport_stream_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa514ee1ebd6451480eff60f288eab0fa"></a>DID_DATA_BROADCAST&#160;</td><td class="fielddoc"><p>DID for DVB data_broadcast_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a47d9da1700f3d033b8f0a1b7d02008bd"></a>DID_SCRAMBLING&#160;</td><td class="fielddoc"><p>DID for DVB scrambling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a59048f1e2e39873ab0798ca9e3902df2"></a>DID_DATA_BROADCAST_ID&#160;</td><td class="fielddoc"><p>DID for DVB data_broadcast_id_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aeee73d3dc9068d4a9d9020667e051005"></a>DID_TRANSPORT_STREAM&#160;</td><td class="fielddoc"><p>DID for DVB transport_stream_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6fb6a7cdef53fe3719b373ccbb810be3"></a>DID_DSNG&#160;</td><td class="fielddoc"><p>DID for DVB DSNG_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abb7214a6c187b036c1af4ddb2e363884"></a>DID_PDC&#160;</td><td class="fielddoc"><p>DID for DVB PDC_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a33ba6989021d614d2aeea33e7510fbb8"></a>DID_AC3&#160;</td><td class="fielddoc"><p>DID for DVB AC-3_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a790a9b0fe3e2585e597e2621a55474fb"></a>DID_ANCILLARY_DATA&#160;</td><td class="fielddoc"><p>DID for DVB ancillary_data_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8ce45f6b9ccb7c73beddf39f9135f2be"></a>DID_CELL_LIST&#160;</td><td class="fielddoc"><p>DID for DVB cell_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0c502ec558a0e10488551e9ede9ea59b"></a>DID_CELL_FREQ_LINK&#160;</td><td class="fielddoc"><p>DID for DVB cell_frequency_link_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797afcefc07be78ebfa60f609227a314cd40"></a>DID_ANNOUNCE_SUPPORT&#160;</td><td class="fielddoc"><p>DID for DVB announcement_support_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5e9298a75170d6066dfda611fd065c0e"></a>DID_APPLI_SIGNALLING&#160;</td><td class="fielddoc"><p>DID for DVB application_signalling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae25438926e8e5cc636c28d497ecf9baa"></a>DID_ADAPTFIELD_DATA&#160;</td><td class="fielddoc"><p>DID for DVB adaptation_field_data_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a404188e1b6e700dfe88b0a50613ff088"></a>DID_SERVICE_ID&#160;</td><td class="fielddoc"><p>DID for DVB service_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a138b0652e568c26bbe68a48964db2e9c"></a>DID_SERVICE_AVAIL&#160;</td><td class="fielddoc"><p>DID for DVB service_availability_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a4eeb644bef98c14f789cebf6adecec2d"></a>DID_DEFAULT_AUTHORITY&#160;</td><td class="fielddoc"><p>DID for DVB default_authority_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a97395366b9f7dd1bc35f3e2755810f6f"></a>DID_RELATED_CONTENT&#160;</td><td class="fielddoc"><p>DID for DVB related_content_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6e10f48920d9b40324c7b71eb7d4ed25"></a>DID_TVA_ID&#160;</td><td class="fielddoc"><p>DID for DVB TVA_id_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7dc4b8be0006656da97fd8dfd0b1472f"></a>DID_CONTENT_ID&#160;</td><td class="fielddoc"><p>DID for DVB content_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac60e3c13afabd1c7597c3133dd85dfc7"></a>DID_TIME_SLICE_FEC_ID&#160;</td><td class="fielddoc"><p>DID for DVB time_slice_fec_identifier_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2639dde2b94888a8e64bb13b48806c60"></a>DID_ECM_REPETITION_RATE&#160;</td><td class="fielddoc"><p>DID for DVB ECM_repetition_rate_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a81eca939426a0d23760a9a83718e669c"></a>DID_S2_SAT_DELIVERY&#160;</td><td class="fielddoc"><p>DID for DVB S2_satellite_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa5667f7a0eb12f656d033602784226da"></a>DID_ENHANCED_AC3&#160;</td><td class="fielddoc"><p>DID for DVB enhanced_AC-3_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af7313a07d460d448f21667cfa03854de"></a>DID_DTS&#160;</td><td class="fielddoc"><p>DID for DVB DTS_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797acc728080a2c6714af8a007c23444bc21"></a>DID_AAC&#160;</td><td class="fielddoc"><p>DID for DVB AAC_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a44ebe007c396f0663e1d081bcc26ace5"></a>DID_XAIT_LOCATION&#160;</td><td class="fielddoc"><p>DID for DVB XAIT_location_descriptor (DVB-MHP) </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5a3459ae4241ba34bce8599e5a8bd8e7"></a>DID_FTA_CONTENT_MGMT&#160;</td><td class="fielddoc"><p>DID for DVB FTA_content_management_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a92a86a67e5972c70354814d376877e52"></a>DID_EXTENSION&#160;</td><td class="fielddoc"><p>DID for DVB extension_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797afd2a8afb3099a6153ec474597a4d2077"></a>DID_ATSC_STUFFING&#160;</td><td class="fielddoc"><p>DID for ATSC stuffing_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a81c493055ea1217a6e7ed5cd7d7da568"></a>DID_AC3_AUDIO_STREAM&#160;</td><td class="fielddoc"><p>DID for ATSC ac3_audio_stream_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2f9a6a552740ac7cee41cf38e4206729"></a>DID_ATSC_PID&#160;</td><td class="fielddoc"><p>DID for ATSC program_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a11d3e6b059ef84f818f1ce2dbdfdf9d3"></a>DID_CAPTION&#160;</td><td class="fielddoc"><p>DID for ATSC caption_service_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac9471fad8b253efc1308410899196881"></a>DID_CONTENT_ADVIS&#160;</td><td class="fielddoc"><p>DID for ATSC content_advisory_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a4c815e50661599cdada598a5cbe8e3a2"></a>DID_EXT_CHAN_NAME&#160;</td><td class="fielddoc"><p>DID for ATSC extended_channel_name_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7b282b015f8abca55d5724cc1adec6f3"></a>DID_SERV_LOCATION&#160;</td><td class="fielddoc"><p>DID for ATSC service_location_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a3c2a5309542f3755999ac4dcae5f6e53"></a>DID_ATSC_TIME_SHIFT&#160;</td><td class="fielddoc"><p>DID for ATSC time_shifted_event_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a14eb6c61f9fcc7dd4dfc9d7f100a6faa"></a>DID_COMPONENT_NAME&#160;</td><td class="fielddoc"><p>DID for ATSC component_name_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8a0dfa2b6c1a4d685f0443dbff833b31"></a>DID_ATSC_DATA_BRDCST&#160;</td><td class="fielddoc"><p>DID for ATSC data_broadcast_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac27c86d2b26dae3701b48b2b6bc35bca"></a>DID_PID_COUNT&#160;</td><td class="fielddoc"><p>DID for ATSC pid_count_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abe7a03b298f4d02c213dfdca67a9c3a7"></a>DID_DOWNLOAD&#160;</td><td class="fielddoc"><p>DID for ATSC download_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab61412e0cb1734add550d52b741ace9d"></a>DID_MPROTO_ENCAPS&#160;</td><td class="fielddoc"><p>DID for ATSC multiprotocol_encapsulation_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797afec7f185b20b1e5bab26867d4b55b29d"></a>DID_LW_SUBSCRIPTION&#160;</td><td class="fielddoc"><p>DID for Logiways subscription_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a30531dec532de8565e60b571766fdb8a"></a>DID_LW_SCHEDULE&#160;</td><td class="fielddoc"><p>DID for Logiways schedule_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a31aab0c37e8580c2655cfeb700c24603"></a>DID_LW_PRIV_COMPONENT&#160;</td><td class="fielddoc"><p>DID for Logiways private_component_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a18481d5cda727106fa736061cf769ad6"></a>DID_LW_PRIV_LINKAGE&#160;</td><td class="fielddoc"><p>DID for Logiways private_linkage_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0c8532405be6f48bf8ef6acc4d109cae"></a>DID_LW_CHAPTER&#160;</td><td class="fielddoc"><p>DID for Logiways chapter_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a77aaa644ba49af0b83172bed5ab41763"></a>DID_LW_DRM&#160;</td><td class="fielddoc"><p>DID for Logiways DRM_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab0c6b23afdcbb06edc4963abe63e7cd8"></a>DID_LW_VIDEO_SIZE&#160;</td><td class="fielddoc"><p>DID for Logiways video_size_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a3b2c02552c605df274fcb7da860a3ddc"></a>DID_LW_EPISODE&#160;</td><td class="fielddoc"><p>DID for Logiways episode_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af82523c15894677ab91e4837ded31f93"></a>DID_LW_PRICE&#160;</td><td class="fielddoc"><p>DID for Logiways price_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a1791237efab90807a89a5ff28b6af45c"></a>DID_LW_ASSET_REFERENCE&#160;</td><td class="fielddoc"><p>DID for Logiways asset_reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a93d9c8634555a3dd93c869ae03a74491"></a>DID_LW_CONTENT_CODING&#160;</td><td class="fielddoc"><p>DID for Logiways content_coding_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a53484db4ae1f3bbff7fe1d090ff37240"></a>DID_LW_VOD_COMMAND&#160;</td><td class="fielddoc"><p>DID for Logiways vod_command_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7006cd9ceb73d0cca7dec83a953e7714"></a>DID_LW_DELETION_DATE&#160;</td><td class="fielddoc"><p>DID for Logiways deletion_date_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab569d4c0d0f7af32b889000deb9cbbb6"></a>DID_LW_PLAY_LIST&#160;</td><td class="fielddoc"><p>DID for Logiways play_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aad3da56bca7e52a642ed27457a595921"></a>DID_LW_PLAY_LIST_ENTRY&#160;</td><td class="fielddoc"><p>DID for Logiways play_list_entry_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7c249fb4d36bd96b1e05dfd422576d4e"></a>DID_LW_ORDER_CODE&#160;</td><td class="fielddoc"><p>DID for Logiways order_code_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a42b41533e61fe1a4586ced0c36ad80b7"></a>DID_LW_BOUQUET_REFERENCE&#160;</td><td class="fielddoc"><p>DID for Logiways bouquet_reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5e0e7ce708c7b6092c0bfaf3231709ff"></a>DID_EUTELSAT_CHAN_NUM&#160;</td><td class="fielddoc"><p>DID for eutelsat_channel_number_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac65f9add2829fa7e7c1ba048e46f62d7"></a>DID_LOGICAL_CHANNEL_NUM&#160;</td><td class="fielddoc"><p>DID for EACEM/EICTA logical_channel_number_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a2a53a68c03527f8a1e6c00eb0c94a985"></a>DID_PREF_NAME_LIST&#160;</td><td class="fielddoc"><p>DID for EACEM/EICTA preferred_name_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae61025d266ae91b138b1d7054d6d9185"></a>DID_PREF_NAME_ID&#160;</td><td class="fielddoc"><p>DID for EACEM/EICTA preferred_name_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aef0b5e0965ac1996efe27fa31c3900bd"></a>DID_EACEM_STREAM_ID&#160;</td><td class="fielddoc"><p>DID for EACEM/EICTA eacem_stream_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a1ac305f14efb23d55d276fafb3b95db1"></a>DID_HD_SIMULCAST_LCN&#160;</td><td class="fielddoc"><p>DID for EACEM/EICTA HD_simulcast_logical_channel_number_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0310b81faabaf896e97890baef588bb9"></a>DID_DTG_STREAM_IND&#160;</td><td class="fielddoc"><p>DID for Canal+ DTG_Stream_indicator_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a686800ff5b2134ab44a105a6d18189df"></a>DID_PIO_OFFSET_TIME&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_offset_time_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6e14f8f7bc9fbb95ed1bd575d403d2e8"></a>DID_LOGICAL_CHANNEL_81&#160;</td><td class="fielddoc"><p>DID for Canal+ logical_channel_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0409e10273a8abde6a20bcb71116527c"></a>DID_PRIVATE2&#160;</td><td class="fielddoc"><p>DID for Canal+ private_descriptor2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af0e69e3d74658c8de407ecd8ce41b8c2"></a>DID_LOGICAL_CHANNEL&#160;</td><td class="fielddoc"><p>DID for Canal+ logical_channel_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa2a0b7c50212d39ed0366d077d97442b"></a>DID_PIO_CONTENT&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_content_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a6f6c6adda03725f9495c152e9f298bd1"></a>DID_PIO_LOGO&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_logo_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a11ef0ade4584e0b0bebb1547f05c98ca"></a>DID_ADSL_DELIVERY&#160;</td><td class="fielddoc"><p>DID for Canal+ adsl_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a58d5fd611b3e4258efdb15f4af55daf2"></a>DID_PIO_FEE&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_fee_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac6a95ce6c545548cff70ef89286d8d53"></a>DID_PIO_EVENT_RANGE&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_event_range_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7045df3c39767fd6a48d21f0d2200224"></a>DID_PIO_COPY_MANAGEMENT&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_copy_management_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a86b9e6bc741e7f47d5b54ba3588b44e8"></a>DID_PIO_COPY_CONTROL&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_copy_control_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a275b1b0035798142c76c4f547dc3e0e9"></a>DID_PIO_PPV&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_ppv_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae6bbe919c6a08c04d931e95e3b89a24c"></a>DID_PIO_STB_SERVICE_ID&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_stb_service_id_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa28575cc3f5307fe81cf9ef6a1443a0e"></a>DID_PIO_MASKING_SERV_ID&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_masking_service_id_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a312ffa7f54ad0c8f3d5fb6019a5235cb"></a>DID_PIO_STB_SERVMAP_UPD&#160;</td><td class="fielddoc"><p>DID for Canal+ pio_stb_service_map_update_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a112558a31f852226b041e949c280309a"></a>DID_NEW_SERVICE_LIST&#160;</td><td class="fielddoc"><p>DID for Canal+ new_service_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a3b5b74db153e17711afbc3bf45daa99a"></a>DID_MESSAGE_NAGRA&#160;</td><td class="fielddoc"><p>DID for Canal+ message_descriptor_Nagra. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aa728edce83eb10bf24462f5afa7e0dab"></a>DID_ITEM_EVENT&#160;</td><td class="fielddoc"><p>DID for Canal+ item_event_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a08dfaac329428c1431571ba028aaa3ea"></a>DID_ITEM_ZAPPING&#160;</td><td class="fielddoc"><p>DID for Canal+ item_zapping_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797afe642776f25cca6ed1e7eb15d11ab0dc"></a>DID_APPLI_MESSAGE&#160;</td><td class="fielddoc"><p>DID for Canal+ appli_message_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a9eb2f0d2f68ed4e392b5b050c5a84f36"></a>DID_LIST&#160;</td><td class="fielddoc"><p>DID for Canal+ list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8907af68f4cad2585a29475ab191941e"></a>DID_KEY_LIST&#160;</td><td class="fielddoc"><p>DID for Canal+ key_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aae9b6d7306fa7f89d208b7992e40c6d4"></a>DID_PICTURE_SIGNALLING&#160;</td><td class="fielddoc"><p>DID for Canal+ picture_signalling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a36e5409ab3f46aff61300756bd35a01a"></a>DID_COUNTER_BB&#160;</td><td class="fielddoc"><p>DID for Canal+ counter_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aab098ed1b42c2efe0f8da6253ac8d302"></a>DID_DATA_COMPONENT_BD&#160;</td><td class="fielddoc"><p>DID for Canal+ data_component_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a8e703e102818edc38420d5f1e555ab09"></a>DID_SYSTEM_MGMT_BE&#160;</td><td class="fielddoc"><p>DID for Canal+ system_management_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abe016f5910b6d77c0d2bfc4b897cca4e"></a>DID_VO_LANGUAGE&#160;</td><td class="fielddoc"><p>DID for Canal+ vo_language_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a568163bac05a8e012314425a4eea214a"></a>DID_DATA_LIST&#160;</td><td class="fielddoc"><p>DID for Canal+ data_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0beba6687a0c871a415e8a6d3fcfb5df"></a>DID_APPLI_LIST&#160;</td><td class="fielddoc"><p>DID for Canal+ appli_list_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aeebae241f653638e3f51ee7bea04e0c9"></a>DID_MESSAGE&#160;</td><td class="fielddoc"><p>DID for Canal+ message_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5504e21be01569d5ccc1c68601b782f1"></a>DID_FILE&#160;</td><td class="fielddoc"><p>DID for Canal+ file_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a897e8c8c16cae9ceedddd2850770984d"></a>DID_RADIO_FORMAT&#160;</td><td class="fielddoc"><p>DID for Canal+ radio_format_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a1dc575dddacb7cfb9e11971c54589577"></a>DID_APPLI_STARTUP&#160;</td><td class="fielddoc"><p>DID for Canal+ appli_startup_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a47e1703fcdaf751cbd173206ab3ce011"></a>DID_PATCH&#160;</td><td class="fielddoc"><p>DID for Canal+ patch_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a253aedb309feb01966741ebcf8215986"></a>DID_LOADER&#160;</td><td class="fielddoc"><p>DID for Canal+ loader_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a58dd0bc2033e18c1b8fb56a2f88714a9"></a>DID_CHANNEL_MAP_UPDATE&#160;</td><td class="fielddoc"><p>DID for Canal+ channel_map_update_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abde49a5d2e98089bd4e6b6084c1555fe"></a>DID_PPV&#160;</td><td class="fielddoc"><p>DID for Canal+ ppv_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aadcf0e235474e82d3099d98a5a47dbbc"></a>DID_COUNTER_CB&#160;</td><td class="fielddoc"><p>DID for Canal+ counter_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7fa96c71804dba8ab3b94e050720cca3"></a>DID_OPERATOR_INFO&#160;</td><td class="fielddoc"><p>DID for Canal+ operator_info_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af86631b0bcd9d47a60619000eeba1499"></a>DID_SERVICE_DEF_PARAMS&#160;</td><td class="fielddoc"><p>DID for Canal+ service_default_parameters_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad3cf2d8f05b2c90a6182824a7582f8e1"></a>DID_FINGER_PRINTING&#160;</td><td class="fielddoc"><p>DID for Canal+ finger_printing_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797adf183c732420a7a13e2d2d7722b8d826"></a>DID_FINGER_PRINTING_V2&#160;</td><td class="fielddoc"><p>DID for Canal+ finger_printing_descriptor_v2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ab59d3c071cd599c535d53d9cc28ce2a9"></a>DID_CONCEALED_GEO_ZONES&#160;</td><td class="fielddoc"><p>DID for Canal+ concealed_geo_zones_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a55314e165adfbc8816a9b300ea2a77c2"></a>DID_COPY_PROTECTION&#160;</td><td class="fielddoc"><p>DID for Canal+ copy_protection_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ae3e365cd6d237935e7d73303ed13d3b7"></a>DID_MG_SUBSCRIPTION&#160;</td><td class="fielddoc"><p>DID for Canal+ subscription_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797af136ba6ac6ea37fae7ba00a39fde95f9"></a>DID_CABLE_BACKCH_DELIV&#160;</td><td class="fielddoc"><p>DID for Canal+ cable_backchannel_delivery_system. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aebe1b3bbc4a5a49ef976c896005a6b98"></a>DID_INTERACT_SNAPSHOT&#160;</td><td class="fielddoc"><p>DID for Canal+ Interactivity_snapshot_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a359b734d03f766a018eb7423fac78d57"></a>DID_ICON_POSITION&#160;</td><td class="fielddoc"><p>DID for Canal+ icon_position_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a97d68a598f7deff41914b4b3e3d46795"></a>DID_ICON_PIXMAP&#160;</td><td class="fielddoc"><p>DID for Canal+ icon_pixmap_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5aa44755143e49bd840c2783c3817373"></a>DID_ZONE_COORDINATE&#160;</td><td class="fielddoc"><p>DID for Canal+ Zone_coordinate_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a23b9219871827fb27b5c05fa21b51524"></a>DID_HD_APP_CONTROL_CODE&#160;</td><td class="fielddoc"><p>DID for Canal+ HD_application_control_code_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abb040861cd912f6b527aad01ac752783"></a>DID_EVENT_REPEAT&#160;</td><td class="fielddoc"><p>DID for Canal+ Event_Repeat_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a528020d4ccb6716d690d14e568dc83ad"></a>DID_PPV_V2&#160;</td><td class="fielddoc"><p>DID for Canal+ PPV_V2_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a802a1804be51d2311f9535a3410f27b0"></a>DID_HYPERLINK_REF&#160;</td><td class="fielddoc"><p>DID for Canal+ Hyperlink_ref_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a4214102e15ea7d77070d66c55c7eb47c"></a>DID_SHORT_SERVICE&#160;</td><td class="fielddoc"><p>DID for Canal+ Short_service_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ac70057864d0ad5e4acb4d03e703b4b87"></a>DID_OPERATOR_TELEPHONE&#160;</td><td class="fielddoc"><p>DID for Canal+ Operator_telephone_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a42599269bcaeebc3ee99b59bf38c81db"></a>DID_ITEM_REFERENCE&#160;</td><td class="fielddoc"><p>DID for Canal+ Item_reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a5868397ea3e6357d8d0735a75b7cc263"></a>DID_MH_PARAMETERS&#160;</td><td class="fielddoc"><p>DID for Canal+ MH_Parameters_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a54553945a5889256422d7fbcda054cc2"></a>DID_LOGICAL_REFERENCE&#160;</td><td class="fielddoc"><p>DID for Canal+ Logical_reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a859bb0363447323101946bc0d3e51a54"></a>DID_DATA_VERSION&#160;</td><td class="fielddoc"><p>DID for Canal+ Data_Version_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a215f91319a5aa8fbc0a4c4ea0718e0ee"></a>DID_SERVICE_GROUP&#160;</td><td class="fielddoc"><p>DID for Canal+ Service_group_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a07e8026c101f61e01d9c23fe0b4ffa35"></a>DID_STREAM_LOC_TRANSP&#160;</td><td class="fielddoc"><p>DID for Canal+ Stream_Locator_Transport_desc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a0c616fe9ddc183431d3d6e04b1d83d95"></a>DID_DATA_LOCATOR&#160;</td><td class="fielddoc"><p>DID for Canal+ Data_Locator_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad2e5f3ec7a15260637772bcec8da2f29"></a>DID_RESIDENT_APP&#160;</td><td class="fielddoc"><p>DID for Canal+ resident_application_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a738b57b676f86379a8bba33dc891f8fa"></a>DID_RESIDENT_APP_SIGNAL&#160;</td><td class="fielddoc"><p>DID for Canal+ Resident_Application_Signalling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad4f2eb17a0305a31c9bb4324105c6b14"></a>DID_MH_LOGICAL_REF&#160;</td><td class="fielddoc"><p>DID for Canal+ MH_Logical_Reference_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797aee6dca68f261e745699ea19f741b542e"></a>DID_RECORD_CONTROL&#160;</td><td class="fielddoc"><p>DID for Canal+ record_control_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a136dfd94cb9a4a6b3babdd82680cf124"></a>DID_CMPS_RECORD_CONTROL&#160;</td><td class="fielddoc"><p>DID for Canal+ cmps_record_control_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797ad3205e97ffa1ec571b560657bde4d0ac"></a>DID_EPISODE&#160;</td><td class="fielddoc"><p>DID for Canal+ episode_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a7f7c580734ae097fba71a0419380d1cf"></a>DID_CMP_SELECTION&#160;</td><td class="fielddoc"><p>DID for Canal+ CMP_Selection_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797a70f1f88abecd2898ac247be9a3a15d55"></a>DID_DATA_COMPONENT_FD&#160;</td><td class="fielddoc"><p>DID for Canal+ data_component_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad86644912ed316d3a3109e2c313bf797abf2196ce2a0bc6d8f0f135f4d2903f81"></a>DID_SYSTEM_MGMT_FE&#160;</td><td class="fielddoc"><p>DID for Canal+ system_management_descriptor. </p>
</td></tr>
</table>

</div>
</div>
<a id="af65eca52660a5db7689e344a97f11ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65eca52660a5db7689e344a97f11ff9">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="namespacets.html#a6d34ed2bcf670e7b2a310f660ca900ee">DID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended descriptor tag values (in extension_descriptor) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a9397a430b78b55d37f835d74728543e8"></a>EDID_IMAGE_ICON&#160;</td><td class="fielddoc"><p>Ext.DID for image_icon_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9affefb23a7815791bcb645db083409609"></a>EDID_CPCM_DELIVERY_SIG&#160;</td><td class="fielddoc"><p>Ext.DID for cpcm_delivery_signalling_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9aaeacf4e235aad61fd96c36970e914b8a"></a>EDID_CP&#160;</td><td class="fielddoc"><p>Ext.DID for CP_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a588e5924b959743a8d9cbf65848dd4e1"></a>EDID_CP_IDENTIFIER&#160;</td><td class="fielddoc"><p>Ext.DID for CP_identifier_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9acbd1a1496c3cced500dceea62015791e"></a>EDID_T2_DELIVERY&#160;</td><td class="fielddoc"><p>Ext.DID for T2_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a478132d4a173908575f8724c49d875be"></a>EDID_SH_DELIVERY&#160;</td><td class="fielddoc"><p>Ext.DID for SH_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9afbc27a78625c80ea3f0294ab9d70c105"></a>EDID_SUPPL_AUDIO&#160;</td><td class="fielddoc"><p>Ext.DID for supplementary_audio_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9aea7462613ccb6767b78df85323b5c04e"></a>EDID_NETW_CHANGE_NOTIFY&#160;</td><td class="fielddoc"><p>Ext.DID for network_change_notify_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a450b08037f6eb854bf488f8ac76103e1"></a>EDID_MESSAGE&#160;</td><td class="fielddoc"><p>Ext.DID for message_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a85641ef8137e3d66d33951576305c4f1"></a>EDID_TARGET_REGION&#160;</td><td class="fielddoc"><p>Ext.DID for target_region_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a5fca01deb1c49ab1cbfcd374488cdf2c"></a>EDID_TARGET_REGION_NAME&#160;</td><td class="fielddoc"><p>Ext.DID for target_region_name_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a7c5e10dc4ed34be2f441f436850ca1ae"></a>EDID_SERVICE_RELOCATED&#160;</td><td class="fielddoc"><p>Ext.DID for service_relocated_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9ad5644d0fa46993f269f79f6a469cb5a2"></a>EDID_XAIT_PID&#160;</td><td class="fielddoc"><p>Ext.DID for XAIT_PID_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a5363b5b0eab1e878abc5900ea5249662"></a>EDID_C2_DELIVERY&#160;</td><td class="fielddoc"><p>Ext.DID for C2_delivery_system_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9aef307e2fdd7900f0cb62bce164f5c30d"></a>EDID_DTS_HD_AUDIO&#160;</td><td class="fielddoc"><p>Ext.DID for DTS_HD_audio_stream_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9abb53e6f6100eb973cfc5a573a765d94d"></a>EDID_DTS_NEURAL&#160;</td><td class="fielddoc"><p>Ext.DID for DTS_Neural_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9add3fc782ad94e94674945585b2a8645f"></a>EDID_VIDEO_DEPTH_RANGE&#160;</td><td class="fielddoc"><p>Ext.DID for video_depth_range_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9aab6aee86919fa41bf02d77dbdfa48ad8"></a>EDID_T2MI&#160;</td><td class="fielddoc"><p>Ext.DID for T2MI_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a2a6a4f046a4750b93e7a78eff14bbe96"></a>EDID_URI_LINKAGE&#160;</td><td class="fielddoc"><p>Ext.DID for URI_linkage_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a56e40ca751a731f315797f9e251b29f7"></a>EDID_CI_ANCILLARY_DATA&#160;</td><td class="fielddoc"><p>Ext.DID for CI_ancillary_data_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a87ce21034a68737e5a20eddeb086133f"></a>EDID_AC4&#160;</td><td class="fielddoc"><p>Ext.DID for AC4_descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="af65eca52660a5db7689e344a97f11ff9a0ccb2634533c4bd7da02c3b47367c872"></a>EDID_C2_BUNDLE_DELIVERY&#160;</td><td class="fielddoc"><p>Ext.DID for C2_bundle_system_delivery_descriptor. </p>
</td></tr>
</table>

</div>
</div>
<a id="a567862128828cb0aca97f42b61800495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567862128828cb0aca97f42b61800495">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linkage type values (in linkage_descriptor) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a43b03312d6d4c2d01b57841004c8fe93"></a>LINKAGE_INFO&#160;</td><td class="fielddoc"><p>Information service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a7c04c1e1698de9af1e502c1eed34223b"></a>LINKAGE_EPG&#160;</td><td class="fielddoc"><p>EPG service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a36158e249137b6ccd3151fb929b781f1"></a>LINKAGE_CA_REPLACE&#160;</td><td class="fielddoc"><p>CA replacement service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495ac62c317896edf1e095f19677bd8cdf8e"></a>LINKAGE_TS_NIT_BAT&#160;</td><td class="fielddoc"><p>TS containing complet network/bouquet SI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495ae1b8fa9b8378c290d528b9655ae5f229"></a>LINKAGE_SERVICE_REPLACE&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_service.html" title="Describe a DVB service. ">Service</a> replacement service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a345ac9d9e6639eb1711312dc55c91d03"></a>LINKAGE_DATA_BROADCAST&#160;</td><td class="fielddoc"><p>Data broadcast service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a4456ced5c78ccdb1ad52d7deba6f287e"></a>LINKAGE_RCS_MAP&#160;</td><td class="fielddoc"><p>RCS map. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495ac774177dd82f17a91f17c46c51438e86"></a>LINKAGE_HAND_OVER&#160;</td><td class="fielddoc"><p>Mobile hand-over. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a5b88d007b85462b3e07a4828dce3433c"></a>LINKAGE_SSU&#160;</td><td class="fielddoc"><p>System software update service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a43bbc0d543796c9947b0f6170b94bbaf"></a>LINKAGE_SSU_TABLE&#160;</td><td class="fielddoc"><p>TS containing SSU <a class="el" href="classts_1_1_b_a_t.html" title="Representation of a Bouquet Association Table (BAT). ">BAT</a> or <a class="el" href="classts_1_1_n_i_t.html" title="Representation of a Network Information Table (NIT) ">NIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a07dbe3437e1105857351731655663b82"></a>LINKAGE_IP_NOTIFY&#160;</td><td class="fielddoc"><p>IP/MAC notification service. </p>
</td></tr>
<tr><td class="fieldname"><a id="a567862128828cb0aca97f42b61800495a90eddc622703c3465952fb452cf442d3"></a>LINKAGE_INT_BAT_NIT&#160;</td><td class="fielddoc"><p>TS containing INT <a class="el" href="classts_1_1_b_a_t.html" title="Representation of a Bouquet Association Table (BAT). ">BAT</a> or <a class="el" href="classts_1_1_n_i_t.html" title="Representation of a Network Information Table (NIT) ">NIT</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad3b474791d0063369fb7eb5b3c5d9593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b474791d0063369fb7eb5b3c5d9593">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data broadcast id values (in data_broadcast[_id]_descriptor) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a5e854bc8b1615bda6a23fad70151c326"></a>DBID_DATA_PIPE&#160;</td><td class="fielddoc"><p>Data pipe. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a3c4667e64a6226fc2f9a8728b37a89aa"></a>DBID_ASYNC_DATA_STREAM&#160;</td><td class="fielddoc"><p>Asynchronous data stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593ab009ae42169bfbfb58c29edfc1b1e9c0"></a>DBID_SYNC_DATA_STREAM&#160;</td><td class="fielddoc"><p>Synchronous data stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a68085ba7aaa707971948593cae187580"></a>DBID_SYNCED_DATA_STREAM&#160;</td><td class="fielddoc"><p>Synchronised data stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593ad55f828edd163550e9862ba3f2ed7a3d"></a>DBID_MPE&#160;</td><td class="fielddoc"><p>Multi protocol encapsulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a326fddbe00e51a80077b2aaf4877f23e"></a>DBID_DATA_CSL&#160;</td><td class="fielddoc"><p>Data Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a5c4109707c334220f8cd9cab31dcab66"></a>DBID_OBJECT_CSL&#160;</td><td class="fielddoc"><p><a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a7e3d371de6aa4711f7d7e9fb19d2c7a9"></a>DBID_ATM&#160;</td><td class="fielddoc"><p>DVB ATM streams. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a12d754fe6d09fbcd01b5bb4510c4bff2"></a>DBID_HP_ASYNC_DATA_STREAM&#160;</td><td class="fielddoc"><p>Higher Protocols based on asynchronous data streams. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a8ed1735a7f3d9752bbe38a03d9341d89"></a>DBID_SSU&#160;</td><td class="fielddoc"><p>System Software Update service [TS 102 006]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593adeffb3a87ddbd34e993e4c706ba7bafc"></a>DBID_IPMAC_NOTIFICATION&#160;</td><td class="fielddoc"><p>IP/MAC Notification service [EN 301 192]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a891afde52d176ce396665deeea31b0d5"></a>DBID_MHP_OBJECT_CSL&#160;</td><td class="fielddoc"><p>MHP <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593acc126606247f09353b3101ebfc95e8e8"></a>DBID_MHP_MPE&#160;</td><td class="fielddoc"><p>Reserved for MHP Multi Protocol Encapsulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593accc56d195853b5abbf89cff2ce7ade16"></a>DBID_EUTELSAT_DATA_PIPE&#160;</td><td class="fielddoc"><p>Eutelsat Data Piping. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a31ca12594fb27f27b7380e431b41f780"></a>DBID_EUTELSAT_DATA_STREAM&#160;</td><td class="fielddoc"><p>Eutelsat Data Streaming. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a59b33466f7b38189e3314f5c36f266a5"></a>DBID_SAGEM_IP&#160;</td><td class="fielddoc"><p>SAGEM IP encapsulation in MPEG-2 PES packets. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a0dd75ef2f7acdf8d5bbc5d1cdde8c881"></a>DBID_BARCO_DATA_BRD&#160;</td><td class="fielddoc"><p>BARCO Data Broadcasting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a82b4aef63934dff2c1fdc06fbe23aea7"></a>DBID_CIBERCITY_MPE&#160;</td><td class="fielddoc"><p>CyberCity Multiprotocol Encapsulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a0437f4faad02fb77dd2b448d5daeb0c4"></a>DBID_CYBERSAT_MPE&#160;</td><td class="fielddoc"><p>CyberSat Multiprotocol Encapsulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a7dd399d26567d830e9f07bc5c636672e"></a>DBID_TDN&#160;</td><td class="fielddoc"><p>The Digital Network. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593afca579ec0e91401b12c2a519a468de74"></a>DBID_OPENTV_DATA_CSL&#160;</td><td class="fielddoc"><p>OpenTV Data Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a54916b1110748ecf821c16a05045feaa"></a>DBID_PANASONIC&#160;</td><td class="fielddoc"><p>Panasonic. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a43e0e983e3fd60a45cabc888324ebdc0"></a>DBID_KABEL_DEUTSCHLAND&#160;</td><td class="fielddoc"><p>Kabel Deutschland. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a440fffe954dcb6170e7e689793620cfb"></a>DBID_TECHNOTREND&#160;</td><td class="fielddoc"><p>TechnoTrend Gorler GmbH. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593ab3f83c06663dc1343593f11ce72f5753"></a>DBID_MEDIAHIGHWAY_SSU&#160;</td><td class="fielddoc"><p>NDS France Technologies system software download. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a4599d719117300f363db64a26767b174"></a>DBID_GUIDE_PLUS&#160;</td><td class="fielddoc"><p>GUIDE Plus+ Rovi Corporation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a3b503c60c8d12691e68ebf8e223661ea"></a>DBID_ACAP_OBJECT_CSL&#160;</td><td class="fielddoc"><p>ACAP <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593aa2df52439d3069a905a1151acdb1c6f0"></a>DBID_MICRONAS&#160;</td><td class="fielddoc"><p>Micronas Download Stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a584717d2c80ab6d7e6bdb00df561d889"></a>DBID_POLSAT&#160;</td><td class="fielddoc"><p>Televizja Polsat. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a83033c28ce1b1eb77d9939a60b3a012c"></a>DBID_DTG&#160;</td><td class="fielddoc"><p>UK DTG. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a711a931e1360897f5c912cd3fa9665d7"></a>DBID_SKYMEDIA&#160;</td><td class="fielddoc"><p>SkyMedia. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a1a3f0449a12ddbe4a18b89b8016b7884"></a>DBID_INTELLIBYTE&#160;</td><td class="fielddoc"><p>Intellibyte DataBroadcasting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a59ff22ab360f9995df498afdadbada2b"></a>DBID_TELEWEB_DATA_CSL&#160;</td><td class="fielddoc"><p>TeleWeb Data Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a15d490344912deab3dd83897548d589a"></a>DBID_TELEWEB_OBJECT_CSL&#160;</td><td class="fielddoc"><p>TeleWeb <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593aed3a7671e9722881b76e6fe211b8ee31"></a>DBID_TELEWEB&#160;</td><td class="fielddoc"><p>TeleWeb. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a98157cdfc6e2f1ea9e751219e32c543a"></a>DBID_BBC&#160;</td><td class="fielddoc"><p>BBC. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593aa9d610022adcfe725a1428b2e38ea7dd"></a>DBID_ELECTRA&#160;</td><td class="fielddoc"><p>Electra Entertainment Ltd. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a0037fdd0843f548f9c7082615ddca19f"></a>DBID_BBC_2_3&#160;</td><td class="fielddoc"><p>BBC 2 - 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a6d523bb0eca72dafd66e619f731f0883"></a>DBID_TELETEXT&#160;</td><td class="fielddoc"><p>Teletext. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a59f246b8808845dda6c3d71b1d059630"></a>DBID_SKY_DOWNLOAD_1_5&#160;</td><td class="fielddoc"><p>Sky Download Streams 1-5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a7c83af778ad957fd71022cd7d0f3e862"></a>DBID_ICO&#160;</td><td class="fielddoc"><p>ICO mim. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593afeee380154bc20a319f2880d67db5c96"></a>DBID_CIPLUS_DATA_CSL&#160;</td><td class="fielddoc"><p>CI+ Data Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a3405658e49464fdcce06972d52ecb26d"></a>DBID_HBBTV&#160;</td><td class="fielddoc"><p>HBBTV Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a01d7fae99c9336e582fbfb289ceb5157"></a>DBID_ROVI_PREMIUM&#160;</td><td class="fielddoc"><p>Premium Content from Rovi Corporation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a079d83fe51b6583ceab60f913a9e8c91"></a>DBID_MEDIA_GUIDE&#160;</td><td class="fielddoc"><p>Media Guide from Rovi Corporation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a59d7346e745f824308d433559e6e4f61"></a>DBID_INVIEW&#160;</td><td class="fielddoc"><p>InView Technology Ltd. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593acc92d2c4dd5d3559a62f90ab154a7b79"></a>DBID_BOTECH&#160;</td><td class="fielddoc"><p>Botech Elektronik SAN. ve TIC. LTD.STI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a7f5fa6551086bc48fe5780f4967bc706"></a>DBID_SCILLA_PUSHVOD_CSL&#160;</td><td class="fielddoc"><p>Scilla Push-VOD Carousel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a8c9c3f6ec6bc5e81db62f2895e934e2b"></a>DBID_CANAL_PLUS&#160;</td><td class="fielddoc"><p>Canal+. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a6b50db71be608bd959bd7fa3018cf672"></a>DBID_OIPF_OBJECT_CSL&#160;</td><td class="fielddoc"><p>OIPF <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Carousel - Open IPTV Forum. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a124d61536e3fcc9649febc1afa691eeb"></a>DBID_4TV&#160;</td><td class="fielddoc"><p>4TV Data Broadcast </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a0735d78b67aafbe7a1c7fd2a29bc40e4"></a>DBID_NOKIA_IP_SSU&#160;</td><td class="fielddoc"><p>Nokia IP based software delivery. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593a899fac929d3280afe18f2e5649366e23"></a>DBID_BBG_DATA_CSL&#160;</td><td class="fielddoc"><p>BBG Data Caroussel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593ae1fe2058832182955710d87c4c00e0b7"></a>DBID_BBG_OBJECT_CSL&#160;</td><td class="fielddoc"><p>BBG <a class="el" href="classts_1_1_object.html" title="Abstract base class for objects which can be stored in a repository. ">Object</a> Caroussel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3b474791d0063369fb7eb5b3c5d9593abda049b64ab0fdf45a61fd4a2282f523"></a>DBID_BBG&#160;</td><td class="fielddoc"><p>Bertelsmann Broadband Group. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0071f2918a8c95ab8f3c188250ce2b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0071f2918a8c95ab8f3c188250ce2b7f">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DVB-assigned Bouquet Identifier values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0071f2918a8c95ab8f3c188250ce2b7faa2d1bf81289ee39f5819366aa003775e"></a>BID_TVNUMERIC&#160;</td><td class="fielddoc"><p>Bouquet id for TV Numeric on French TNT network. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0071f2918a8c95ab8f3c188250ce2b7fa3e5052a523c8b6a8bea580345275540b"></a>BID_TVNUMERIC_EUTELSAT&#160;</td><td class="fielddoc"><p>Bouquet id for TV Numeric on Eutelsat network. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0071f2918a8c95ab8f3c188250ce2b7fab2f1ecd8398a5712afd7d79d08f767a0"></a>BID_TVNUMERIC_ASTRA&#160;</td><td class="fielddoc"><p>Bouquet id for TV Numeric on Astra network. </p>
</td></tr>
</table>

</div>
</div>
<a id="a443b2a4f497204a667fde32be9d72277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443b2a4f497204a667fde32be9d72277">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DVB-assigned CA System Identifier values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a1183fa7863df85531cc8c790879136cd"></a>CASID_MEDIAGUARD_MIN&#160;</td><td class="fielddoc"><p>Minimum CAS Id value for MediaGuard. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a21faff0f81464fe7ffc1f23920531f1b"></a>CASID_MEDIAGUARD_MAX&#160;</td><td class="fielddoc"><p>Maximum CAS Id value for MediaGuard. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277aaa77af9e1d2faa3a57d1de963cf9f223"></a>CASID_VIACCESS_MIN&#160;</td><td class="fielddoc"><p>Minimum CAS Id value for Viaccess. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a2872c4929c4ec4a21f7367f8921ada9e"></a>CASID_VIACCESS_MAX&#160;</td><td class="fielddoc"><p>Maximum CAS Id value for Viaccess. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a6956ef8e23a09136b637dff9f5a6ede9"></a>CASID_NAGRA_MIN&#160;</td><td class="fielddoc"><p>Minimum CAS Id value for Nagravision. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277aaf747ad50c2a7ac79e63a8c6b89ddc83"></a>CASID_NAGRA_MAX&#160;</td><td class="fielddoc"><p>Maximum CAS Id value for Nagravision. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a57ff1d43b05d798784bde8aa9e376864"></a>CASID_THALESCRYPT_MIN&#160;</td><td class="fielddoc"><p>Minimum CAS Id value for ThalesCrypt. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277af5f401cd0482559575e806016d835008"></a>CASID_THALESCRYPT_MAX&#160;</td><td class="fielddoc"><p>Maximum CAS Id value for ThalesCrypt. </p>
</td></tr>
<tr><td class="fieldname"><a id="a443b2a4f497204a667fde32be9d72277a581c463569cc256c895ffd5209d9c059"></a>CASID_SAFEACCESS&#160;</td><td class="fielddoc"><p>CAS Id value for SafeAccess. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac7e055e7ef7b6e3e2d04a2744b2142cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e055e7ef7b6e3e2d04a2744b2142cf">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DVB-assigned Network Identifier values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7e055e7ef7b6e3e2d04a2744b2142cfa00aaa8dbcc42db0c145597826f6455e6"></a>NID_TNT_FRANCE&#160;</td><td class="fielddoc"><p>Network id for the French national terrestrial network. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab4503aa2186893e4d94ff9d8da88d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4503aa2186893e4d94ff9d8da88d178">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IEEE-assigned Organizationally Unique Identifier (OUI) values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab4503aa2186893e4d94ff9d8da88d178aa85e5b790ab8964d0073b3c6ab0873a3"></a>OUI_DVB&#160;</td><td class="fielddoc"><p>OUI for Digital Video Broadcasting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab4503aa2186893e4d94ff9d8da88d178ac26d4d80924b3fd601e80125e942a686"></a>OUI_SKARDIN&#160;</td><td class="fielddoc"><p>OUI for Skardin (UK) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab4503aa2186893e4d94ff9d8da88d178a8784c141e8c5ba924a3b8905b79d7dea"></a>OUI_LOGIWAYS&#160;</td><td class="fielddoc"><p>OUI for Logiways. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2d3fc0fa119551548f2550c83ca68e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3fc0fa119551548f2550c83ca68e47">&#9670;&nbsp;</a></span>CopyShare</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47">ts::CopyShare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> type used to indicate if the data referenced by a pointer shall be copied or shared. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2d3fc0fa119551548f2550c83ca68e47a5083b3f9b5f22506be23ec56cc217b7a"></a>COPY&#160;</td><td class="fielddoc"><p>Data shall be copied. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d3fc0fa119551548f2550c83ca68e47a278c7050331579ffce6ee95b6157f5f9"></a>SHARE&#160;</td><td class="fielddoc"><p>Data shall be shared. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3b76963ba3c3e6d12b29fc10bd4642fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b76963ba3c3e6d12b29fc10bd4642fa">&#9670;&nbsp;</a></span>VersionFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa">ts::VersionFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of version formatting, for predefined option &ndash;version. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faaba95baa6c3dc575f82d5ced4879619d7"></a>VERSION_SHORT&#160;</td><td class="fielddoc"><p>Short format X.Y-R. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faacc4a4738370590fc3b4b29e660bdb518"></a>VERSION_GLOBAL&#160;</td><td class="fielddoc"><p>Short format X.Y-R with highest revision number of all TSDuck files. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faa9ca9a7309972b9095446810f08664ccc"></a>VERSION_LONG&#160;</td><td class="fielddoc"><p>Full explanatory format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faa7c8baaececaedc8e028bea2f04926e68"></a>VERSION_DATE&#160;</td><td class="fielddoc"><p>Build date. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faae14179522627d36a7ace0c4cb4be8c8d"></a>VERSION_NSIS&#160;</td><td class="fielddoc"><p>Output an NSIS <code>!define</code> directive. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faaf20bd58a733e0b559edac6ea4fe88b2a"></a>VERSION_DEKTEC&#160;</td><td class="fielddoc"><p>Version of embedded Dektec DTAPI and detected Dektec drivers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b76963ba3c3e6d12b29fc10bd4642faa1beccd6420073a2a8eae48f62ce86341"></a>VERSION_FILES&#160;</td><td class="fielddoc"><p>Complete list of all TSDuck files with revision. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab34e77074819f7f75377d48b113d360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34e77074819f7f75377d48b113d360a">&#9670;&nbsp;</a></span>DirectShowPinFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacets.html#ab34e77074819f7f75377d48b113d360a">ts::DirectShowPinFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for DirectShow filter pin selections (Windows-specific). </p>
<p>Bit masks allowed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aaf35b094d7ef7a5f8c390c6b2e47f7c09"></a>xPIN_CONNECTED&#160;</td><td class="fielddoc"><p>Filter connected pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aa3b40c92e209b6b5ac947086ed7d09915"></a>xPIN_UNCONNECTED&#160;</td><td class="fielddoc"><p>Filter unconnected pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aa3135226c9bfca03d7ac531c5c340d388"></a>xPIN_INPUT&#160;</td><td class="fielddoc"><p>Filter input pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aa2fdfc924a62c3d95e5e187eb0e83ca21"></a>xPIN_OUTPUT&#160;</td><td class="fielddoc"><p>Filter output pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aaeca568fbe551db05cab6c7898d31c742"></a>xPIN_ALL_INPUT&#160;</td><td class="fielddoc"><p>Filter all input pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aa579d2bf985ce9b0443607593b11b977b"></a>xPIN_ALL_OUTPUT&#160;</td><td class="fielddoc"><p>Filter all output pins. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab34e77074819f7f75377d48b113d360aa4f52982b3618751e40366e718ba92db4"></a>xPIN_ALL&#160;</td><td class="fielddoc"><p>Filter all pins. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae0c0c67e025cd6ee1b5a1d6839e12c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c0c67e025cd6ee1b5a1d6839e12c52">&#9670;&nbsp;</a></span>EnumerateCombinations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EnumerateCombinations </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all 'k'-elements combinations of a 'n'-elements set. </p>
<p>This function enumerates all possible sets of 'k' elements within a set of 'n' elements. For each combination, a user-supplied predicate is invoked. The signature of the predicate function should be equivalent to the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> p (<span class="keyword">const</span> std::set&lt;T&gt;&amp; combination);</div></div><!-- fragment --><p>The signature does not need to have <code>const</code>, but the function must not modify the set which is passed to it. The function returns true when the search for more combinations shall continue and false when the search shall prematurely stops.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the sets.</td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of unary predicate returning true or false from one set of elements of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The set of all values from which the combinations are built. The size of <em>values</em> is the 'n' in the sentence <em>"enumerate all 'k'-elements
combinations of a 'n'-elements set"</em>.</td></tr>
    <tr><td class="paramname">fixed</td><td>The set of fixed values which must be present in all combinations. To enumerate all possible combinations in <em>values</em>, use an empty set for <em>fixed</em>. If <em>fixed</em> is not empty, the <em>predicate</em> will be invoked only with combinations of <em>values</em> which contains all elements in <em>fixed</em>.</td></tr>
    <tr><td class="paramname">size</td><td>The size (number of elements) of the combinations to enumerate. This is the 'k' in the sentence <em>"enumerate all 'k'-elements combinations of
a 'n'-elements set"</em>.</td></tr>
    <tr><td class="paramname">predicate</td><td>The unary predicate to invoke for each possible combination of <em>size</em> elements in <em>values</em>. If <em>predicate</em> returns true, the search for more combination continues. When <em>predicate</em> returns false, the search is interrupted immediately and no more combination is proposed. Example: When the application searches for a combination which matches specific properties, the application's predicate returns false when a matching combination is found to avoid looking for additional combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all combinations were searched and false if the search was interrupted because <em>predicate</em> returned false at some point. </dd></dl>

</div>
</div>
<a id="a6f2839cd69668c7102e1757131e1c6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2839cd69668c7102e1757131e1c6e5">&#9670;&nbsp;</a></span>AppendUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ELEMENT , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::AppendUnique </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ELEMENT &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an element into a container if not already present in the container. </p>
<p>If the element <em>e</em> is not already present in the <em>container</em>, <em>e</em> is appended at the end of the <em>container</em>. Otherwise, the <em>container</em> is left unmodified.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEMENT</td><td>Any type. </td></tr>
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>ELEMENT</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <code>ELEMENT</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>An element to conditionally append to <em>container</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>e</em> was appended in the container, false if it was already present. </dd></dl>

</div>
</div>
<a id="a86b3dfedaa899b7a41e7c65b40bf39d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b3dfedaa899b7a41e7c65b40bf39d2">&#9670;&nbsp;</a></span>DecodeBCD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ts::DecodeBCD </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the decimal value of a Binary Coded Decimal (BCD) encoded byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A byte containing a BCD-encoded value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded value in the range 0 to 99. </dd></dl>

</div>
</div>
<a id="aa71d9ebe7b3844665f2d9c236188ad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d9ebe7b3844665f2d9c236188ad68">&#9670;&nbsp;</a></span>EncodeBCD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ts::EncodeBCD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a one-byte Binary Coded Decimal (BCD) representation of an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The integer to encode (must be in 0..99). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One byte containing the BCD-encoded value of <em>i</em>. </dd></dl>

</div>
</div>
<a id="a4b3b811606a75a6ce077fa6edd3504e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3b811606a75a6ce077fa6edd3504e5">&#9670;&nbsp;</a></span>DecodeBCD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::DecodeBCD </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bcd_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the decimal value of a Binary Coded Decimal (BCD) encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bcd</td><td>Address of an array of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcd_count</td><td>Number of BCD digits (<em>bcd_count</em> / 2 bytes). Note that <em>bcd_count</em> can be even. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded integer value. </dd></dl>

</div>
</div>
<a id="a0ace6ccbb276bb1cd485e692eab3fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ace6ccbb276bb1cd485e692eab3fc11">&#9670;&nbsp;</a></span>BCDToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::BCDToString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bcd_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string representation of a variable-length Binary Coded Decimal (BCD) encoded integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>Returned string representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcd</td><td>Address of an array of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcd_count</td><td>Number of BCD digits (<em>bcd_count</em> / 2 bytes). Note that <em>bcd_count</em> can be even. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decimal</td><td>Indicates the position of the virtual decimal point (-1: none, 0: before first digit, 1: after first digit, etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28b73dac0d0e1108e1acc38354a1d3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b73dac0d0e1108e1acc38354a1d3c1">&#9670;&nbsp;</a></span>CASFamilyOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1de171688c3a6ff71896a8f3e5817c11">CASFamily</a> ts::CASFamilyOf </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ca_system_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a CAS family from a CA system id. </p>
<p>Useful to analyze CA descriptors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ca_system_id</td><td>DVB-allocated CA system id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CAS family enumeration value. </dd></dl>

</div>
</div>
<a id="a8b687ea0feac92c5c08f3d006c28cce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b687ea0feac92c5c08f3d006c28cce3">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::operator== </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_c_r_c32.html">CRC32</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance and a 32-bit integer. </p>
<p>The reversed form of operators is a member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>A <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c2</td><td>A <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> are identical, false otherwise. </dd></dl>

</div>
</div>
<a id="acc8837ea36e9e2a5555db18d880d660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8837ea36e9e2a5555db18d880d660f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::operator!= </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_c_r_c32.html">CRC32</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance and a 32-bit integer. </p>
<p>The reversed form of operators is a member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>A <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c2</td><td>A <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> instance to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two <a class="el" href="classts_1_1_c_r_c32.html" title="Cyclic Redundancy Check as used in MPEG sections. ">CRC32</a> are different, false otherwise. </dd></dl>

</div>
</div>
<a id="a889077d129ec53aafeb88d066f016d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889077d129ec53aafeb88d066f016d7a">&#9670;&nbsp;</a></span>Decimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Decimal </td>
          <td>(</td>
          <td class="paramtype">const INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_justified</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_sign</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string containing a decimal value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer value to format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_width</td><td>Minimum width of the returned string. Padded with spaces if larger than the number of characters in the formatted number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_justified</td><td>If true (the default), return a right-justified string. When false, return a left-justified string. Ignored if <em>min_width</em> is lower than the number of characters in the formatted number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Separator string for groups of thousands, a comma by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force_sign</td><td>If true, force a '+' sign for positive values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. </dd></dl>

</div>
</div>
<a id="ae10322711d0b7969007f6fdad31e38b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10322711d0b7969007f6fdad31e38b6">&#9670;&nbsp;</a></span>GetDektecVersions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::GetDektecVersions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the versions of Dektec API and drivers. </p>
<dl class="section return"><dt>Returns</dt><dd>A string describing the Dektec versions (or the lack of Dektec support). </dd></dl>

</div>
</div>
<a id="a026d43091fa662ad1d16b323994a77e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026d43091fa662ad1d16b323994a77e5">&#9670;&nbsp;</a></span>FatalError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::FatalError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle a fatal error. </p>
<p>An emergency message is output and the application is terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Address of an emergency error message to output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of <em>message</em>. The caller must specify <em>length</em> in a static way. In that kind of fatal error, we can't even dare to call strlen(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a440dc142daf576dd4c291aa41ccb23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440dc142daf576dd4c291aa41ccb23ef">&#9670;&nbsp;</a></span>FatalMemoryAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::FatalMemoryAllocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle fatal memory allocation failure. </p>
<p>Out of virtual memory, very dangerous situation, really can't recover from that, need to abort immediately. An emergency error message is output and the application is terminated. </p>

</div>
</div>
<a id="aaefacebb545891e8e34e3532f9009c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefacebb545891e8e34e3532f9009c94">&#9670;&nbsp;</a></span>CheckNonNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::CheckNonNull </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the value of a pointer and abort the application when zero. </p>
<p>This function is typically after a new. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets.html#a440dc142daf576dd4c291aa41ccb23ef" title="Handle fatal memory allocation failure. ">FatalMemoryAllocation()</a> </dd></dl>

</div>
</div>
<a id="a3b9496a30d57f3184cf57739acd04c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9496a30d57f3184cf57739acd04c12">&#9670;&nbsp;</a></span>GetFileNameRates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::GetFileNameRates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#aa62844508c6ce5b912390af83157c7eb">FileNameRateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_args.html">Args</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option_name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td>
          <td class="paramname"><em>default_rate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a list of parameters containing a list of file names with optional repetition rates in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">files</td><td>Returned vector or <a class="el" href="structts_1_1_file_name_rate.html" title="Representation of a file name and an associated repetition rate. ">FileNameRate</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">args</td><td>Instance of <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a> containing the command line parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option_name</td><td>The long name of an option. All values of this option are fetched. Each value must be a string "name[=value]" where <em>value</em> is an optional repetition rate in milliseconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_rate</td><td>Default repetition rate for files without repetition rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. On error, set error state in <em>args</em> and return false. </dd></dl>

</div>
</div>
<a id="a3a20c24ed1bf1ead37597f9ffb95ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a20c24ed1bf1ead37597f9ffb95ddb7">&#9670;&nbsp;</a></span>Format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a string using a printf-like format. </p>
<p>This function has the same profile as <code>printf()</code>. The <em>format</em> argument is followed by a variable-length list of arguments for the format string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A C-string containing a printf-like format. Refer to the documentation of <code>vsnprintf()</code> on the target platform for the complete syntax of the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the result of the formatting. </dd></dl>

</div>
</div>
<a id="a518c3129e643fa3c679f061fcfcf271f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518c3129e643fa3c679f061fcfcf271f">&#9670;&nbsp;</a></span>Hexa() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Hexa </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Starting address of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6ad7ef6d80730180cbdfcf918c83b1ce78">ts::hexa::BPL</a> is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6a772aba2940945daf456102973aef3878">ts::hexa::OFFSET</a> is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the formatted hexadecimal dump. Lines are separated with embedded new-line characters ('\n'). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a> </dd></dl>

</div>
</div>
<a id="a53f40d1dde25f4d00aaf466483bf334f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f40d1dde25f4d00aaf466483bf334f">&#9670;&nbsp;</a></span>Hexa() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Hexa </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6ad7ef6d80730180cbdfcf918c83b1ce78">ts::hexa::BPL</a> is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6a772aba2940945daf456102973aef3878">ts::hexa::OFFSET</a> is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the formatted hexadecimal dump. Lines are separated with embedded new-line characters ('\n'). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a> </dd></dl>

</div>
</div>
<a id="a87da430dda0a1f7b381eabba762d48da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87da430dda0a1f7b381eabba762d48da">&#9670;&nbsp;</a></span>Hexa() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Hexa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bb</td><td>Byte block to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6ad7ef6d80730180cbdfcf918c83b1ce78">ts::hexa::BPL</a> is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6a772aba2940945daf456102973aef3878">ts::hexa::OFFSET</a> is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the formatted hexadecimal dump. Lines are separated with embedded new-line characters ('\n'). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a> </dd></dl>

</div>
</div>
<a id="a8e5760f774441c48a9c5f8138b0f2fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5760f774441c48a9c5f8138b0f2fdb">&#9670;&nbsp;</a></span>AppendHexa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::AppendHexa </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6aad5f43306863dc44384c71053cbe3036">hexa::HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="namespacets_1_1hexa.html#a050606272cf6b103a06890be6325a576">hexa::DEFAULT_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>A string object. The formatted hexa string is appended to this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Starting address of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6ad7ef6d80730180cbdfcf918c83b1ce78">ts::hexa::BPL</a> is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag <a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6a772aba2940945daf456102973aef3878">ts::hexa::OFFSET</a> is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>str</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets_1_1hexa.html#a490e158f46bf3d8b610cd81e9d6290e6" title="Flags for the ts::Hexa() family of functions. ">ts::hexa::Flags</a> </dd></dl>

</div>
</div>
<a id="a65a65372e92a780aa7ed79802c41c6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a65372e92a780aa7ed79802c41c6ab">&#9670;&nbsp;</a></span>BoundedAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">INT ts::BoundedAdd </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a bounded addition without overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <em>a</em> + <em>b</em>. The value is <em>bounded</em>, in case of underflow or overflow, the result is the min or max value of the type, respectively. </dd></dl>

</div>
</div>
<a id="afcd38176df8cc88d81af7f93f0821995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd38176df8cc88d81af7f93f0821995">&#9670;&nbsp;</a></span>BoundedSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">INT ts::BoundedSub </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a bounded subtraction without overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <em>a</em> - <em>b</em>. The value is <em>bounded</em>, in case of underflow or overflow, the result is the min or max value of the type, respectively. </dd></dl>

</div>
</div>
<a id="a9301b5fe5b626fcde7937191ddcf0a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9301b5fe5b626fcde7937191ddcf0a79">&#9670;&nbsp;</a></span>RoundDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::RoundDown </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <em>x</em> down to previous multiple of a factor <em>f</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <em>x</em> rounded down to previous multiple of <em>f</em>. </dd></dl>

</div>
</div>
<a id="ac059d29061522705dfad72fa6b6b8fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac059d29061522705dfad72fa6b6b8fa1">&#9670;&nbsp;</a></span>RoundUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::RoundUp </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round <em>x</em> up to next multiple of a factor <em>f</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <em>x</em> rounded up to next multiple of <em>f</em>. </dd></dl>

</div>
</div>
<a id="a8c295dd82cb73c63d7d728bdfca3f38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c295dd82cb73c63d7d728bdfca3f38d">&#9670;&nbsp;</a></span>MaxDecimalWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::MaxDecimalWidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>typeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>digitSeparatorSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum width of the decimal representation of an integer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeSize</td><td>Size of the integer type in bytes (result of <code>sizeof</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digitSeparatorSize</td><td>Size in characters of the digit-grouping separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum width in characters. </dd></dl>

</div>
</div>
<a id="a9ebd618d1519a261d2bd1a165abdaa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebd618d1519a261d2bd1a165abdaa1d">&#9670;&nbsp;</a></span>MaxHexaWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::MaxHexaWidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>typeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>digitSeparatorSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum width of the hexadecimal representation of an integer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeSize</td><td>Size of the integer type in bytes (result of <code>sizeof</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digitSeparatorSize</td><td>Size in characters of the digit-grouping separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum width in characters. </dd></dl>

</div>
</div>
<a id="aa92d4bead498ab54f7e99a780e1d1419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92d4bead498ab54f7e99a780e1d1419">&#9670;&nbsp;</a></span>PercentageString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::PercentageString </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a percentage string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An integer value, a portion of <em>total</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total</td><td>The total value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string reprenting the percentage of <em>value</em> in <em>total</em>. </dd></dl>

</div>
</div>
<a id="a4b2277992c53ededdc67aad35fb3e0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2277992c53ededdc67aad35fb3e0a2">&#9670;&nbsp;</a></span>IPInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IPInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"> = <code>(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the IP libraries in the current process. </p>
<p>On some systems (UNIX), there is no need to initialize IP. On other systems (Windows), using IP and socket without initialization fails. This method is a portable way to ensure that IP is properly initialized. It shall be called at least once before using IP in the application.</p>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a2268d9defcbb4b19c04791493a616ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2268d9defcbb4b19c04791493a616ad5">&#9670;&nbsp;</a></span>LastSocketErrorCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a5346c902c2c02fd7fdf27ecbd67e0d7e">SocketErrorCode</a> ts::LastSocketErrorCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the error code of the last socket system call. </p>
<p>The validity of the returned value may depends on specific conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>The error code of the last socket system call. </dd></dl>

</div>
</div>
<a id="a3fa865450711be59bc301cdb10982373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa865450711be59bc301cdb10982373">&#9670;&nbsp;</a></span>SocketErrorCodeMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::SocketErrorCodeMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a5346c902c2c02fd7fdf27ecbd67e0d7e">SocketErrorCode</a>&#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="namespacets.html#a2268d9defcbb4b19c04791493a616ad5">LastSocketErrorCode</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a socket error code into a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>An error code from the operating system. Typically a result from <a class="el" href="namespacets.html#a2268d9defcbb4b19c04791493a616ad5" title="Get the error code of the last socket system call. ">LastSocketErrorCode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error. </dd></dl>

</div>
</div>
<a id="a64242ae941b3b1a93dccb53ef5ea2582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64242ae941b3b1a93dccb53ef5ea2582">&#9670;&nbsp;</a></span>GetLocalIPAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::GetLocalIPAddresses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a6825a1db0e62afdf5e6ccb895a28c020">IPAddressVector</a> &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em> = <code>(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of all local IPv4 addresses in the system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">addresses</td><td>A vector of IpAddress which receives the list of all local IPv4 addresses in the system, except <a class="el" href="classts_1_1_i_p_address.html#ab5bcdcc7f5b401cf1be8f17d51935994">ts::IPAddress::LocalHost</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="ad781da44b42d0a87b25127108d9fe5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad781da44b42d0a87b25127108d9fe5fa">&#9670;&nbsp;</a></span>IsLocalIPAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsLocalIPAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_i_p_address.html">IPAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a local system interface has a specified IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is <em>address</em> is the address of a local system interface, false otherwise. </dd></dl>

</div>
</div>
<a id="a4e14fcda16e3d54676261db8d3a77953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e14fcda16e3d54676261db8d3a77953">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::Zero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zeroing a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>Address of a memory area to fill with zeroes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the memory area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ed6b39ed58cb2b9fa6e33e1b8626a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed6b39ed58cb2b9fa6e33e1b8626a4b">&#9670;&nbsp;</a></span>StartsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::StartsWith </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>area_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prefix_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a memory area starts with the specified prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Address of a memory area to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">area_size</td><td>Size in bytes of the memory area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Address of the content of the prefix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_size</td><td>Size in bytes of the prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>area</em> starts with <em>prefix</em>. </dd></dl>

</div>
</div>
<a id="a41d108b4eca6c486c304a6557daee280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d108b4eca6c486c304a6557daee280">&#9670;&nbsp;</a></span>LocatePattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* ts::LocatePattern </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>area_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pattern_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a pattern into a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Address of a memory area to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">area_size</td><td>Size in bytes of the memory area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Address of the content of the pattern to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern_size</td><td>Size in bytes of the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the first occurence of <em>pattern</em> in <em>area</em> or zero if not found. </dd></dl>

</div>
</div>
<a id="a825344141ed756c464e741feafbf826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825344141ed756c464e741feafbf826c">&#9670;&nbsp;</a></span>DecodeMJD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::DecodeMJD </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mjd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mjd_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Modified Julian Date (MJD) into a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">ts::Time</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mjd</td><td>Address of a 2-to-5 bytes area, in the format specified by a <a class="el" href="classts_1_1_t_d_t.html" title="Representation of a Time &amp; Date Table (TDT) ">TDT</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mjd_size</td><td>Size in bytes of the <em>mjd</em> area. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time</td><td>Return time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false in case of error. </dd></dl>

</div>
</div>
<a id="a80fc214dd82608d324ad17bd751ac2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fc214dd82608d324ad17bd751ac2ad">&#9670;&nbsp;</a></span>EncodeMJD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EncodeMJD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_time.html">Time</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mjd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mjd_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">ts::Time</a> into a Modified Julian Date (MJD). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Input time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mjd</td><td>Address of a writeable 2-to-5 bytes area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mjd_size</td><td>Size in bytes of the <em>mjd</em> area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false in case of error. </dd></dl>

</div>
</div>
<a id="a156abf4673a5c590de73bbd6f488762c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156abf4673a5c590de73bbd6f488762c">&#9670;&nbsp;</a></span>CheckModEnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::CheckModEnum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an enumeration value is supported by the native implementation. </p>
<p>The file <a class="el" href="ts_modulation_8h.html">tsModulation.h</a> declares several enumeration types relating to modulation features. Whenever possible, all enumerations have identical integer values as their counterparts in the Linux DVB or Windows DirectShow API for faster conversion. When an enum cannot be mapped to a native value (because the feature is not supported by the operating system), a "very negative" value is used. Very negative means "-10 or less" since these values are never used by an implementation.</p>
<p>This function checks that an enumeration value is supported by the native implementation. If it is not, report an error message and return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <code>int</code> value of an enumeration value from on the enumeration types in file <a class="el" href="ts_modulation_8h.html">tsModulation.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the feature or enumeration type (eg. "FEC", "guard interval", etc.) Used to report errors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conv</td><td>The <a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">ts::Enumeration</a> instance for the enumeration type. Used to report errors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>value</em> is supported on the operating system. False if the feature is not supported. In this case, an error message is reported to <em>report</em>. </dd></dl>

</div>
</div>
<a id="ad228da89510018c994467ef6df2058d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad228da89510018c994467ef6df2058d5">&#9670;&nbsp;</a></span>BitsPerSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::BitsPerSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ae4e82c198bc4395f3dc9368516da5b58">Modulation</a>&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bits per symbol for a specified modulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Modulation type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits per symbol or zero if unknown. </dd></dl>

</div>
</div>
<a id="a56b7a0dc5023472f5928cbaed6780e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b7a0dc5023472f5928cbaed6780e77">&#9670;&nbsp;</a></span>FECMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::FECMultiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">InnerFEC</a>&#160;</td>
          <td class="paramname"><em>fec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the multiplier of a FEC value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fec</td><td>Inner FEC value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multiplier (eg. 9 for FEC_9_10) or zero if unknown. </dd></dl>

</div>
</div>
<a id="aed8a0c64adb713a2917de5cb2711ed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8a0c64adb713a2917de5cb2711ed91">&#9670;&nbsp;</a></span>FECDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::FECDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#aba02cdc67c6160675835a56352ee020e">InnerFEC</a>&#160;</td>
          <td class="paramname"><em>fec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the divider of a FEC value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fec</td><td>Inner FEC value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divider (eg. 10 for FEC_9_10) or zero if unknown. </dd></dl>

</div>
</div>
<a id="ab37a7bf7b228d4590928b32c6873cda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37a7bf7b228d4590928b32c6873cda8">&#9670;&nbsp;</a></span>BandWidthValueHz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::BandWidthValueHz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">BandWidth</a>&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bandwidth value in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bw</td><td>Bandwidth enumeration value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bandwidth in Hz or zero if unknown. </dd></dl>

</div>
</div>
<a id="afa8a052d6addf8a3d5d796113412763b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a052d6addf8a3d5d796113412763b">&#9670;&nbsp;</a></span>BandWidthCodeFromHz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a14bb51c4b1573092910ab6fdec459e31">BandWidth</a> ts::BandWidthCodeFromHz </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bandwidth code from a value in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hz</td><td>Bandwidth in Hz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bandwidth enumeration value or BW_AUTO if undefined. </dd></dl>

</div>
</div>
<a id="aa84c96c83e1ba8c8190aaadaceb8c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c96c83e1ba8c8190aaadaceb8c298">&#9670;&nbsp;</a></span>GuardIntervalMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GuardIntervalMultiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">GuardInterval</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the multiplier of a guard interval value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multiplier (eg. 1 for GUARD_1_16) or zero if unknown. </dd></dl>

</div>
</div>
<a id="a39d6e6634b1f01dec5973105da80a7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d6e6634b1f01dec5973105da80a7b5">&#9670;&nbsp;</a></span>GuardIntervalDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GuardIntervalDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a244247a91af4595a95740ef778f85184">GuardInterval</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the divider of a guard interval value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td><a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">Guard</a> interval value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divider (eg. 16 for GUARD_1_16) or zero if unknown. </dd></dl>

</div>
</div>
<a id="a6dc5cded24e3c2859043129e1f66092b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc5cded24e3c2859043129e1f66092b">&#9670;&nbsp;</a></span>ToBitrate204()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> ts::ToBitrate204 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td>
          <td class="paramname"><em>bitrate188</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 188-byte packet bitrate into 204-byte packet bitrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitrate188</td><td>Bitrate using 188-byte packet as reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding bitrate using 204-byte packet as reference. </dd></dl>

</div>
</div>
<a id="afc0a50ad635fadd171e9c3552bd03a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0a50ad635fadd171e9c3552bd03a4d">&#9670;&nbsp;</a></span>ToBitrate188()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a> ts::ToBitrate188 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td>
          <td class="paramname"><em>bitrate204</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 204-byte packet bitrate into 188-byte packet bitrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitrate204</td><td>Bitrate using 204-byte packet as reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding bitrate using 188-byte packet as reference. </dd></dl>

</div>
</div>
<a id="ae7840cb2a5119860dc7e0757c3e71821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7840cb2a5119860dc7e0757c3e71821">&#9670;&nbsp;</a></span>PacketInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a> ts::PacketInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td>
          <td class="paramname"><em>bitrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interval, in milliseconds, between two packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitrate</td><td>TS bitrate in bits/second, based on 188-byte packets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Distance between the two packets: 0 for the same packet, 1 for the next packet (the default), etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval in milliseconds between the first byte of the first packet and the first byte of the second packet. </dd></dl>

</div>
</div>
<a id="ac3d740a7e88454fbd55f924d9cc2d9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d740a7e88454fbd55f924d9cc2d9f8">&#9670;&nbsp;</a></span>PacketDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a> ts::PacketDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ab979eee2ee2eef80c6f655146d4c3961">BitRate</a>&#160;</td>
          <td class="paramname"><em>bitrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of packets transmitted during a given duration in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitrate</td><td>TS bitrate in bits/second, based on 188-byte packets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>Number of milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets during <em>duration</em> milliseconds. </dd></dl>

</div>
</div>
<a id="a77da02aa4068409cbb3cf797de782021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77da02aa4068409cbb3cf797de782021">&#9670;&nbsp;</a></span>SectionPacketCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a9cdec7a120783847f53fbf71e5eb49f6">PacketCounter</a> ts::SectionPacketCount </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>section_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimum number of TS packets required to transport a section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_size</td><td>Total section size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets required for the section. </dd></dl>

</div>
</div>
<a id="a732dbdcd93f1b6cec64fe0496c76c5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732dbdcd93f1b6cec64fe0496c76c5ec">&#9670;&nbsp;</a></span>WrapUpPTS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::WrapUpPTS </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pts2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if PTS2 follows PTS1 after wrap up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pts1</td><td>First PTS. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pts2</td><td>Second PTS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is <em>pts2</em> is probably following <em>pts1</em> after wrapping up at 2**33. </dd></dl>

</div>
</div>
<a id="ab92b1ce1e3abaf6202b9415f58102b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92b1ce1e3abaf6202b9415f58102b56">&#9670;&nbsp;</a></span>SequencedPTS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SequencedPTS </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pts2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two Presentation <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">Time</a> Stamp are in sequence. </p>
<p>In MPEG video, B-frames are transported out-of-sequence. Their PTS is typically lower than the previous D-frame or I-frame in the transport. A "sequenced" PTS is one that is higher than the previous sequenced PTS (with possible wrap up). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pts1</td><td>First PTS. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pts2</td><td>Second PTS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is <em>pts2</em> is after <em>pts1</em>, possibly after wrapping up at 2**33. </dd></dl>

</div>
</div>
<a id="a4cc03c60ce8759943ed1ed873c30edfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc03c60ce8759943ed1ed873c30edfc">&#9670;&nbsp;</a></span>IsVideoSID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsVideoSID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a stream id value indicates a video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sid</td><td>Stream id as found in a PES header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>sid</em> indicates a video stream. </dd></dl>

</div>
</div>
<a id="a7b1689d90f2a19242bd4c659734971e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1689d90f2a19242bd4c659734971e2">&#9670;&nbsp;</a></span>IsAudioSID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsAudioSID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a stream id value indicates an audio stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sid</td><td>Stream id as found in a PES header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>sid</em> indicates an audio stream. </dd></dl>

</div>
</div>
<a id="ac67c718addb2facbf7dbb99fe0c38fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67c718addb2facbf7dbb99fe0c38fb7">&#9670;&nbsp;</a></span>IsLongHeaderSID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsLongHeaderSID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a stream id value indicates a PES packet with long header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sid</td><td>Stream id as found in a PES header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>sid</em> indicates a PES packet with long header. </dd></dl>

</div>
</div>
<a id="aa9b64d63b82990b3e2f0f2b637c35d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b64d63b82990b3e2f0f2b637c35d1c">&#9670;&nbsp;</a></span>IsPES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsPES </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an stream type value indicates a PES stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>Stream type as used in the <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>st</em> indicates a PES stream. </dd></dl>

</div>
</div>
<a id="af327ff80e50ad9fcd5b37b01ff002e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af327ff80e50ad9fcd5b37b01ff002e3c">&#9670;&nbsp;</a></span>IsVideoST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsVideoST </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an stream type value indicates a video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>Stream type as used in the <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>st</em> indicates a video stream. </dd></dl>

</div>
</div>
<a id="aad5d9524f27c4af27d49827e1a1e1a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5d9524f27c4af27d49827e1a1e1a77">&#9670;&nbsp;</a></span>IsAudioST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsAudioST </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an stream type value indicates an audio stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>Stream type as used in the <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>st</em> indicates an audio stream. </dd></dl>

</div>
</div>
<a id="ab3ce043219049a0ad153a92d9df2be6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ce043219049a0ad153a92d9df2be6f">&#9670;&nbsp;</a></span>IsSectionST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsSectionST </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an stream type value indicates a stream carrying sections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>Stream type as used in the <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">PMT</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>st</em> indicates a stream carrying sections. </dd></dl>

</div>
</div>
<a id="a1a99e4b44cc2663249707bc8c1b90b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a99e4b44cc2663249707bc8c1b90b24">&#9670;&nbsp;</a></span>GetPCR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::GetPCR </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine extracts a PCR from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Address of a 6-byte memory area containing a PCR binary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 42-bit PCR value. </dd></dl>

</div>
</div>
<a id="a56efbbc13dd286af2da95348d9f27f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56efbbc13dd286af2da95348d9f27f04">&#9670;&nbsp;</a></span>PutPCR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutPCR </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>pcr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine inserts a PCR in a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Address of a 6-byte memory area to write the PCR binary value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcr</td><td>A 42-bit PCR value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62efc57362e856920b2008d838583ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62efc57362e856920b2008d838583ea8">&#9670;&nbsp;</a></span>ByteSwap16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::ByteSwap16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing byte swap on 16-bit integer data. </p>
<p>This function unconditionally swaps bytes within an unsigned integer, regardless of the native endianness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 16-bit unsigned integer to swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>x</em> where bytes were swapped. </dd></dl>

</div>
</div>
<a id="a9b4e88f0624d9fc9fb36d2b8dea9d99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4e88f0624d9fc9fb36d2b8dea9d99c">&#9670;&nbsp;</a></span>ByteSwap24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::ByteSwap24 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing byte swap on 24-bit integer data. </p>
<p>This function unconditionally swaps bytes within an unsigned integer, regardless of the native endianness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer containing a 24-bit value to swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>x</em> where the three least significant bytes were swapped. </dd></dl>

</div>
</div>
<a id="a8c1516fddd435f2bd54085b3674ff6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1516fddd435f2bd54085b3674ff6fd">&#9670;&nbsp;</a></span>ByteSwap32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::ByteSwap32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing byte swap on 32-bit integer data. </p>
<p>This function unconditionally swaps bytes within an unsigned integer, regardless of the native endianness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer to swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>x</em> where bytes were swapped. </dd></dl>

</div>
</div>
<a id="ae133add30b41089dacbb1ffa4fc42656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae133add30b41089dacbb1ffa4fc42656">&#9670;&nbsp;</a></span>ByteSwap64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::ByteSwap64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing byte swap on 64-bit integer data. </p>
<p>This function unconditionally swaps bytes within an unsigned integer, regardless of the native endianness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 64-bit unsigned integer to swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>x</em> where bytes were swapped. </dd></dl>

</div>
</div>
<a id="a8b72cb6e05cd166c8346ee6bbbb6b4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b72cb6e05cd166c8346ee6bbbb6b4d8">&#9670;&nbsp;</a></span>CondByteSwap16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::CondByteSwap16BE </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 16-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a9cec3aee4ec20d0fea7c12d0d0e8347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cec3aee4ec20d0fea7c12d0d0e8347e">&#9670;&nbsp;</a></span>CondByteSwap16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::CondByteSwap16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 16-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a5b1daad980866e973aa0bcdd3991d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1daad980866e973aa0bcdd3991d47f">&#9670;&nbsp;</a></span>CondByteSwap24BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap24BE </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer containing a 24-bit value to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where the three least significant bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a98b2fbe7a2ee13195f725e96d51310cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b2fbe7a2ee13195f725e96d51310cb">&#9670;&nbsp;</a></span>CondByteSwap24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap24 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer containing a 24-bit value to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where the three least significant bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="afc7d797ee241bdfa65935663268a8cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7d797ee241bdfa65935663268a8cf4">&#9670;&nbsp;</a></span>CondByteSwap32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap32BE </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="acaf35fc29b505b8b31ae5f331e4e9979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf35fc29b505b8b31ae5f331e4e9979">&#9670;&nbsp;</a></span>CondByteSwap32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a3d4a858ba042ba9ff717978fee34209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4a858ba042ba9ff717978fee34209a">&#9670;&nbsp;</a></span>CondByteSwap64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::CondByteSwap64BE </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 64-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a3b6c20d76fd476e16a318b1b8445b40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6c20d76fd476e16a318b1b8445b40c">&#9670;&nbsp;</a></span>CondByteSwap64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::CondByteSwap64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 64-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a3baec140b94d96b53eed46b5461081e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baec140b94d96b53eed46b5461081e0">&#9670;&nbsp;</a></span>CondByteSwap16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::CondByteSwap16LE </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 16-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On big-endian platforms, return the value of <em>x</em> where bytes were swapped. On little-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a55d035c03d139c7ca220cbb318089ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d035c03d139c7ca220cbb318089ab7">&#9670;&nbsp;</a></span>CondByteSwap24LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap24LE </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer containing a 24-bit value to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On big-endian platforms, return the value of <em>x</em> where the three least significant bytes were swapped. On little-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a2d3d8873bb0120e283796079cdf3f5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3d8873bb0120e283796079cdf3f5f9">&#9670;&nbsp;</a></span>CondByteSwap32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::CondByteSwap32LE </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On big-endian platforms, return the value of <em>x</em> where bytes were swapped. On little-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a3ffa36c67fd7339fc5e0924c9f6b688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa36c67fd7339fc5e0924c9f6b688e">&#9670;&nbsp;</a></span>CondByteSwap64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::CondByteSwap64LE </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 64-bit unsigned integer to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On big-endian platforms, return the value of <em>x</em> where bytes were swapped. On little-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a5d6eea3582f5368a84f08aa6512942a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6eea3582f5368a84f08aa6512942a3">&#9670;&nbsp;</a></span>SignExtend24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::SignExtend24 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sign extension on 24 bit integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A 32-bit integer containing a signed 24-bit value to extend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer containing the signed 24-bit value with proper sign extension on 32-bits. </dd></dl>

</div>
</div>
<a id="a36e4b522c105fa6ee6706cb14bc1c77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e4b522c105fa6ee6706cb14bc1c77a">&#9670;&nbsp;</a></span>GetUInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ts::GetUInt8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting an 8-bit unsigned integer from serialized data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an 8-bit unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 8-bit unsigned integer at <em>p</em>. </dd></dl>

</div>
</div>
<a id="ac91ac45e9e2741fd64f495afb7dd5e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ac45e9e2741fd64f495afb7dd5e61">&#9670;&nbsp;</a></span>GetUInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::GetUInt16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="ae68fc76b965efdefafa9ec1742ffb834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68fc76b965efdefafa9ec1742ffb834">&#9670;&nbsp;</a></span>GetUInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a2c8afb0d642689f1ca2429d96e1eb9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8afb0d642689f1ca2429d96e1eb9e7">&#9670;&nbsp;</a></span>GetUInt24() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 24-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a34d8f836756fd5acb9ec38c0732fb15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d8f836756fd5acb9ec38c0732fb15b">&#9670;&nbsp;</a></span>GetUInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::GetUInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="ac90ccc17acabae9276cea7a69fe85cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90ccc17acabae9276cea7a69fe85cfc">&#9670;&nbsp;</a></span>GetUInt16BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::GetUInt16BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="ad11bde3bce4bc0cfae007433d280f239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11bde3bce4bc0cfae007433d280f239">&#9670;&nbsp;</a></span>GetUInt32BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt32BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a70882b518121c43cd47d258bbe0e7f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70882b518121c43cd47d258bbe0e7f01">&#9670;&nbsp;</a></span>GetUInt24BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt24BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 24-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a1c9bc167b8cc7b75ac8acfcf475a655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9bc167b8cc7b75ac8acfcf475a655d">&#9670;&nbsp;</a></span>GetUInt64BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::GetUInt64BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a4afd90bdfe6e1a70c534da4b2a0f1657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afd90bdfe6e1a70c534da4b2a0f1657">&#9670;&nbsp;</a></span>GetUInt16LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ts::GetUInt16LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="ad4a5525afda4d4444ec7fa91816f9cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a5525afda4d4444ec7fa91816f9cf9">&#9670;&nbsp;</a></span>GetUInt32LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt32LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a196e63036518e36c9aade78a0672757b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196e63036518e36c9aade78a0672757b">&#9670;&nbsp;</a></span>GetUInt24LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::GetUInt24LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 24-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a1ae6fc9b599b7a479b3b4c059e27e2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae6fc9b599b7a479b3b4c059e27e2b2">&#9670;&nbsp;</a></span>GetUInt64LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::GetUInt64LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="af67f53a8fcbddf0e3b5195d63f469bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67f53a8fcbddf0e3b5195d63f469bf5">&#9670;&nbsp;</a></span>GetInt8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t ts::GetInt8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting an 8-bit signed integer from serialized data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an 8-bit signed integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 8-bit signed integer at <em>p</em>. </dd></dl>

</div>
</div>
<a id="ae4b32ec99a2e227a7742865f27974b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b32ec99a2e227a7742865f27974b67">&#9670;&nbsp;</a></span>GetInt16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t ts::GetInt16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="aa6c27f13544400a9832dd9fe12425c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c27f13544400a9832dd9fe12425c2e">&#9670;&nbsp;</a></span>GetInt24() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 24-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a0b85f9ebc717a54509a44eb340b1352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b85f9ebc717a54509a44eb340b1352d">&#9670;&nbsp;</a></span>GetInt32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a56224321d92070fb07832659c23d553d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56224321d92070fb07832659c23d553d">&#9670;&nbsp;</a></span>GetInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ts::GetInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a6e0c99c5cd7dff8ec394e5515eae6357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0c99c5cd7dff8ec394e5515eae6357">&#9670;&nbsp;</a></span>GetInt16BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t ts::GetInt16BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a6ea6588c8736c18a436c561227d007ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea6588c8736c18a436c561227d007ba">&#9670;&nbsp;</a></span>GetInt24BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt24BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 24-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a9c67eafbbf4f7b06b2cba52a54359ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c67eafbbf4f7b06b2cba52a54359ab3">&#9670;&nbsp;</a></span>GetInt32BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt32BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="aee51ebfe80183472394a82a099b050a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee51ebfe80183472394a82a099b050a9">&#9670;&nbsp;</a></span>GetInt64BE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ts::GetInt64BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="abb588d1a13c75a5d5422ce40004b9c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb588d1a13c75a5d5422ce40004b9c22">&#9670;&nbsp;</a></span>GetInt16LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t ts::GetInt16LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a831c7bf60e2ae215cd33eb90f4ad644c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831c7bf60e2ae215cd33eb90f4ad644c">&#9670;&nbsp;</a></span>GetInt24LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt24LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="aa4e42b691d1b61264a6ac1ddc820eaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e42b691d1b61264a6ac1ddc820eaa7">&#9670;&nbsp;</a></span>GetInt32LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ts::GetInt32LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="aa827b7a0b2e9a76136cbffe4b6258a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa827b7a0b2e9a76136cbffe4b6258a06">&#9670;&nbsp;</a></span>GetInt64LE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ts::GetInt64LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="a6099795b2a30ac243a548217568231b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6099795b2a30ac243a548217568231b7">&#9670;&nbsp;</a></span>GetUInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting an 8-bit unsigned integer from serialized data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an 8-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 8-bit unsigned integer at <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a640588fb3bf230cc97292e011bc6386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640588fb3bf230cc97292e011bc6386d">&#9670;&nbsp;</a></span>GetUInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a3509bd545f2ef43e00fff957d39b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3509bd545f2ef43e00fff957d39b6d">&#9670;&nbsp;</a></span>GetUInt24() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d03f32b2cc3d180c0278cb528f2dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d03f32b2cc3d180c0278cb528f2dd3">&#9670;&nbsp;</a></span>GetUInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a818fee94510087611afa73a9d365c585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818fee94510087611afa73a9d365c585">&#9670;&nbsp;</a></span>GetUInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6de659ceb502ea588e7b1d54beb326b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6de659ceb502ea588e7b1d54beb326b">&#9670;&nbsp;</a></span>GetUInt16BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt16BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a502006f7de222a7313790483bd219a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502006f7de222a7313790483bd219a80">&#9670;&nbsp;</a></span>GetUInt24BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt24BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5307f92f2750b89a6c708e2aa089474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5307f92f2750b89a6c708e2aa089474">&#9670;&nbsp;</a></span>GetUInt32BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt32BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba89ecf66ba17985d47ee587027d14ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba89ecf66ba17985d47ee587027d14ea">&#9670;&nbsp;</a></span>GetUInt64BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt64BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb655627968c393bc4847b1801e7ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb655627968c393bc4847b1801e7ccc">&#9670;&nbsp;</a></span>GetUInt16LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt16LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit unsigned integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4344c054ebe6196445c629dccec90142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4344c054ebe6196445c629dccec90142">&#9670;&nbsp;</a></span>GetUInt24LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt24LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit unsigned integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 24-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ec83efdcf4e64a1ede8fc6f2440e38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec83efdcf4e64a1ede8fc6f2440e38a">&#9670;&nbsp;</a></span>GetUInt32LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt32LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit unsigned integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9099fb920e9cd1ba4f0b80070556757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9099fb920e9cd1ba4f0b80070556757">&#9670;&nbsp;</a></span>GetUInt64LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetUInt64LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit unsigned integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeebbae738a51852399693a6cfe37d919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebbae738a51852399693a6cfe37d919">&#9670;&nbsp;</a></span>GetInt8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting an 8-bit signed integer from serialized data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an 8-bit signed integer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 8-bit signed integer at <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabce47934b112b06aa1d0e034c0ab851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabce47934b112b06aa1d0e034c0ab851">&#9670;&nbsp;</a></span>GetInt16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d4ec1b3fbdd3ff2d19f2c38b79499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d4ec1b3fbdd3ff2d19f2c38b79499b">&#9670;&nbsp;</a></span>GetInt24() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt24 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 24-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2700410ea296c21f2bcddd7186e84c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2700410ea296c21f2bcddd7186e84c4">&#9670;&nbsp;</a></span>GetInt32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc81f51b1795f2dae40bbb2eecb2f2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc81f51b1795f2dae40bbb2eecb2f2e7">&#9670;&nbsp;</a></span>GetInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00d6bbd751c624abd11d5871edbb4f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d6bbd751c624abd11d5871edbb4f83">&#9670;&nbsp;</a></span>GetInt16BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt16BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe74b54d502f2d4904300533e43d11a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe74b54d502f2d4904300533e43d11a3">&#9670;&nbsp;</a></span>GetInt24BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt24BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 24-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a081c684a9d7f24ea32c62d021d2cf6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081c684a9d7f24ea32c62d021d2cf6a3">&#9670;&nbsp;</a></span>GetInt32BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt32BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bf0acc4d3952cf73398cb86dfedf935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf0acc4d3952cf73398cb86dfedf935">&#9670;&nbsp;</a></span>GetInt64BE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt64BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9921a2b83853ab95d3a8071f9568f655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9921a2b83853ab95d3a8071f9568f655">&#9670;&nbsp;</a></span>GetInt16LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt16LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 16-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 16-bit signed integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0271258a9dfdd04ccd315680f743e484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0271258a9dfdd04ccd315680f743e484">&#9670;&nbsp;</a></span>GetInt24LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt24LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 24-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 24-bit signed integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cbbe3883b9e2c35587a405593405876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbbe3883b9e2c35587a405593405876">&#9670;&nbsp;</a></span>GetInt32LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt32LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 32-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 32-bit signed integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395998cb5255d75c73aedbba83408c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395998cb5255d75c73aedbba83408c03">&#9670;&nbsp;</a></span>GetInt64LE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt64LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function getting a 64-bit signed integer from serialized data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to a 64-bit signed integer in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d2da9f1234257162bc54cdc7f14577d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2da9f1234257162bc54cdc7f14577d">&#9670;&nbsp;</a></span>PutUInt8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing an 8-bit unsigned integer data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 8-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 8-bit unsigned integer to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a305fe98ef80b1759d8576b06f67c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a305fe98ef80b1759d8576b06f67c59">&#9670;&nbsp;</a></span>PutUInt16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ebe5e56895037b713f551b84b20d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ebe5e56895037b713f551b84b20d26">&#9670;&nbsp;</a></span>PutUInt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d78a8326b8a5742aeec60b9f625149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d78a8326b8a5742aeec60b9f625149f">&#9670;&nbsp;</a></span>PutUInt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f8f07a858bb7c998fd49e0ab5c2936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f8f07a858bb7c998fd49e0ab5c2936">&#9670;&nbsp;</a></span>PutUInt16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt16BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1706da0714b173a86e1d3453b296f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1706da0714b173a86e1d3453b296f809">&#9670;&nbsp;</a></span>PutUInt32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt32BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55984dfbb23eadbafe471c519bb141a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55984dfbb23eadbafe471c519bb141a2">&#9670;&nbsp;</a></span>PutUInt64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt64BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bca47bda40cfd63c54acceafd8c9720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bca47bda40cfd63c54acceafd8c9720">&#9670;&nbsp;</a></span>PutUInt16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt16LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit unsigned integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit unsigned integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acecae3276848613afd48ca0e86fe0612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecae3276848613afd48ca0e86fe0612">&#9670;&nbsp;</a></span>PutUInt32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt32LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit unsigned integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a256ffe0e0d15f20904ccc77b5b015e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256ffe0e0d15f20904ccc77b5b015e4c">&#9670;&nbsp;</a></span>PutUInt64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt64LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit unsigned integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit unsigned integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edaf6a54326bf4a0ece6d642a81e1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edaf6a54326bf4a0ece6d642a81e1a6">&#9670;&nbsp;</a></span>PutUInt24BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt24BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 24-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d9ddad30e3e50702cc7fcd19a6e8c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9ddad30e3e50702cc7fcd19a6e8c97">&#9670;&nbsp;</a></span>PutUInt24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt24 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit unsigned integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 24-bit unsigned integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78420230afab2dda2251c77a64f0a42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78420230afab2dda2251c77a64f0a42f">&#9670;&nbsp;</a></span>PutUInt24LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutUInt24LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit unsigned integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit unsigned integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit unsigned integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab609f2d6182dfbf69356a50b4840ad5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab609f2d6182dfbf69356a50b4840ad5a">&#9670;&nbsp;</a></span>PutInt8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing an 8-bit signed integer data. </p>
<p>Note: There is no byte-swapping in the serialization / deserialization of 8-bit integer data. But this function is provided for consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 8-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 8-bit signed integer to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53cfe7ccf881f48abb903fad0ce5eba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cfe7ccf881f48abb903fad0ce5eba4">&#9670;&nbsp;</a></span>PutInt16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dad66d4d0f6bd8b5b996a33078da03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dad66d4d0f6bd8b5b996a33078da03a">&#9670;&nbsp;</a></span>PutInt24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt24 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4420be5d849abb7c099a35f192a85b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4420be5d849abb7c099a35f192a85b57">&#9670;&nbsp;</a></span>PutInt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b07e8dadad2b6d5c1a32ccc6a9396ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b07e8dadad2b6d5c1a32ccc6a9396ee">&#9670;&nbsp;</a></span>PutInt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93ea4cfd4f900ead4b28b38c1b5c86c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ea4cfd4f900ead4b28b38c1b5c86c3">&#9670;&nbsp;</a></span>PutInt16BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt16BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0683c99580e91b2adff0b3097d0332d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0683c99580e91b2adff0b3097d0332d9">&#9670;&nbsp;</a></span>PutInt24BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt24BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4b6dd0238df9158bc987a2df603ee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b6dd0238df9158bc987a2df603ee8f">&#9670;&nbsp;</a></span>PutInt32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt32BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6205bd79cdf6c8821774624c63f2c563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6205bd79cdf6c8821774624c63f2c563">&#9670;&nbsp;</a></span>PutInt64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt64BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit signed integer data in big endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae74ec8e23311e6160103e721af9b1d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74ec8e23311e6160103e721af9b1d5b">&#9670;&nbsp;</a></span>PutInt16LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt16LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 16-bit signed integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 16-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 16-bit signed integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae07fa62ef736da28b1075a4a58dc6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae07fa62ef736da28b1075a4a58dc6e6">&#9670;&nbsp;</a></span>PutInt24LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt24LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 24-bit signed integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 24-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a56ef6cccf4ad5fc2db2bdb9145b341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a56ef6cccf4ad5fc2db2bdb9145b341">&#9670;&nbsp;</a></span>PutInt32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt32LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 32-bit signed integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 32-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 32-bit signed integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a9b487302b87e7419da6928a574107b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9b487302b87e7419da6928a574107b">&#9670;&nbsp;</a></span>PutInt64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt64LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function serializing a 64-bit signed integer data in little endian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the 64-bit signed integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The 64-bit signed integer in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa73790a97bab5af98d70d61ac940e812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73790a97bab5af98d70d61ac940e812">&#9670;&nbsp;</a></span>CondByteSwapBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::CondByteSwapBE </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function performing conditional byte swap on integer data to obtain the data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An INT to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a5727edb9849beae3829fb323b15585d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5727edb9849beae3829fb323b15585d6">&#9670;&nbsp;</a></span>CondByteSwapLE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::CondByteSwapLE </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function performing conditional byte swap on integer data to obtain the data in little endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An INT to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On big-endian platforms, return the value of <em>x</em> where bytes were swapped. On little-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a103d4008075d1c45ec21011f0c5b58df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103d4008075d1c45ec21011f0c5b58df">&#9670;&nbsp;</a></span>CondByteSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::CondByteSwap </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function performing conditional byte swap on integer data to obtain the data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An INT to conditionally swap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On little-endian platforms, return the value of <em>x</em> where bytes were swapped. On big-endian platforms, return the value of <em>x</em> unmodified. </dd></dl>

</div>
</div>
<a id="a17265d933a9beb229d001b26bbf021af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17265d933a9beb229d001b26bbf021af">&#9670;&nbsp;</a></span>GetInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::GetInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The INT value in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="afb3a7db5384f5070e45edfb58e92c3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3a7db5384f5070e45edfb58e92c3d2">&#9670;&nbsp;</a></span>GetIntBE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::GetIntBE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in big endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The INT value in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="ab10732fdeb495c72480c06249aa9e270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10732fdeb495c72480c06249aa9e270">&#9670;&nbsp;</a></span>GetIntLE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT ts::GetIntLE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in little endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in little endian representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The INT value in native byte order, deserialized from <em>p</em>. </dd></dl>

</div>
</div>
<a id="afcc9d2fb4021b00dac5c7aa0cae59c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc9d2fb4021b00dac5c7aa0cae59c6e">&#9670;&nbsp;</a></span>GetInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The INT value in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add89d5728c5affffa607ff9f52f7ca45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add89d5728c5affffa607ff9f52f7ca45">&#9670;&nbsp;</a></span>GetIntBE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetIntBE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in big endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The INT value in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa461b054bf380348f7db7f899840e382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa461b054bf380348f7db7f899840e382">&#9670;&nbsp;</a></span>GetIntLE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetIntLE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function getting an integer from serialized data in little endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>An address pointing to an INT in little endian representation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The INT value in native byte order, deserialized from <em>p</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb825a99d11021d5b9fb46fd09d847ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb825a99d11021d5b9fb46fd09d847ab">&#9670;&nbsp;</a></span>PutInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutInt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function serializing an integer data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The INT in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7c976028b433f728b45103ea1c331e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c976028b433f728b45103ea1c331e6">&#9670;&nbsp;</a></span>PutIntBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutIntBE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function serializing an integer data in big endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The INT in native byte order to serialize in big endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abae1747799a404d1b992b36e4dad6f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae1747799a404d1b992b36e4dad6f62">&#9670;&nbsp;</a></span>PutIntLE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ts::PutIntLE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function serializing an integer data in little endian representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>Some integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An address where to serialize the integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The INT in native byte order to serialize in little endian representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc1511582799a25d3ca0889391ef6cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1511582799a25d3ca0889391ef6cdd">&#9670;&nbsp;</a></span>ROL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::ROL </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 32-bit left-rotate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 32-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Can be positive (left-rotate) or negative (right-rotate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> left-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="a1bd41a7d2a6ef91744555d603accea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd41a7d2a6ef91744555d603accea06">&#9670;&nbsp;</a></span>RORc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::RORc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 32-bit left-rotate with a constant value in the range 0..31 for index. </p>
<p>Inlined function performing 32-bit right-rotate with a constant value in the range 0..31 for index.</p>
<p>Using <code>ROLc</code> instead of <code>ROL</code> when the number of bits to rotate is a compile-time constant brings some performance gain on platforms where the function in written as inlined assembly code. Although the performance gain is small, it can bring some improvement on cryptographic algorithms for instance.</p>
<p>Note: In debug mode, <code>ROLc</code> reverts to <code>ROL</code> since the routine is not inlined and the constant constraint cannot be checked by the compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 32-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Must be a constant value in the range 0..31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> left-rotated by <em>i</em> bits.</dd></dl>
<p>Using <code>RORc</code> instead of <code>ROR</code> when the number of bits to rotate is a compile-time constant brings some performance gain on platforms where the function in written as inlined assembly code. Although the performance gain is small, it can bring some improvement on cryptographic algorithms for instance.</p>
<p>Note 1: In debug mode, <code>RORc</code> reverts to <code>ROR</code> since the routine is not inlined and the constant constraint cannot be checked by the compiler.</p>
<p>Note 2: With the LLVM compiler, <code>RORc</code> reverts to <code>ROR</code> since the compiled generates an error and does not recognize the operand as a constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 32-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Must be a constant value in the range 0..31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> right-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="aebdf2fed7c021b5f0ed05991aea8c9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdf2fed7c021b5f0ed05991aea8c9b2">&#9670;&nbsp;</a></span>ROR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ts::ROR </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 32-bit right-rotate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 32-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Can be positive (right-rotate) or negative (left-rotate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> right-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="a57151094cdd98106fb52d244ab77512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57151094cdd98106fb52d244ab77512a">&#9670;&nbsp;</a></span>ROL64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::ROL64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 64-bit left-rotate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 64-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Can be positive (left-rotate) or negative (right-rotate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> left-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="ad693f2485d1a42ed33214a7d04d4421d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693f2485d1a42ed33214a7d04d4421d">&#9670;&nbsp;</a></span>ROL64c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::ROL64c </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 64-bit left-rotate with a constant value in the range 0..63 for index. </p>
<p>Using <code>ROL64c</code> instead of <code>ROL64</code> when the number of bits to rotate is a compile-time constant brings some performance gain on platforms where the function in written as inlined assembly code. Although the performance gain is small, it can bring some improvement on cryptographic algorithms for instance.</p>
<p>Note: In debug mode, <code>ROL64c</code> reverts to <code>ROL64</code> since the routine is not inlined and the constant constraint cannot be checked by the compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 64-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Must be a constant value in the range 0..63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> left-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="aea56cdee827d08793a5f9b9c608ff787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea56cdee827d08793a5f9b9c608ff787">&#9670;&nbsp;</a></span>ROR64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::ROR64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 64-bit right-rotate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 64-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Can be positive (right-rotate) or negative (left-rotate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> right-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="a6d0521f51487a0d59c3f36fc6f2d8cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0521f51487a0d59c3f36fc6f2d8cfe">&#9670;&nbsp;</a></span>ROR64c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ts::ROR64c </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined function performing 64-bit right-rotate with a constant value in the range 0..63 for index. </p>
<p>Using <code>ROR64c</code> instead of <code>ROR64</code> when the number of bits to rotate is a compile-time constant brings some performance gain on platforms where the function in written as inlined assembly code. Although the performance gain is small, it can bring some improvement on cryptographic algorithms for instance.</p>
<p>Note: In debug mode, <code>ROR64c</code> reverts to <code>ROR64</code> since the routine is not inlined and the constant constraint cannot be checked by the compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>A 64-bit word to rotate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The number of bits by which to rotate <em>word</em>. Must be a constant value in the range 0..63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>word</em> right-rotated by <em>i</em> bits. </dd></dl>

</div>
</div>
<a id="aa816d1f04480538021fee6d480570238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa816d1f04480538021fee6d480570238">&#9670;&nbsp;</a></span>LastErrorCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::LastErrorCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the error code of the last operating system call. </p>
<p>The validity of the returned value may depends on specific conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>The error code of the last operating system call. </dd></dl>

</div>
</div>
<a id="ac83331155a2f7f09c1d919ba570cc263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83331155a2f7f09c1d919ba570cc263">&#9670;&nbsp;</a></span>Trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::Trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading and / or trailing space characters in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>String to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of <em>str</em>. If false, do not modify the beginning of <em>str</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of <em>str</em>. If false, do not modify the end of <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>str</em>. </dd></dl>

</div>
</div>
<a id="a3578dc1ee3136b0c040aab4848608036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3578dc1ee3136b0c040aab4848608036">&#9670;&nbsp;</a></span>ReturnTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnTrim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of a string where leading and / or trailing spaces are trimmed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of <em>str</em>. If false, do not modify the beginning of <em>str</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of <em>str</em>. If false, do not modify the end of <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>str</em> after trimming. </dd></dl>

</div>
</div>
<a id="a42422894b047910ea84ae5569a15abf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42422894b047910ea84ae5569a15abf6">&#9670;&nbsp;</a></span>RemoveSubstring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::RemoveSubstring </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>Input string, to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove from <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>str</em>. </dd></dl>

</div>
</div>
<a id="a286b27824b61d0cdedb03dd5adf865ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286b27824b61d0cdedb03dd5adf865ee">&#9670;&nbsp;</a></span>RemoveSubstring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::RemoveSubstring </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>Input string, to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove from <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>str</em>. </dd></dl>

</div>
</div>
<a id="aea5388748dd6d6f913357717d24b7cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5388748dd6d6f913357717d24b7cd2">&#9670;&nbsp;</a></span>ReturnRemoveSubstring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnRemoveSubstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove from <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>str</em> where all occurences of <em>substr</em> are removed. </dd></dl>

</div>
</div>
<a id="a350c867cc5c3841da86284dbde958ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350c867cc5c3841da86284dbde958ee4">&#9670;&nbsp;</a></span>ReturnRemoveSubstring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnRemoveSubstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove from <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>str</em> where all occurences of <em>substr</em> are removed. </dd></dl>

</div>
</div>
<a id="a3d9d029d4b1bc55e2ba770a8320617fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9d029d4b1bc55e2ba770a8320617fb">&#9670;&nbsp;</a></span>SubstituteAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::SubstituteAll </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all occurences of a string with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>A string to modify: all occurences of <em>value</em> will be replaced by <em>replace</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>str</em> after modification. </dd></dl>

</div>
</div>
<a id="a94466636c79bbfd8808c670c69006138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94466636c79bbfd8808c670c69006138">&#9670;&nbsp;</a></span>ReturnSubstituteAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnSubstituteAll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of a string where all occurences of a string are substituted with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Original string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy to <em>str</em> where all occurences of <em>value</em> have been replaced by <em>replace</em>. </dd></dl>

</div>
</div>
<a id="a6489166bbdba4193977b020ec4b8385e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6489166bbdba4193977b020ec4b8385e">&#9670;&nbsp;</a></span>SplitString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::SplitString </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into segments based on a separator character (comma by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A C-string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>The character which is used to separate the segments of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a272bf411bef1fb0ae4d01bc1c049f73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bf411bef1fb0ae4d01bc1c049f73d">&#9670;&nbsp;</a></span>SplitString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::SplitString </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into segments based on a separator character (comma by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>The character which is used to separate the segments of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a86fb18e3c49571263b63f5abed843c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fb18e3c49571263b63f5abed843c3c">&#9670;&nbsp;</a></span>SplitBlocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::SplitBlocks </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>startWith</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>endWith</em> = <code>']'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A C-string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startWith</td><td>The character which is used to identify the start of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endWith</td><td>The character which is used to identify the end of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a91ff97eeaa3c005db1fb62a8fe91b44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ff97eeaa3c005db1fb62a8fe91b44d">&#9670;&nbsp;</a></span>SplitBlocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::SplitBlocks </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>startWith</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>endWith</em> = <code>']'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into segments based on a separator character (comma by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startWith</td><td>The character which is used to identify the start of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endWith</td><td>The character which is used to identify the end of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a7b74c0c8707ab08243759c4210424dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b74c0c8707ab08243759c4210424dcf">&#9670;&nbsp;</a></span>SplitLines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::SplitLines </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>otherSeparators</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nextMargin</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSplit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into multiple lines which are not longer than a specified maximum width. </p>
<p>The splits occur on spaces or after any character in <em>otherSeparators</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> which receives the lines of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to break into lines </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of each resulting line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSeparators</td><td>A string containing all characters which are acceptable as line break points (in addition to space characters which are always potential line break points). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMargin</td><td>A string which is prepended to all lines after the first one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSplit</td><td>If true, longer lines without separators are split at the maximum width (by default, longer lines without separators are not split, resulting in lines longer than <em>maxWidth</em>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="accb698f50941b427f5edeb93f24f1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb698f50941b427f5edeb93f24f1a05">&#9670;&nbsp;</a></span>JoinStrings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::JoinStrings </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a part of a container of strings into one big string. </p>
<p>The strings are accessed through iterators in the container. All strings are concatenated into one big string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="adae3999ebda5c36c9b12205527307b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae3999ebda5c36c9b12205527307b16">&#9670;&nbsp;</a></span>JoinStrings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::JoinStrings </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a container of strings into one big string. </p>
<p>All strings from the container are concatenated into one big string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <code>std::string</code> containing all strings to concatenate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="a18700ff6227513eb587f3af1bb5767f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18700ff6227513eb587f3af1bb5767f1">&#9670;&nbsp;</a></span>IsSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsSpace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a character is a space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>An integer containing a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>c</em> is a space, tab, new line character. </dd></dl>

</div>
</div>
<a id="aee27fac7041403178f5dceb53fb721b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee27fac7041403178f5dceb53fb721b8">&#9670;&nbsp;</a></span>IsPrintable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsPrintable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure european characters are detected as printable, even if isprint(3) does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>An integer containing a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>c</em> is a printable character, including extended european character. </dd></dl>

</div>
</div>
<a id="a5ae930748c773797e40b2c4d80163509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae930748c773797e40b2c4d80163509">&#9670;&nbsp;</a></span>Printable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Printable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replacement</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a printable version of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>The character which replaces non-printable characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>s</em> where non-printable characters are replaced by <em>replacement</em>. </dd></dl>

</div>
</div>
<a id="a105a245fbc25ba78e9512b6c473ccae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105a245fbc25ba78e9512b6c473ccae6">&#9670;&nbsp;</a></span>Printable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Printable </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replacement</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a printable version of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of string data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>String length in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>The character which replaces non-printable characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the string where non-printable characters are replaced by <em>replacement</em>. </dd></dl>

</div>
</div>
<a id="a64e55c368064694ae66e6fa3454180ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e55c368064694ae66e6fa3454180ed">&#9670;&nbsp;</a></span>ToLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ts::ToLower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>A character to convert to lowercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>c</em> converted to lowercase. </dd></dl>

</div>
</div>
<a id="acae6f5cf0f1bfd1300f69104a46c512b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae6f5cf0f1bfd1300f69104a46c512b">&#9670;&nbsp;</a></span>ToUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ts::ToUpper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a character to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>A character to convert to uppercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>c</em> converted to uppercase. </dd></dl>

</div>
</div>
<a id="abd44c62e7b82e60cf923994a89caa096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd44c62e7b82e60cf923994a89caa096">&#9670;&nbsp;</a></span>ToLowerCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::ToLowerCase </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a string to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>A string which is converted to lowercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string parameter. </dd></dl>

</div>
</div>
<a id="acdf4a092f09455169cfa57a8951bac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4a092f09455169cfa57a8951bac3e">&#9670;&nbsp;</a></span>ToUpperCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::ToUpperCase </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a string to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>A string which is converted to uppercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string parameter. </dd></dl>

</div>
</div>
<a id="a14a774ecfc4c9d96443b20df10ba22b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a774ecfc4c9d96443b20df10ba22b2">&#9670;&nbsp;</a></span>LowerCaseValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::LowerCaseValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a lowercase copy of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to convert to lowercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>s</em> converted to lowercase. </dd></dl>

</div>
</div>
<a id="a109c37b26251bd268a268d566743076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109c37b26251bd268a268d566743076c">&#9670;&nbsp;</a></span>UpperCaseValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::UpperCaseValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uppercase copy of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to convert to uppercase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>s</em> converted to uppercase. </dd></dl>

</div>
</div>
<a id="ae63069e9073c0b2a0261ebe1d8e7909a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63069e9073c0b2a0261ebe1d8e7909a">&#9670;&nbsp;</a></span>RemoveCharacter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::RemoveCharacter </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of character c in string s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>A string which is modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string parameter. </dd></dl>

</div>
</div>
<a id="addf11fa7933c08cd5863597bb9e9bf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf11fa7933c08cd5863597bb9e9bf47">&#9670;&nbsp;</a></span>RemovePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::RemovePrefix </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>A string which is modified. If <em>s</em> starts with <em>prefix</em>, the prefix is removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string parameter. </dd></dl>

</div>
</div>
<a id="ac8e582bc1154c776bf39bbbdb2a82cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e582bc1154c776bf39bbbdb2a82cd3">&#9670;&nbsp;</a></span>RemoveSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ts::RemoveSuffix </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>A string which is modified. If <em>s</em> ends with <em>suffix</em>, the suffix is removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string parameter. </dd></dl>

</div>
</div>
<a id="ab92609fc21b3ff43cbd411a71864b620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92609fc21b3ff43cbd411a71864b620">&#9670;&nbsp;</a></span>ReturnRemovePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnRemovePrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>An input string. If <em>s</em> starts with <em>prefix</em>, the prefix is removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>s</em> with prefix removed. </dd></dl>

</div>
</div>
<a id="a1d11256c6de3fbaac1e0fc3d7544d225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d11256c6de3fbaac1e0fc3d7544d225">&#9670;&nbsp;</a></span>ReturnRemoveSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ReturnRemoveSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>An input string. If <em>s</em> ends with <em>suffix</em>, the suffix is removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>s</em> with suffix removed. </dd></dl>

</div>
</div>
<a id="a61e7fd59b1897788309e19f2e7b9bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7fd59b1897788309e19f2e7b9bfcd">&#9670;&nbsp;</a></span>StartWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::StartWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string starts with a specified prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A C-string prefix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a4526d2f0dde97eea9132047ea1dc5bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4526d2f0dde97eea9132047ea1dc5bf9">&#9670;&nbsp;</a></span>StartWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::StartWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string starts with a specified prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A string prefix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="aefdb6bf8a7cbfa70fb3e2dc943d379b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb6bf8a7cbfa70fb3e2dc943d379b0">&#9670;&nbsp;</a></span>StartWithInsensitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::StartWithInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string starts with a specified prefix, case-insensitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A C-string prefix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a379ad577f8980175a649df52aaaec1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379ad577f8980175a649df52aaaec1c3">&#9670;&nbsp;</a></span>StartWithInsensitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::StartWithInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string starts with a specified prefix, case-insensitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A string prefix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="acaa6e545213c5fd39a1053fbd43a095b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa6e545213c5fd39a1053fbd43a095b">&#9670;&nbsp;</a></span>EndWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EndWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a suffix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A C-string suffix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a45f150c14724d830da22138ddef8aa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f150c14724d830da22138ddef8aa56">&#9670;&nbsp;</a></span>EndWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EndWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a suffix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A string suffix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="ab4923b602ba062ef4f527ca62fe09088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4923b602ba062ef4f527ca62fe09088">&#9670;&nbsp;</a></span>EndWithInsensitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EndWithInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix, case-insensitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a suffix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A C-string suffix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a696723ccbd395ba7b1d6b82ec202730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696723ccbd395ba7b1d6b82ec202730b">&#9670;&nbsp;</a></span>EndWithInsensitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EndWithInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix, case-insensitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to look for a suffix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A string suffix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>s</em> ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="ab831b156e2633695c1152110edca118d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab831b156e2633695c1152110edca118d">&#9670;&nbsp;</a></span>JustifyLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::JustifyLeft </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a left-justified (padded and optionally truncated) string. </p>
<p>If the string is shorter than the specified width, <em>pad</em> characters are appended to the string up to the specified width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to justify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to append to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and <em>str</em> is longer than <em>width</em>, <em>str</em> is truncated to <em>width</em> character. If false, <em>str</em> is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a99b47ed835d84c03dac56a6b33ee6e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b47ed835d84c03dac56a6b33ee6e35">&#9670;&nbsp;</a></span>JustifyRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::JustifyRight </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a right-justified (padded and optionally truncated) string. </p>
<p>If the string is shorter than the specified width, <em>pad</em> characters are prepended to the string up to the specified width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to justify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to prepend to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and <em>str</em> is longer than <em>width</em>, the beginning of <em>str</em> is truncated. If false, <em>str</em> is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="ad5962b91c1219cc2969210911be0ced9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5962b91c1219cc2969210911be0ced9">&#9670;&nbsp;</a></span>JustifyCentered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::JustifyCentered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a centered-justified (padded and optionally truncated) string. </p>
<p>If the string is shorter than the specified width, <em>pad</em> characters are prepended and appended to the string up to the specified width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to justify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The pad character for the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and <em>str</em> is longer than <em>width</em>, <em>str</em> is truncated to <em>width</em> character. If false, <em>str</em> is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a912d1288481242c9392726062a9bc8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912d1288481242c9392726062a9bc8c4">&#9670;&nbsp;</a></span>Justify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::Justify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a justified string, pad in the middle. </p>
<p>If the <em>left</em> and <em>right</em> components are collectively shorter than the specified width, <em>pad</em> characters are inserted between <em>left</em> and <em>right</em>, up to the specified width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The left part of the string to justify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right part of the string to justify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to insert between the two parts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. Can be longer than <em>width</em> if the <em>left</em> and <em>right</em> components are collectively longer than <em>width</em>. </dd></dl>

</div>
</div>
<a id="a5bd917f9a32dab4b5f8d0adfb66356e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd917f9a32dab4b5f8d0adfb66356e0">&#9670;&nbsp;</a></span>YesNo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ts::YesNo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "yes" or "no". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"yes" is <em>b</em> is true, "no" otherwise. </dd></dl>

</div>
</div>
<a id="a905341d5e67049eca079b9730d229797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905341d5e67049eca079b9730d229797">&#9670;&nbsp;</a></span>TrueFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ts::TrueFalse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "true" or "false". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" is <em>b</em> is true, "false" otherwise. </dd></dl>

</div>
</div>
<a id="a8cf6b498027908f096a0f9162897912e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf6b498027908f096a0f9162897912e">&#9670;&nbsp;</a></span>OnOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ts::OnOff </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "on" or "off". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"on" is <em>b</em> is true, "off" otherwise. </dd></dl>

</div>
</div>
<a id="aab8264fdcc13f105f5b88ed29a1f5c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8264fdcc13f105f5b88ed29a1f5c14">&#9670;&nbsp;</a></span>SimilarStrings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SimilarStrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings are "similar", ie. identical, case-insensitive and ignoring blanks </dd></dl>

</div>
</div>
<a id="a8157d774bb7d87d33a907874e575630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8157d774bb7d87d33a907874e575630a">&#9670;&nbsp;</a></span>SimilarStrings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SimilarStrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Address of second string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bsize</td><td>Size of second string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings are "similar", ie. identical, case-insensitive and ignoring blanks </dd></dl>

</div>
</div>
<a id="acd7d283185f503c985d9ac0dd8049e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7d283185f503c985d9ac0dd8049e2d">&#9670;&nbsp;</a></span>HexaDecode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::HexaDecode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexa_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Decoded bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hexa_string</td><td>A string as a sequence of hexadecimal digits and blanks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="a1d4a51962a177e62402915c9aedd6724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4a51962a177e62402915c9aedd6724">&#9670;&nbsp;</a></span>HexaDecode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::HexaDecode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hexa_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Decoded bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hexa_string</td><td>A string as a sequence of hexadecimal digits and blanks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="af30dd41c88e3c79134b27e3e95ba7962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30dd41c88e3c79134b27e3e95ba7962">&#9670;&nbsp;</a></span>HexaDecodeAndAppend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::HexaDecodeAndAppend </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexa_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The decoded bytes are added at the end of the previous content. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hexa_string</td><td>A string as a sequence of hexadecimal digits and blanks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="a94866a95881571f8a34510e89e152c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94866a95881571f8a34510e89e152c71">&#9670;&nbsp;</a></span>HexaDecodeAndAppend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::HexaDecodeAndAppend </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hexa_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The decoded bytes are added at the end of the previous content. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hexa_string</td><td>A string as a sequence of hexadecimal digits and blanks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="aa176777d53302df102a85c1f6d138c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa176777d53302df102a85c1f6d138c32">&#9670;&nbsp;</a></span>LoadStrings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::LoadStrings </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all lines of a text file as strings into a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="ae191ded5f90ee4a10ebdf42e127c2269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae191ded5f90ee4a10ebdf42e127c2269">&#9670;&nbsp;</a></span>LoadAppendStrings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::LoadAppendStrings </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all lines of a text file as strings and append them at the end of a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> receiving all lines of the file. Each line of the text file is a separate string. The lines are appended at the end of the container, preserving the previous content of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a97c069b088781066598fa644830e9f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c069b088781066598fa644830e9f84">&#9670;&nbsp;</a></span>SaveStrings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SaveStrings </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save strings from a container into a file, one per line. </p>
<p>The strings must be located in a container and are accessed through iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a2dfe3605604a4fe9c52d644912977a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfe3605604a4fe9c52d644912977a70">&#9670;&nbsp;</a></span>SaveStrings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SaveStrings </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save strings from a container into a file, one per line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <code>std::string</code> containing all strings to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="ae6e4e88a9c2f7064573fd90c72ff156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e4e88a9c2f7064573fd90c72ff156d">&#9670;&nbsp;</a></span>AppendContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::AppendContainer </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an array of C-strings to a container of strings. </p>
<p>All C-strings from an array are appended at the end of a container. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <code>std::string</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="ae621d83bb5d17fa06d18f342a75cb06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae621d83bb5d17fa06d18f342a75cb06f">&#9670;&nbsp;</a></span>AppendContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::AppendContainer </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an array of C-strings to a container of strings. </p>
<p>All C-strings from an array are appended at the end of a container. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <code>std::string</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="ad4243f1bbc2cce04db3982f9684f29b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4243f1bbc2cce04db3982f9684f29b7">&#9670;&nbsp;</a></span>AssignContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::AssignContainer </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an array of C-strings to a container of strings. </p>
<p>The container is assigned using all C-strings from an array. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="ac7b00c4b99bf91b332b150c7c6492f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b00c4b99bf91b332b150c7c6492f15">&#9670;&nbsp;</a></span>AssignContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER&amp; ts::AssignContainer </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an array of C-strings to a container of strings. </p>
<p>The container is assigned using all C-strings from an array. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a55c92f5de6d04087bd9e9183fbe6648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c92f5de6d04087bd9e9183fbe6648b">&#9670;&nbsp;</a></span>LargestLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::LargestLength </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the longest string in a container of strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <code>std::string</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the longest string in <em>container</em>. </dd></dl>

</div>
</div>
<a id="af2b6fa8094989e30357301a679aa7a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b6fa8094989e30357301a679aa7a79">&#9670;&nbsp;</a></span>VernacularFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::VernacularFilePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a "vernacular" version of a file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <em>path</em> where all '/' and '\' have been translated into the local directory separator. </dd></dl>

</div>
</div>
<a id="a6152d8b5663d062a2797cd3bb9496ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6152d8b5663d062a2797cd3bb9496ab9">&#9670;&nbsp;</a></span>DirectoryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::DirectoryName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the directory name of a file path ("dir/foo.bar" =&gt; "dir"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The directory name of <em>path</em> ("dir/foo.bar" =&gt; "dir"). </dd></dl>

</div>
</div>
<a id="ae49fabcce93a8e3bf7e998873a5a78a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49fabcce93a8e3bf7e998873a5a78a1">&#9670;&nbsp;</a></span>BaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::BaseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the base file name of a file path ("dir/foo.bar" =&gt; "foo.bar"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>An optional file suffix. If <em>path</em> ends in <em>suffix</em>, the suffix is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base file name of <em>path</em> ("dir/foo.bar" =&gt; "foo.bar"). </dd></dl>

</div>
</div>
<a id="a0e8326c599b8c65d4f12fcbd3a5b38b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8326c599b8c65d4f12fcbd3a5b38b6">&#9670;&nbsp;</a></span>PathSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::PathSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the suffix of a file path ("dir/foo.bar" =&gt; ".bar"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The suffix of <em>path</em> ("dir/foo.bar" =&gt; ".bar"). </dd></dl>

</div>
</div>
<a id="ac7e91f1fc19b43a859dffb518daf4488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e91f1fc19b43a859dffb518daf4488">&#9670;&nbsp;</a></span>AddPathSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::AddPathSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditionally add a suffix to a file path. </p>
<p>If the file path does not contain a suffix, add the specified one. Otherwise, return the name unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>The suffix to conditionally add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>path</em> with a suffix (for conditional suffix ".bar", "dir/foo" =&gt; "dir/foo.bar" and "dir/foo.too" =&gt; "dir/foo.too"). </dd></dl>

</div>
</div>
<a id="aca04bf40c24a4469afab720302f1589e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca04bf40c24a4469afab720302f1589e">&#9670;&nbsp;</a></span>PathPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::PathPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the prefix of a file path ("dir/foo.bar" =&gt; "dir/foo"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prefix of <em>path</em> ("dir/foo.bar" =&gt; "dir/foo"). </dd></dl>

</div>
</div>
<a id="a710c83d83ca1de817a6df4f30c056615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710c83d83ca1de817a6df4f30c056615">&#9670;&nbsp;</a></span>UserHomeDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::UserHomeDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current user's home directory. </p>
<dl class="section return"><dt>Returns</dt><dd>The full path of the current user's home directory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classts_1_1_exception.html" title="Base class for all exceptions in TSDuck. ">ts::Exception</a></td><td>In case of operating system error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a716f791b1bb4f10defba533ee696a193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716f791b1bb4f10defba533ee696a193">&#9670;&nbsp;</a></span>ExecutableFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ExecutableFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the current application executable file. </p>
<dl class="section return"><dt>Returns</dt><dd>The full path of the executable file which is run in the current process. </dd></dl>

</div>
</div>
<a id="a0e7898369b6ffa64d96dabd6762f3137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7898369b6ffa64d96dabd6762f3137">&#9670;&nbsp;</a></span>HostName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::HostName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the system host. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the system host. </dd></dl>

</div>
</div>
<a id="a02c8b8b3091d0e281fdf0f52ce50e3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c8b8b3091d0e281fdf0f52ce50e3c9">&#9670;&nbsp;</a></span>SleepThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::SleepThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">MilliSecond</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the current thread for the specified period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Number of milliseconds to sleep the current thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5bce33bd7308fbf637d689cc4a6601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bce33bd7308fbf637d689cc4a6601b">&#9670;&nbsp;</a></span>MemoryPageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::MemoryPageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get system memory page size. </p>
<dl class="section return"><dt>Returns</dt><dd>The system memory page size in bytes. </dd></dl>

</div>
</div>
<a id="aeac83403c71f0d14f31ee088e99c7fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac83403c71f0d14f31ee088e99c7fce">&#9670;&nbsp;</a></span>CurrentProcessId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#ade1d7cf3ca2437414d1d4238149a2d5b">ProcessId</a> ts::CurrentProcessId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current process id. </p>
<dl class="section return"><dt>Returns</dt><dd>Identification of the current process. </dd></dl>

</div>
</div>
<a id="a5d60d5af605eb100728b5449eef13b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d60d5af605eb100728b5449eef13b24">&#9670;&nbsp;</a></span>CreateDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::CreateDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A directory path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A system-specific error code (SYS_SUCCESS on success). </dd></dl>

</div>
</div>
<a id="a0ff0f6fd630e4975f1af2816b9b183dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff0f6fd630e4975f1af2816b9b183dc">&#9670;&nbsp;</a></span>TempDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::TempDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of a directory for temporary files. </p>
<dl class="section return"><dt>Returns</dt><dd>A system-dependent location where temporary files can be created. </dd></dl>

</div>
</div>
<a id="a1548a6055eeb4a2acf4a8b45d94483ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548a6055eeb4a2acf4a8b45d94483ad">&#9670;&nbsp;</a></span>TempFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::TempFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>&quot;.tmp&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of a unique temporary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>An optional suffix to add to the file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique temporary file name. </dd></dl>

</div>
</div>
<a id="a6246d849cc1244eb701bba6a73899968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6246d849cc1244eb701bba6a73899968">&#9670;&nbsp;</a></span>GetFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ts::GetFileSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the file or -1 in case of error. </dd></dl>

</div>
</div>
<a id="a8a73e8bb9eddf0c571dbc5c091b03b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73e8bb9eddf0c571dbc5c091b03b2f">&#9670;&nbsp;</a></span>GetFileModificationTimeLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_time.html">Time</a> ts::GetFileModificationTimeLocal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local time of the last modification of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last modification time or <a class="el" href="classts_1_1_time.html#aaddf023d4de5d142e36f599e34ae0294" title="Constant representing the Epoch, ie the first representable time on this operating system...">Time::Epoch</a> in case of error. </dd></dl>

</div>
</div>
<a id="a6b9bcad6c2ca95ba2fed59ae677f1c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9bcad6c2ca95ba2fed59ae677f1c96">&#9670;&nbsp;</a></span>GetFileModificationTimeUTC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_time.html">Time</a> ts::GetFileModificationTimeUTC </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the UTC time of the last modification of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last modification time or <a class="el" href="classts_1_1_time.html#aaddf023d4de5d142e36f599e34ae0294" title="Constant representing the Epoch, ie the first representable time on this operating system...">Time::Epoch</a> in case of error. </dd></dl>

</div>
</div>
<a id="a6c97a02f849dec86d490c6f37f2152bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c97a02f849dec86d490c6f37f2152bb">&#9670;&nbsp;</a></span>FileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::FileExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file or directory exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a file or directory exists with that name, false otherwise. </dd></dl>

</div>
</div>
<a id="a2c35820651b762dde155b395d59af8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c35820651b762dde155b395d59af8d3">&#9670;&nbsp;</a></span>IsDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::IsDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a path exists and is a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A directory path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a directory exists with that name, false otherwise. </dd></dl>

</div>
</div>
<a id="ab3ee8cba56b55cc80888dd85248d576e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ee8cba56b55cc80888dd85248d576e">&#9670;&nbsp;</a></span>DeleteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::DeleteFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file or directory. </p>
<p>If the specified path is a directory, it must be empty. Otherwise, an error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file or directory path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A system-specific error code (SYS_SUCCESS on success). </dd></dl>

</div>
</div>
<a id="a2cabb9f3d1331e509c3bbe4a38b0fba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cabb9f3d1331e509c3bbe4a38b0fba3">&#9670;&nbsp;</a></span>TruncateFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::TruncateFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate a file to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A file path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes after which the file shall be truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A system-specific error code (SYS_SUCCESS on success). </dd></dl>

</div>
</div>
<a id="ae78dad2dfbfc59bacd7d7103b6ae394d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78dad2dfbfc59bacd7d7103b6ae394d">&#9670;&nbsp;</a></span>RenameFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::RenameFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>old_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename / move a file or directory. </p>
<p>If the path specifies a directory, all files in the directory are moved as well.</p>
<p>This method is not guaranteed to work when the new and old names are on distinct volumes or file systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_path</td><td>The file path of an existing file or directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_path</td><td>The new name for the file or directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A system-specific error code (SYS_SUCCESS on success). </dd></dl>

</div>
</div>
<a id="a872c8a98756714309fe0a90e32d323c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872c8a98756714309fe0a90e32d323c6">&#9670;&nbsp;</a></span>ExpandWildcardAndAppend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ExpandWildcardAndAppend </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all files matching a specified wildcard pattern and append them into a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> receiving the the names of all files matching the wildcard. The names are appended at the end of the existing content of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>A file path pattern with wildcards. The syntax of the wildcards is system-dependent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. Note that finding no file matching the pattern is not an error, it simply return no file name. </dd></dl>

</div>
</div>
<a id="a677c17ff06fb84cfd077cfc172bbd3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677c17ff06fb84cfd077cfc172bbd3ac">&#9670;&nbsp;</a></span>ExpandWildcard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ExpandWildcard </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all files matching a specified wildcard pattern. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> receiving the the names of all files matching the wildcard. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>A file path pattern with wildcards. The syntax of the wildcards is system-dependent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. Note that finding no file matching the pattern is not an error, it simply return no file name. </dd></dl>

</div>
</div>
<a id="aa27e4332cd3ac6cd4c8455fcc6f5543e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27e4332cd3ac6cd4c8455fcc6f5543e">&#9670;&nbsp;</a></span>EnvironmentExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::EnvironmentExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an environment variable exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varname</td><td>Environment variable name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified environment variable exists, false otherwise. </dd></dl>

</div>
</div>
<a id="a19a4130331712aade3ef14c149d39f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a4130331712aade3ef14c149d39f94">&#9670;&nbsp;</a></span>GetEnvironment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::GetEnvironment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defvalue</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of an environment variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varname</td><td>Environment variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defvalue</td><td>Default value if the specified environment variable does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified environment variable it it exists, <em>defvalue</em> otherwise. </dd></dl>

</div>
</div>
<a id="a2d35e2646586828824e02e2ef9fd4fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d35e2646586828824e02e2ef9fd4fa1">&#9670;&nbsp;</a></span>GetEnvironmentPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetEnvironmentPath </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of an environment variable containing a search path. </p>
<p>The search path is analyzed and split into individual directory names.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code>std::string</code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code>std::string</code> receiving the directory names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Environment variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>Default value if the specified environment variable does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205c3371a5ac31b772a0b350a025f5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205c3371a5ac31b772a0b350a025f5f9">&#9670;&nbsp;</a></span>SetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SetEnvironment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an environment variable. </p>
<p>If the variable previously existed, its value is overwritten. If it did not exist, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Environment variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Environment variable value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a0a6b50463bf9e942dd7bd8bf23190bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6b50463bf9e942dd7bd8bf23190bf1">&#9670;&nbsp;</a></span>DeleteEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::DeleteEnvironment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an environment variable. </p>
<p>If the variable did not exist, do nothing, do not generate an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Environment variable name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a1663085e6ea259e268bb59923823c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1663085e6ea259e268bb59923823c113">&#9670;&nbsp;</a></span>ExpandEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ExpandEnvironment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand environment variables inside a file path (or any string). </p>
<p>Environment variable references '$name' or '${name}' are replaced by the corresponding values from the environment. In the first form, 'name' is the longest combination of letters, digits and underscore. A combination \$ is interpreted as a literal $, not an environment variable reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A path string containing references to environment variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expanded string. </dd></dl>

</div>
</div>
<a id="a77da99b840fd0e0f3610e490b75314da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77da99b840fd0e0f3610e490b75314da">&#9670;&nbsp;</a></span>GetEnvironment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetEnvironment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a193fcb3d69633d775555333ad51c9cc1">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content of the entire environment (all environment variables). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">env</td><td>An associative container which receives the content of the environment. Each <em>key</em> is the name of an environment variable and the corresponding <em>value</em> is the value of this environment variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dc90f0819fcb22d328d56f707ff3f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc90f0819fcb22d328d56f707ff3f37">&#9670;&nbsp;</a></span>ErrorCodeMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::ErrorCodeMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a>&#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="namespacets.html#aa816d1f04480538021fee6d480570238">LastErrorCode</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format an error code into a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>An error code from the operating system. Typically a result from <a class="el" href="namespacets.html#aa816d1f04480538021fee6d480570238" title="Get the error code of the last operating system call. ">LastErrorCode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error. </dd></dl>

</div>
</div>
<a id="a64cc0b0979e89bf83d62afa726e7d0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cc0b0979e89bf83d62afa726e7d0e3">&#9670;&nbsp;</a></span>GetProcessMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::GetProcessMetrics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structts_1_1_process_metrics.html">ProcessMetrics</a> &amp;&#160;</td>
          <td class="paramname"><em>metrics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get metrics for the current process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">metrics</td><td>Receive the current process metrics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classts_1_1_exception.html" title="Base class for all exceptions in TSDuck. ">ts::Exception</a></td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ab29fca47e41a41feec37fa8317215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab29fca47e41a41feec37fa8317215d">&#9670;&nbsp;</a></span>IgnorePipeSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::IgnorePipeSignal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that writing to a broken pipe does not kill the current process. </p>
<p>On UNIX systems, writing to a <em>broken pipe</em>, i.e. a pipe with no process reading from it, kills the current process. This may not be what you want. This functions prevents this.</p>
<p><b>UNIX Systems:</b> This function ignores SIGPIPE. Writing to a broken pipe will now return an error instead of killing the process.</p>
<p><b>Windows systems:</b> This function does nothing (because there is no need to do anything). </p>

</div>
</div>
<a id="abe79c94e4ddee6770dcf6a43b88c7174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe79c94e4ddee6770dcf6a43b88c7174">&#9670;&nbsp;</a></span>SetBinaryModeStdin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SetBinaryModeStdin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em> = <code>(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the standard input stream in binary mode. </p>
<p>On UNIX systems, this does not make any difference. On Windows systems, however, in a stream which is not open in binary mode, there is automatic translation between LF and CR-LF. The standard input is open in text mode (non-binary). This function forces it into binary mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. If <em>report</em> is a subclass of <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a>, also terminate application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets.html#a507c176a2cc25838661a9674d45dbc2f" title="Put the standard output stream in binary mode. ">SetBinaryModeStdout()</a> </dd></dl>

</div>
</div>
<a id="a507c176a2cc25838661a9674d45dbc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507c176a2cc25838661a9674d45dbc2f">&#9670;&nbsp;</a></span>SetBinaryModeStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::SetBinaryModeStdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em> = <code>(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the standard output stream in binary mode. </p>
<p>On UNIX systems, this does not make any difference. On Windows systems, however, in a stream which is not open in binary mode, there is automatic translation between LF and CR-LF. The standard output is open in text mode (non-binary). This function forces it into binary mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. If <em>report</em> is a subclass of <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a>, also terminate application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets.html#a507c176a2cc25838661a9674d45dbc2f" title="Put the standard output stream in binary mode. ">SetBinaryModeStdout()</a> </dd></dl>

</div>
</div>
<a id="a11de7b466e0fbf2759d7cb1820242130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11de7b466e0fbf2759d7cb1820242130">&#9670;&nbsp;</a></span>ToIntegerDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ts::ToIntegerDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a character representing a multi-base integer digit into the corresponding integer value. </p>
<p>Characters '0'..'9' are converted to 0..9. Characters 'a'..'z' and 'A'..'Z' are converted to 10..35. This function can be used to convert decimal digits, hexadecimal and any other base up to base 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>A character to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The base of the integer representation, must be in the range 2 to 36. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The value to return on invalid character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding integer value or the default value in case of error. </dd></dl>

</div>
</div>
<a id="aedeead29b0f6ee4348b34750bb720dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeead29b0f6ee4348b34750bb720dd2">&#9670;&nbsp;</a></span>ToInteger() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToInteger </td>
          <td>(</td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into an integer. </p>
<p>The input string must contain the representation of an integer value in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. The ToInteger function decodes integer values of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The returned decoded value. On error (invalid string), <em>value</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The C-string to decode, not nul-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of character in the C-string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a8f3271bf4f7fc74063f8ebdc7089a148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3271bf4f7fc74063f8ebdc7089a148">&#9670;&nbsp;</a></span>ToInteger() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToInteger </td>
          <td>(</td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string into an integer. </p>
<p>The input string must contain the representation of an integer value in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. The ToInteger function decodes integer values of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The returned decoded value. On error (invalid string), <em>value</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The C-string to decode. Must be nul-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="aa78ab9da22e14746ce87b385b226ccca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78ab9da22e14746ce87b385b226ccca">&#9670;&nbsp;</a></span>ToInteger() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToInteger </td>
          <td>(</td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string into an integer. </p>
<p>The input string must contain the representation of an integer value in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. The ToInteger function decodes integer values of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The returned decoded value. On error (invalid string), <em>value</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The string to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="ab506bc57d5f6261a6b32aa548cec7c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab506bc57d5f6261a6b32aa548cec7c50">&#9670;&nbsp;</a></span>ToIntegers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToIntegers </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>listSeparators</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string containing a list of integers into a container of integers. </p>
<p>The input string must contain the representation of integer values in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<p>The various integer values in the string are separated using list delimiters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of any integer type as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>The returned decoded values. The previous content of the container is discarded. The integer values are added in the container in the order of the decoded string. On error (invalid string), <em>container</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The C-string to decode, not nul-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of character in the C-string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listSeparators</td><td>A string of characters which are interpreted as list separators. Distinct integer values must be separated by one or more of these separators. <em>Any character</em> from the <em>listSeparators</em> string is interpreted as a separator. Note that this implies that the list separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a1986b0b72815d041b92189026b8b14ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1986b0b72815d041b92189026b8b14ec">&#9670;&nbsp;</a></span>ToIntegers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToIntegers </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>listSeparators</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string containing a list of integers into a container of integers. </p>
<p>The input string must contain the representation of integer values in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<p>The various integer values in the string are separated using list delimiters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of any integer type as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>The returned decoded values. The previous content of the container is discarded. The integer values are added in the container in the order of the decoded string. On error (invalid string), <em>container</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The C-string to decode. Must be nul-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listSeparators</td><td>A string of characters which are interpreted as list separators. Distinct integer values must be separated by one or more of these separators. <em>Any character</em> from the <em>listSeparators</em> string is interpreted as a separator. Note that this implies that the list separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="abe4f9078f7a6ac87b521825fcd115bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4f9078f7a6ac87b521825fcd115bca">&#9670;&nbsp;</a></span>ToIntegers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::ToIntegers </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>listSeparators</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string containing a list of integers into a container of integers. </p>
<p>The input string must contain the representation of integer values in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<p>The various integer values in the string are separated using list delimiters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of any integer type as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>The returned decoded values. The previous content of the container is discarded. The integer values are added in the container in the order of the decoded string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The string to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listSeparators</td><td>A string of characters which are interpreted as list separators. Distinct integer values must be separated by one or more of these separators. <em>Any character</em> from the <em>listSeparators</em> string is interpreted as a separator. Note that this implies that the list separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a3e1dcaccdf30869ae92f04e3c6ff698e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1dcaccdf30869ae92f04e3c6ff698e">&#9670;&nbsp;</a></span>GetTunerFromZapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::GetTunerFromZapFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em> = <code>(*<a class="el" href="classts_1_1_cerr_report.html#ad5fc721c37e1eceab55d90f8c76ff6b6">ts::CerrReport::Instance</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DVB tuner parameters from a Linux zap configuration file. </p>
<p>This method reads a Linux zap configuration file, locate a channel description and sets the <a class="el" href="classts_1_1_tuner_parameters.html" title="Abstract base class for DVB tuners parameters. ">TunerParameters</a> to the values for this channel's transponder.</p>
<p>Since Linux zap configuration files are text files, they can be used on any platform, although they are usually generated on Linux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_name</td><td>Name of the TV channel to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>Name of the file to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameters</td><td>Returned tuner parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a0bc488febbeb2d704f43067d14e1a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc488febbeb2d704f43067d14e1a650">&#9670;&nbsp;</a></span>DecodeDeliveryDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_tuner_parameters.html">TunerParameters</a>* ts::DecodeDeliveryDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_descriptor.html">Descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DVB tuner parameters from a delivery system descriptor. </p>
<p>This method analyzes a delivery system descriptor (satellite, cable or terrestrial) and returns a new tuner parameters object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>A descriptor. Must be a valid delivery system descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated tuner parameters object of the appropriate class. Return 0 if the descriptor was not correctly analyzed or is not a delivery system descriptor. </dd></dl>

</div>
</div>
<a id="a24c8d044d7cd371d0da9fc1043420325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c8d044d7cd371d0da9fc1043420325">&#9670;&nbsp;</a></span>GetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::GetVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa">VersionFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642faaba95baa6c3dc575f82d5ced4879619d7">VERSION_SHORT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>revisionFile</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TSDuck formatted version number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Type of output, short by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">applicationName</td><td>Name of the application to prepend to the long format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revisionFile</td><td>Extract the revision number from this file (use current executable if empty). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted version string. </dd></dl>

</div>
</div>
<a id="aa8bd9929f8fc64be7b9501f3f2a8d49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bd9929f8fc64be7b9501f3f2a8d49d">&#9670;&nbsp;</a></span>GetRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ts::GetRevision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeLibrary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TSDuck revision number as integer from a binary file. </p>
<p>The revision number is in fact the most recent compilation date in the file. The revision number for June 30 2017 is 20170630 for instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Extract the revision number from this file (use current executable if empty). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeLibrary</td><td>If true, also look for revision number in the TSDuck common code shared library in same directory as the specified file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The revision number or zero if not found. </dd></dl>

</div>
</div>
<a id="a4537fb83d538a76bb69656a3d9661ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4537fb83d538a76bb69656a3d9661ad4">&#9670;&nbsp;</a></span>ComVectorRelease()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class COMCLASS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::ComVectorRelease </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt; COMCLASS &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects in a vector (Windows-specific). </p>
<p>Keep vector size (all elements become null pointers). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMCLASS</td><td>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> interface or object class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec</td><td>A vector of <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf42628048bf867b3b2accc46c0e1f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf42628048bf867b3b2accc46c0e1f0e">&#9670;&nbsp;</a></span>ComVectorClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class COMCLASS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::ComVectorClear </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt; COMCLASS &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects in a vector and clear the vector (Windows-specific). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMCLASS</td><td>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> interface or object class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec</td><td>A vector of <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> objects to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a6233f878e3f8be1f5085de80a54a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a6233f878e3f8be1f5085de80a54a2">&#9670;&nbsp;</a></span>ComMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::ComMessage </td>
          <td>(</td>
          <td class="paramtype">::HRESULT&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format the message for a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding message string. </dd></dl>

</div>
</div>
<a id="a71ee0892a7b1dea3452dfad4da4dd769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ee0892a7b1dea3452dfad4da4dd769">&#9670;&nbsp;</a></span>ComSuccess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::ComSuccess </td>
          <td>(</td>
          <td class="paramtype">::HRESULT&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific). </p>
<p>In case of error, report an error message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Application message in case of error. The <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> message is appended to the application message. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if status is success, false if error. </dd></dl>

</div>
</div>
<a id="a14d5810bf9e7895fffa6548f08465661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d5810bf9e7895fffa6548f08465661">&#9670;&nbsp;</a></span>ComSuccess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::ComSuccess </td>
          <td>(</td>
          <td class="paramtype">::HRESULT&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status (Windows-specific). </p>
<p>In case of error, report an error message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Application message in case of error. The <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> message is appended to the application message. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if status is success, false if error. </dd></dl>

</div>
</div>
<a id="a3964d8d1482f927971bb2bd106ec3e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3964d8d1482f927971bb2bd106ec3e0d">&#9670;&nbsp;</a></span>ToString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::ToString </td>
          <td>(</td>
          <td class="paramtype">const ::VARIANT &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string to std::string (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent C++ string or an empty string on error. </dd></dl>

</div>
</div>
<a id="a4e6e0a3b92162a15392c66e5998470a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6e0a3b92162a15392c66e5998470a0">&#9670;&nbsp;</a></span>ToString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::ToString </td>
          <td>(</td>
          <td class="paramtype">const ::BSTR&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string to std::string (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent C++ string or an empty string on error. </dd></dl>

</div>
</div>
<a id="a5f7e96e9a9eef01004dfbdc14431dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7e96e9a9eef01004dfbdc14431dfb3">&#9670;&nbsp;</a></span>ToString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::ToString </td>
          <td>(</td>
          <td class="paramtype">const ::WCHAR *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Unicode string to std::string (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The Unicode string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent C++ string or an empty string on error. </dd></dl>

</div>
</div>
<a id="adea9d40213127e4e3de8890b1737761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea9d40213127e4e3de8890b1737761f">&#9670;&nbsp;</a></span>FormatGUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::FormatGUID </td>
          <td>(</td>
          <td class="paramtype">const ::GUID &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_braces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a GUID as string (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guid</td><td>A GUID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_braces</td><td>If true, add the surrounding braces "{...}". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent string or an empty string on error. </dd></dl>

</div>
</div>
<a id="a4297db0eda62aaabe34c3b7ce24cd438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4297db0eda62aaabe34c3b7ce24cd438">&#9670;&nbsp;</a></span>NameGUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::NameGUID </td>
          <td>(</td>
          <td class="paramtype">const ::GUID &amp;&#160;</td>
          <td class="paramname"><em>guid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a GUID as string and resolve a few known names (Windows-specific). </p>
<p>Warning: Very slow, eat CPU time, use with care. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guid</td><td>A GUID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent string or an empty string on error. </dd></dl>

</div>
</div>
<a id="a32407d90ff51474766cdacd51fdfa695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32407d90ff51474766cdacd51fdfa695">&#9670;&nbsp;</a></span>GetStringPropertyBag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::GetStringPropertyBag </td>
          <td>(</td>
          <td class="paramtype">::IMoniker *&#160;</td>
          <td class="paramname"><em>moniker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::OLECHAR *&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string property from the "property bag" of an object (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">moniker</td><td>Moniker defining the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">property_name</td><td>Name of the property to fetch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The property value. </dd></dl>

</div>
</div>
<a id="a90a8237da12cf198a7d95e872844a9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a8237da12cf198a7d95e872844a9dd">&#9670;&nbsp;</a></span>GetPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::GetPin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#ac7d5a53ca04175acbd22243acc877c7b">PinPtrVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::IBaseFilter *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of pins on a DirectShow filter (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pins</td><td>Returned list of pins. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">filter</td><td>DirectShow filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Bit mask of pin selections from DirectShowPinFilter. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a7c4aa575e4686cea6a7d5db3cfc1981f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4aa575e4686cea6a7d5db3cfc1981f">&#9670;&nbsp;</a></span>ConnectFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::ConnectFilters </td>
          <td>(</td>
          <td class="paramtype">::IGraphBuilder *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::IBaseFilter *&#160;</td>
          <td class="paramname"><em>filter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::IBaseFilter *&#160;</td>
          <td class="paramname"><em>filter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly connect two DirectShow filters using whatever output and input pin (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph</td><td>DirectShow graph builder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">filter1</td><td>DirectShow filter with output pins. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">filter2</td><td>DirectShow filter with input pins. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="acd872cb1364138bbabccd3e41fec9a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd872cb1364138bbabccd3e41fec9a36">&#9670;&nbsp;</a></span>CleanupDownstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::CleanupDownstream </td>
          <td>(</td>
          <td class="paramtype">::IGraphBuilder *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::IBaseFilter *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In a DirectShow filter graph, cleanup everything downstream a specified filter (Windows-specific). </p>
<p>All downstream filters are disconnected and removed from the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph</td><td>DirectShow graph builder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">filter</td><td>DirectShow filter. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="ace175bdc5f4a9125a6d80d9ebf07fc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace175bdc5f4a9125a6d80d9ebf07fc30">&#9670;&nbsp;</a></span>DisplayFilterGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::DisplayFilterGraph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IBaseFilter &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the description of a DirectShow filter graph (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>Output text stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>Start the graph description at this DirectShow filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>Left margin to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If true, display more verbose information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a910fd7399db097ceca4dbf6e37a574f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910fd7399db097ceca4dbf6e37a574f0">&#9670;&nbsp;</a></span>DisplayFilterGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::DisplayFilterGraph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IGraphBuilder &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the description of a DirectShow filter graph (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>Output text stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>DirectShow graph builder. Start the graph description at one arbitray input filter (one with no connected input pin) in the graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>Left margin to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If true, display more verbose information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a4535b34d24a4b5f2883fd921f1625e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4535b34d24a4b5f2883fd921f1625e94">&#9670;&nbsp;</a></span>DisplayDevicesByCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::DisplayDevicesByCategory </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::GUID &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display all devices of the specified category (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>Output text stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">category</td><td>Category of the devices to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>Left margin to display. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the category to display. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="ab101089c688f3dc2d73c9e715242e151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab101089c688f3dc2d73c9e715242e151">&#9670;&nbsp;</a></span>NetworkProviderToTunerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::NetworkProviderToTunerType </td>
          <td>(</td>
          <td class="paramtype">const ::GUID&#160;</td>
          <td class="paramname"><em>provider_clsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a0bfe51c83f30216c9beaac7fc31f96d2">TunerType</a> &amp;&#160;</td>
          <td class="paramname"><em>tuner_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a DirectShow network provider class id into a TSDuck tuner type (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">provider_clsid</td><td>DirectShow network provider class. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tuner_type</td><td>Returned TSDuck tuner type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false if no match is found. </dd></dl>

</div>
</div>
<a id="aa269a8b9ad17a6eb5ef511c2e0286b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa269a8b9ad17a6eb5ef511c2e0286b67">&#9670;&nbsp;</a></span>EnumerateDevicesByClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::EnumerateDevicesByClass </td>
          <td>(</td>
          <td class="paramtype">const ::CLSID &amp;&#160;</td>
          <td class="paramname"><em>clsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classts_1_1_com_ptr.html">ComPtr</a>&lt;::IMoniker &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monikers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all devices of the specified class. </p>
<p>Fill a vector of monikers to these objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clsid</td><td>Device class to enumerate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">monikers</td><td>Returned vector of monikers to all devices of class <em>clsid</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a81ccd6ebc59fc1f9e52a3f47d04194dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ccd6ebc59fc1f9e52a3f47d04194dd">&#9670;&nbsp;</a></span>GetTuningSpaceFriendlyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::GetTuningSpaceFriendlyName </td>
          <td>(</td>
          <td class="paramtype">::ITuningSpace *&#160;</td>
          <td class="paramname"><em>tuning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the user-friendly name of a DirectShow tuning space (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuning</td><td>Tuning space. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuning space name or an empty string on error. </dd></dl>

</div>
</div>
<a id="aeb6df875a157273fabeb7e3d1910e9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6df875a157273fabeb7e3d1910e9f1">&#9670;&nbsp;</a></span>GetTuningSpaceUniqueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::GetTuningSpaceUniqueName </td>
          <td>(</td>
          <td class="paramtype">::ITuningSpace *&#160;</td>
          <td class="paramname"><em>tuning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classts_1_1_report_interface.html">ReportInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique name of a DirectShow tuning space (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuning</td><td>Tuning space. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">report</td><td>Where to report errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuning space name or an empty string on error. </dd></dl>

</div>
</div>
<a id="ac0067d3e29f03a0420c61dfa4dce50f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0067d3e29f03a0420c61dfa4dce50f0">&#9670;&nbsp;</a></span>DeleteMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void ts::DeleteMediaType </td>
          <td>(</td>
          <td class="paramtype">::AM_MEDIA_TYPE *&#160;</td>
          <td class="paramname"><em>media_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a heap-allocated AM_MEDIA_TYPE structure (Windows-specific). </p>
<p>This is useful when calling IEnumMediaTypes::Next as the interface implementation allocates the structures which you must later delete the format block may also be a pointer to an interface to release. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">media_type</td><td>Media type to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5988d10d1b0b9625f1cad0a60b431c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5988d10d1b0b9625f1cad0a60b431c3">&#9670;&nbsp;</a></span>FreeMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void ts::FreeMediaType </td>
          <td>(</td>
          <td class="paramtype">::AM_MEDIA_TYPE &amp;&#160;</td>
          <td class="paramname"><em>media_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an existing media type, ie free resources it holds (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">media_type</td><td>Media type to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4972efcce0a4e6ba9678d3152cdf0387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4972efcce0a4e6ba9678d3152cdf0387">&#9670;&nbsp;</a></span>CopyMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> ::HRESULT ts::CopyMediaType </td>
          <td>(</td>
          <td class="paramtype">::AM_MEDIA_TYPE &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::AM_MEDIA_TYPE &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a media type to another (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Destination media type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source media type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">COM</a> status code. </dd></dl>

</div>
</div>
<a id="a039ec21e77be08c539c60c1c796e4494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039ec21e77be08c539c60c1c796e4494">&#9670;&nbsp;</a></span>InitMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> void ts::InitMediaType </td>
          <td>(</td>
          <td class="paramtype">::AM_MEDIA_TYPE &amp;&#160;</td>
          <td class="paramname"><em>media_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a media type with "null" values (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">media_type</td><td>Destination media type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfec5855785c253a943aa0726bdb39cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfec5855785c253a943aa0726bdb39cd">&#9670;&nbsp;</a></span>GetRegistryValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> std::string ts::GetRegistryValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a value in a registry key as a string (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_name</td><td>Name of the value in <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty string if non-existent or error. </dd></dl>

</div>
</div>
<a id="a311d88ca573af86ea3e127361811fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311d88ca573af86ea3e127361811fd59">&#9670;&nbsp;</a></span>SetRegistryValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::SetRegistryValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expandable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a registry key (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_name</td><td>Name of the value in <em>key</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set in <em>value_name</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expandable</td><td>If true, set the type to REG_EXPAND_SZ. Otherwise, set type to REG_SZ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a573c78d9775369814fbdf0fa1db2ee3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573c78d9775369814fbdf0fa1db2ee3f">&#9670;&nbsp;</a></span>SetRegistryValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::SetRegistryValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::DWORD&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of a registry key (Windows-specific). </p>
<p>Set the data type as REG_DWORD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_name</td><td>Name of the value in <em>key</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set in <em>value_name</em>. Set the data type as REG_DWORD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a8d251d900e34d4b91b91c9dddb1b687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d251d900e34d4b91b91c9dddb1b687f">&#9670;&nbsp;</a></span>DeleteRegistryValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::DeleteRegistryValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a value of a registry key (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_name</td><td>Name of the value in <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="ad527ee2430f46867cba71d2671bcc355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad527ee2430f46867cba71d2671bcc355">&#9670;&nbsp;</a></span>CreateRegistryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::CreateRegistryKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_volatile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a registry key (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_volatile</td><td>If true, create a "volatile" registry key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="afc4bccb473270020c937fc3b92fca3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4bccb473270020c937fc3b92fca3b1">&#9670;&nbsp;</a></span>DeleteRegistryKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::DeleteRegistryKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a registry key (Windows-specific). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Registry key to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a id="a3cbc8576c34486ae43e406b3631121ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbc8576c34486ae43e406b3631121ae">&#9670;&nbsp;</a></span>NotifySettingChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a> bool ts::NotifySettingChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all applications of a setting change (Windows-specific). </p>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7bb82b6cb4a761e4fc84a9b6bc7cca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb82b6cb4a761e4fc84a9b6bc7cca42">&#9670;&nbsp;</a></span>DTA_MAX_IO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::DTA_MAX_IO_SIZE = 6 * 1024 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum I/O size in bytes of DTA devices. </p>
<p>This value is merely an advice, the absolute maximum is the FIFO size. </p>

</div>
</div>
<a id="aa7856250798a1a9f61be7f18869bb10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7856250798a1a9f61be7f18869bb10b">&#9670;&nbsp;</a></span>DTA_MAX_HW_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::DTA_MAX_HW_FUNC = 75</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of "hardware functions" per Dektec device. </p>
<p>A hardware function is one input or output channel for instance. </p><dl class="section see"><dt>See also</dt><dd>DTAPI documentation </dd></dl>

</div>
</div>
<a id="a89aabb15437c766330177f7f4336d894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89aabb15437c766330177f7f4336d894">&#9670;&nbsp;</a></span>MJD_MIN_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::MJD_MIN_SIZE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimal size in bytes of an encoded Modified Julian Date (MJD), ie. </p>
<p>date only. </p>

</div>
</div>
<a id="a1dfcd0a5c6d992829a38268acacd3827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfcd0a5c6d992829a38268acacd3827">&#9670;&nbsp;</a></span>PKT_M2TS_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::PKT_M2TS_SIZE = <a class="el" href="namespacets.html#a8515d4bd016eab6e66aec798058a3647">M2TS_HEADER_SIZE</a> + <a class="el" href="namespacets.html#a29cecff9c6ed61e3cf69a84301b5483b">PKT_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size in bytes of an TS packet in M2TS files (Blu-ray disc). </p>
<p>There is a leading 4-byte timestamp before the TS packet. </p>

</div>
</div>
<a id="a636e5b0b20d954dbf3426647e24799c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636e5b0b20d954dbf3426647e24799c9">&#9670;&nbsp;</a></span>CC_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ts::CC_MASK = 0x0F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to wrap a Continuity Counter (CC) value. </p>
<p>CC values wrap at 16. </p>

</div>
</div>
<a id="a83c4762bb3ca7b93157c4c7dc4f6430a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c4762bb3ca7b93157c4c7dc4f6430a">&#9670;&nbsp;</a></span>SVERSION_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ts::SVERSION_MASK = 0x1F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to wrap a section version value. </p>
<p><a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">Section</a> version values wrap at 32. </p>

</div>
</div>
<a id="a791105205bda054589f97061752ee029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791105205bda054589f97061752ee029">&#9670;&nbsp;</a></span>MJD_EPOCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t ts::MJD_EPOCH = 40587</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Origin of Modified Julian Dates (MJD). </p>
<p>The origin of MJD is 17 Nov 1858 00:00:00. The UNIX epoch (1 Jan 1970) is 40587 days from julian time origin. </p>

</div>
</div>
<a id="a44869d633531ce62b6eb349395334b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44869d633531ce62b6eb349395334b8b">&#9670;&nbsp;</a></span>MACROBLOCK_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::MACROBLOCK_WIDTH = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Video macroblock width in pixels. </p>
<p>Valid for:</p><ul>
<li>ISO 11172-2 (MPEG-1 video)</li>
<li>ISO 13818-2 (MPEG-2 video)</li>
<li>ISO 14496-10 (MPEG-4 Advanced Video Coding, AVC, ITU H.264) </li>
</ul>

</div>
</div>
<a id="a4034991316d5f718760e9cc0d96a6af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4034991316d5f718760e9cc0d96a6af1">&#9670;&nbsp;</a></span>MACROBLOCK_HEIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ts::MACROBLOCK_HEIGHT = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Video macroblock height in pixels. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacets.html#a44869d633531ce62b6eb349395334b8b" title="Video macroblock width in pixels. ">MACROBLOCK_WIDTH</a> </dd></dl>

</div>
</div>
<a id="a5c31a3d1b0122eb8863cc6feaef7df44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c31a3d1b0122eb8863cc6feaef7df44">&#9670;&nbsp;</a></span>SYS_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::SYS_SUCCESS = platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating success. </p>
<p>It is not guaranteed that this value is the <em>only</em> success value. Operating system calls which complete successfully may also return other values. </p>

</div>
</div>
<a id="a67013ae18c714713055aa25de3a24568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67013ae18c714713055aa25de3a24568">&#9670;&nbsp;</a></span>SYS_DATA_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> ts::SYS_DATA_ERROR = platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating a generic data error. </p>
<p>This value can be used to initialize an error code to some generic error code indicating that a data is not yet available or an operation is not yet performed. </p>

</div>
</div>
<a id="ab772207b2b6d2c9383cf2ede5069ee5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772207b2b6d2c9383cf2ede5069ee5d">&#9670;&nbsp;</a></span>EmptyPacket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structts_1_1_t_s_packet.html">TSPacket</a> ts::EmptyPacket</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constant is an empty packet (no payload). </p>
<p>PID and CC shall be updated for use in specific PID's. </p>

</div>
</div>
<a id="a4afcbbc5e6e8a897709aa196e0b87559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afcbbc5e6e8a897709aa196e0b87559">&#9670;&nbsp;</a></span>VersionFormatEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classts_1_1_enumeration.html">Enumeration</a> ts::VersionFormatEnum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">Enumeration</a> description of <a class="el" href="namespacets.html#a3b76963ba3c3e6d12b29fc10bd4642fa" title="Types of version formatting, for predefined option –version. ">ts::VersionFormat</a>. </p>
<p>Typically used to implement the --version command line option. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
