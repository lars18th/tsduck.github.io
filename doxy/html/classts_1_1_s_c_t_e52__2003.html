<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: ts::SCTE52_2003 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.11-717</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classts_1_1_s_c_t_e52__2003.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classts_1_1_s_c_t_e52__2003-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ts::SCTE52_2003 Class Reference<div class="ingroups"><a class="el" href="group__crypto.html">Cryptography</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ANSI/SCTE 52 2003 DES-based TS packet encryption.  
 <a href="classts_1_1_s_c_t_e52__2003.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ts::SCTE52_2003:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_s_c_t_e52__2003__inherit__graph.png" border="0" usemap="#ts_1_1_s_c_t_e52__2003_inherit__map" alt="Inheritance graph"/></div>
<map name="ts_1_1_s_c_t_e52__2003_inherit__map" id="ts_1_1_s_c_t_e52__2003_inherit__map">
<area shape="rect" id="node2" href="classts_1_1_d_v_s042.html" title="ts::DVS042\&lt; DES \&gt;" alt="" coords="28,239,167,264"/>
<area shape="rect" id="node3" href="classts_1_1_cipher_chaining_template.html" title="ts::CipherChainingTemplate\l\&lt; DES \&gt;" alt="" coords="5,152,190,191"/>
<area shape="rect" id="node4" href="classts_1_1_cipher_chaining.html" title="Base class of all cipher chaining modes. " alt="" coords="32,79,163,104"/>
<area shape="rect" id="node5" href="classts_1_1_block_cipher.html" title="Abstract interface of block ciphers. " alt="" coords="42,5,153,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ts::SCTE52_2003:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_s_c_t_e52__2003__coll__graph.png" border="0" usemap="#ts_1_1_s_c_t_e52__2003_coll__map" alt="Collaboration graph"/></div>
<map name="ts_1_1_s_c_t_e52__2003_coll__map" id="ts_1_1_s_c_t_e52__2003_coll__map">
<area shape="rect" id="node2" href="classts_1_1_d_v_s042.html" title="ts::DVS042\&lt; DES \&gt;" alt="" coords="92,355,231,380"/>
<area shape="rect" id="node3" href="classts_1_1_cipher_chaining_template.html" title="ts::CipherChainingTemplate\l\&lt; DES \&gt;" alt="" coords="5,267,190,305"/>
<area shape="rect" id="node4" href="classts_1_1_cipher_chaining.html" title="Base class of all cipher chaining modes. " alt="" coords="44,180,175,205"/>
<area shape="rect" id="node5" href="classts_1_1_block_cipher.html" title="Abstract interface of block ciphers. " alt="" coords="25,80,136,105"/>
<area shape="rect" id="node6" href="classts_1_1_byte_block.html" title="Definition of a generic block of bytes. " alt="" coords="167,80,266,105"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab634875a69c75261ac254bb695d3b2ca"><td class="memItemLeft" align="right" valign="top"><a id="ab634875a69c75261ac254bb695d3b2ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_c_t_e52__2003.html#ab634875a69c75261ac254bb695d3b2ca">SCTE52_2003</a> ()</td></tr>
<tr class="memdesc:ab634875a69c75261ac254bb695d3b2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ab634875a69c75261ac254bb695d3b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292212d99a48214146b7bacba10d0fb9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a292212d99a48214146b7bacba10d0fb9">blockSize</a> () const override</td></tr>
<tr class="memdesc:a292212d99a48214146b7bacba10d0fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the block used by the algorithm.  <a href="#a292212d99a48214146b7bacba10d0fb9">More...</a><br /></td></tr>
<tr class="separator:a292212d99a48214146b7bacba10d0fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f47c3c92a8438c26bbc4dc9a70d782"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#ac8f47c3c92a8438c26bbc4dc9a70d782">decrypt</a> (const void *cipher, size_t cipher_length, void *plain, size_t plain_maxsize, size_t *plain_length=0) override</td></tr>
<tr class="memdesc:ac8f47c3c92a8438c26bbc4dc9a70d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt one block of data.  <a href="#ac8f47c3c92a8438c26bbc4dc9a70d782">More...</a><br /></td></tr>
<tr class="separator:ac8f47c3c92a8438c26bbc4dc9a70d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e560b1b26c8c906cc4b507c7a3318bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_block_cipher.html#a3e560b1b26c8c906cc4b507c7a3318bf">decryptInPlace</a> (void *data, size_t data_length, size_t *max_actual_length=0)</td></tr>
<tr class="memdesc:a3e560b1b26c8c906cc4b507c7a3318bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt one block of data in place.  <a href="#a3e560b1b26c8c906cc4b507c7a3318bf">More...</a><br /></td></tr>
<tr class="separator:a3e560b1b26c8c906cc4b507c7a3318bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1daf9e41ef2f75a667fddc60b374dd"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a1f1daf9e41ef2f75a667fddc60b374dd">defaultRounds</a> () const override</td></tr>
<tr class="memdesc:a1f1daf9e41ef2f75a667fddc60b374dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of rounds for the algorithm.  <a href="#a1f1daf9e41ef2f75a667fddc60b374dd">More...</a><br /></td></tr>
<tr class="separator:a1f1daf9e41ef2f75a667fddc60b374dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab35616368408546c3f5e5d392eb1d5e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#aab35616368408546c3f5e5d392eb1d5e">encrypt</a> (const void *plain, size_t plain_length, void *cipher, size_t cipher_maxsize, size_t *cipher_length=0) override</td></tr>
<tr class="memdesc:aab35616368408546c3f5e5d392eb1d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt one block of data.  <a href="#aab35616368408546c3f5e5d392eb1d5e">More...</a><br /></td></tr>
<tr class="separator:aab35616368408546c3f5e5d392eb1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e7ab6b0558bed387fb3e7ff01db7a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_block_cipher.html#a76e7ab6b0558bed387fb3e7ff01db7a8">encryptInPlace</a> (void *data, size_t data_length, size_t *max_actual_length=0)</td></tr>
<tr class="memdesc:a76e7ab6b0558bed387fb3e7ff01db7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt one block of data in place.  <a href="#a76e7ab6b0558bed387fb3e7ff01db7a8">More...</a><br /></td></tr>
<tr class="separator:a76e7ab6b0558bed387fb3e7ff01db7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86de9dfc56b07e635875592892f2a2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#aba86de9dfc56b07e635875592892f2a2">isValidKeySize</a> (size_t size) const override</td></tr>
<tr class="memdesc:aba86de9dfc56b07e635875592892f2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a size in bytes is a valid key size.  <a href="#aba86de9dfc56b07e635875592892f2a2">More...</a><br /></td></tr>
<tr class="separator:aba86de9dfc56b07e635875592892f2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc8535776f3b6cf2874f65f5db615e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#ac3bc8535776f3b6cf2874f65f5db615e">maxIVSize</a> () const</td></tr>
<tr class="memdesc:ac3bc8535776f3b6cf2874f65f5db615e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum IV sizes in bytes.  <a href="#ac3bc8535776f3b6cf2874f65f5db615e">More...</a><br /></td></tr>
<tr class="separator:ac3bc8535776f3b6cf2874f65f5db615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d8774b302e9915f99e53dbe2b9cd2f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#ad2d8774b302e9915f99e53dbe2b9cd2f">maxKeySize</a> () const override</td></tr>
<tr class="memdesc:ad2d8774b302e9915f99e53dbe2b9cd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum key sizes in bytes.  <a href="#ad2d8774b302e9915f99e53dbe2b9cd2f">More...</a><br /></td></tr>
<tr class="separator:ad2d8774b302e9915f99e53dbe2b9cd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086d6fae6f3422e9e549aefdaab7d331"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a086d6fae6f3422e9e549aefdaab7d331">maxRounds</a> () const override</td></tr>
<tr class="memdesc:a086d6fae6f3422e9e549aefdaab7d331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of rounds for the algorithm.  <a href="#a086d6fae6f3422e9e549aefdaab7d331">More...</a><br /></td></tr>
<tr class="separator:a086d6fae6f3422e9e549aefdaab7d331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325f3c779715cf9489b250e1f56294b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a8325f3c779715cf9489b250e1f56294b">minIVSize</a> () const</td></tr>
<tr class="memdesc:a8325f3c779715cf9489b250e1f56294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum IV sizes in bytes.  <a href="#a8325f3c779715cf9489b250e1f56294b">More...</a><br /></td></tr>
<tr class="separator:a8325f3c779715cf9489b250e1f56294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c2eeaf3d8a4396c8cb026a79517e49"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a84c2eeaf3d8a4396c8cb026a79517e49">minKeySize</a> () const override</td></tr>
<tr class="memdesc:a84c2eeaf3d8a4396c8cb026a79517e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum key sizes in bytes.  <a href="#a84c2eeaf3d8a4396c8cb026a79517e49">More...</a><br /></td></tr>
<tr class="separator:a84c2eeaf3d8a4396c8cb026a79517e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cd002a917fefb3983172e7304f121"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#af03cd002a917fefb3983172e7304f121">minMessageSize</a> () const override</td></tr>
<tr class="memdesc:af03cd002a917fefb3983172e7304f121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum message size.  <a href="#af03cd002a917fefb3983172e7304f121">More...</a><br /></td></tr>
<tr class="separator:af03cd002a917fefb3983172e7304f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6440d21660ced2a68a5eece499c681"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a0b6440d21660ced2a68a5eece499c681">minRounds</a> () const override</td></tr>
<tr class="memdesc:a0b6440d21660ced2a68a5eece499c681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum number of rounds for the algorithm.  <a href="#a0b6440d21660ced2a68a5eece499c681">More...</a><br /></td></tr>
<tr class="separator:a0b6440d21660ced2a68a5eece499c681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b187f3d4e63b26907876a80d4b5a7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_s_c_t_e52__2003.html#aa2b187f3d4e63b26907876a80d4b5a7a">name</a> () const override</td></tr>
<tr class="memdesc:aa2b187f3d4e63b26907876a80d4b5a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm name (informational only).  <a href="#aa2b187f3d4e63b26907876a80d4b5a7a">More...</a><br /></td></tr>
<tr class="separator:aa2b187f3d4e63b26907876a80d4b5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447054574857d438a2bf5c07bf65bdb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#a5447054574857d438a2bf5c07bf65bdb">residueAllowed</a> () const override</td></tr>
<tr class="memdesc:a5447054574857d438a2bf5c07bf65bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the chaining mode can process residue after the last multiple of the block size.  <a href="#a5447054574857d438a2bf5c07bf65bdb">More...</a><br /></td></tr>
<tr class="separator:a5447054574857d438a2bf5c07bf65bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f888d0a082c1020b91635f086fc3ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#ae5f888d0a082c1020b91635f086fc3ed">setIV</a> (const void *<a class="el" href="classts_1_1_cipher_chaining.html#af057b5694ca7fd5a01d0fcc94f4344f2">iv</a>, size_t iv_length) override</td></tr>
<tr class="memdesc:ae5f888d0a082c1020b91635f086fc3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new initialization vector.  <a href="#ae5f888d0a082c1020b91635f086fc3ed">More...</a><br /></td></tr>
<tr class="separator:ae5f888d0a082c1020b91635f086fc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc948d4c651ec7931971ba4838f1874e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#adc948d4c651ec7931971ba4838f1874e">setKey</a> (const void *key, size_t key_length, size_t rounds=0) override</td></tr>
<tr class="memdesc:adc948d4c651ec7931971ba4838f1874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a new key.  <a href="#adc948d4c651ec7931971ba4838f1874e">More...</a><br /></td></tr>
<tr class="separator:adc948d4c651ec7931971ba4838f1874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5ccb20cd987f3b4f6f52d2b9058c1d39"><td class="memItemLeft" align="right" valign="top"><a id="a5ccb20cd987f3b4f6f52d2b9058c1d39"></a>
<a class="el" href="classts_1_1_block_cipher.html">BlockCipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a5ccb20cd987f3b4f6f52d2b9058c1d39">algo</a></td></tr>
<tr class="memdesc:a5ccb20cd987f3b4f6f52d2b9058c1d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of the block cipher. <br /></td></tr>
<tr class="separator:a5ccb20cd987f3b4f6f52d2b9058c1d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b1c77ea30a6007449230c039a3ab4"><td class="memItemLeft" align="right" valign="top"><a id="a5d8b1c77ea30a6007449230c039a3ab4"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a5d8b1c77ea30a6007449230c039a3ab4">block_size</a></td></tr>
<tr class="memdesc:a5d8b1c77ea30a6007449230c039a3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for algo-&gt;<a class="el" href="classts_1_1_cipher_chaining.html#a292212d99a48214146b7bacba10d0fb9" title="Size in bytes of the block used by the algorithm. ">blockSize()</a>. <br /></td></tr>
<tr class="separator:a5d8b1c77ea30a6007449230c039a3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af057b5694ca7fd5a01d0fcc94f4344f2"><td class="memItemLeft" align="right" valign="top"><a id="af057b5694ca7fd5a01d0fcc94f4344f2"></a>
<a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#af057b5694ca7fd5a01d0fcc94f4344f2">iv</a></td></tr>
<tr class="memdesc:af057b5694ca7fd5a01d0fcc94f4344f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current initialization vector. <br /></td></tr>
<tr class="separator:af057b5694ca7fd5a01d0fcc94f4344f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0ba8e5f0958c0ab5217ff03efd79c1"><td class="memItemLeft" align="right" valign="top"><a id="a2f0ba8e5f0958c0ab5217ff03efd79c1"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#a2f0ba8e5f0958c0ab5217ff03efd79c1">iv_max_size</a></td></tr>
<tr class="memdesc:a2f0ba8e5f0958c0ab5217ff03efd79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">IV max size in bytes. <br /></td></tr>
<tr class="separator:a2f0ba8e5f0958c0ab5217ff03efd79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af135ca34ee98eca91bbea7ea836c48e6"><td class="memItemLeft" align="right" valign="top"><a id="af135ca34ee98eca91bbea7ea836c48e6"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#af135ca34ee98eca91bbea7ea836c48e6">iv_min_size</a></td></tr>
<tr class="memdesc:af135ca34ee98eca91bbea7ea836c48e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">IV min size in bytes. <br /></td></tr>
<tr class="separator:af135ca34ee98eca91bbea7ea836c48e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcaeb00a2cf3999cd046f09abda5eac"><td class="memItemLeft" align="right" valign="top"><a id="a3fcaeb00a2cf3999cd046f09abda5eac"></a>
<a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_d_v_s042.html#a3fcaeb00a2cf3999cd046f09abda5eac">shortIV</a></td></tr>
<tr class="memdesc:a3fcaeb00a2cf3999cd046f09abda5eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current initialization vector for short blocks. <br /></td></tr>
<tr class="separator:a3fcaeb00a2cf3999cd046f09abda5eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd340d96eb6830df7d04260a261588"><td class="memItemLeft" align="right" valign="top"><a id="aa0fd340d96eb6830df7d04260a261588"></a>
<a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_cipher_chaining.html#aa0fd340d96eb6830df7d04260a261588">work</a></td></tr>
<tr class="memdesc:aa0fd340d96eb6830df7d04260a261588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary working buffer. <br /></td></tr>
<tr class="separator:aa0fd340d96eb6830df7d04260a261588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ANSI/SCTE 52 2003 DES-based TS packet encryption. </p>
<p>DVS 042 has been renamed as "ANSI/SCTE 52 2003". The next iteration of this standard is "ANSI/SCTE 52 2008". The only difference between the two versions is the handling of messages shorter than the block size. In the 2003 (DVS 042) version, the same IV (called "whitener" in the standard) is used for long and short messages. In the 2008 version, a different "whitener2" must be used for messages shorter than the block size. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2b187f3d4e63b26907876a80d4b5a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b187f3d4e63b26907876a80d4b5a7a">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classts_1_1_u_string.html">UString</a> ts::SCTE52_2003::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Algorithm name (informational only). </p>
<dl class="section return"><dt>Returns</dt><dd>The algorithm name. </dd></dl>

<p>Reimplemented from <a class="el" href="classts_1_1_d_v_s042.html#a0ab26ae011c296a1cc31ed3db9440e56">ts::DVS042&lt; DES &gt;</a>.</p>

</div>
</div>
<a id="af03cd002a917fefb3983172e7304f121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03cd002a917fefb3983172e7304f121">&#9670;&nbsp;</a></span>minMessageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classts_1_1_d_v_s042.html">ts::DVS042</a>&lt; <a class="el" href="classts_1_1_d_e_s.html">DES</a>  &gt;::minMessageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum message size. </p>
<p>Shorter data cannot be ciphered in this mode. </p><dl class="section return"><dt>Returns</dt><dd>The minimum message size. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_cipher_chaining.html#ac67f57099f61892539ddf7f900b69da6">ts::CipherChaining</a>.</p>

</div>
</div>
<a id="a5447054574857d438a2bf5c07bf65bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5447054574857d438a2bf5c07bf65bdb">&#9670;&nbsp;</a></span>residueAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classts_1_1_d_v_s042.html">ts::DVS042</a>&lt; <a class="el" href="classts_1_1_d_e_s.html">DES</a>  &gt;::residueAllowed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the chaining mode can process residue after the last multiple of the block size. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the chaining mode can process residue after the last multiple of the block size. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_cipher_chaining.html#ae94f23e887bcaff45eb4c736ca045776">ts::CipherChaining</a>.</p>

</div>
</div>
<a id="ae5f888d0a082c1020b91635f086fc3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f888d0a082c1020b91635f086fc3ed">&#9670;&nbsp;</a></span>setIV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classts_1_1_d_v_s042.html">ts::DVS042</a>&lt; <a class="el" href="classts_1_1_d_e_s.html">DES</a>  &gt;::setIV </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iv_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new initialization vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Address of IV. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv_length</td><td>IV length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Reimplemented from <a class="el" href="classts_1_1_cipher_chaining.html#a018fc2acb10778eee7b5bf79361159ce">ts::CipherChaining</a>.</p>

</div>
</div>
<a id="aab35616368408546c3f5e5d392eb1d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab35616368408546c3f5e5d392eb1d5e">&#9670;&nbsp;</a></span>encrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classts_1_1_d_v_s042.html">ts::DVS042</a>&lt; <a class="el" href="classts_1_1_d_e_s.html">DES</a>  &gt;::encrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>plain_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cipher_maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cipher_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt one block of data. </p>
<p>For pure block ciphers such as <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">AES</a> or <a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">DES</a>, the plain text and cipher text must have the block size of the algorithm. For cipher chainings, the acceptable message sizes depend on the chaining mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>Address of plain text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain_length</td><td>Plain text length in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cipher</td><td>Address of buffer for cipher text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cipher_maxsize</td><td>Size of <em>cipher</em> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cipher_length</td><td>Returned actual size of cipher text. Ignored if zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#ae4dbd6ee08d2e2d37f881f109d316fe0">ts::BlockCipher</a>.</p>

</div>
</div>
<a id="ac8f47c3c92a8438c26bbc4dc9a70d782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f47c3c92a8438c26bbc4dc9a70d782">&#9670;&nbsp;</a></span>decrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classts_1_1_d_v_s042.html">ts::DVS042</a>&lt; <a class="el" href="classts_1_1_d_e_s.html">DES</a>  &gt;::decrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cipher_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>plain_maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>plain_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt one block of data. </p>
<p>For pure block ciphers such as <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">AES</a> or <a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">DES</a>, the plain text and cipher text must have the block size of the algorithm. For cipher chainings, the acceptable message sizes depend on the chaining mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cipher</td><td>Address of cipher text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cipher_length</td><td>Cipher text length in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plain</td><td>Address of buffer for plain text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain_maxsize</td><td>Size of <em>plain</em> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plain_length</td><td>Returned actual size of plain text. Ignored if zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#a4f5fa4cf33d98d9d249a0aa803e577cf">ts::BlockCipher</a>.</p>

</div>
</div>
<a id="a292212d99a48214146b7bacba10d0fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292212d99a48214146b7bacba10d0fb9">&#9670;&nbsp;</a></span>blockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::blockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of the block used by the algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the block used by the algorithm. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#aa7d8372bd82068868f9925cbc78ea9f1">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a542f9de54b94312041f7f2818d16cea2">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a84c2eeaf3d8a4396c8cb026a79517e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c2eeaf3d8a4396c8cb026a79517e49">&#9670;&nbsp;</a></span>minKeySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::minKeySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum key sizes in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum key sizes in bytes. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#ad63fb12dfb541fc587ec8f936d184281">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a582030943ca251f1742d25644bc5eb4b">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="ad2d8774b302e9915f99e53dbe2b9cd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d8774b302e9915f99e53dbe2b9cd2f">&#9670;&nbsp;</a></span>maxKeySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::maxKeySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum key sizes in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum key sizes in bytes. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#a292f5bf8aa9d88721dd86c249db44d21">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#ab1878755fa3c709fef8ae87d7ab8ee18">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="aba86de9dfc56b07e635875592892f2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86de9dfc56b07e635875592892f2a2">&#9670;&nbsp;</a></span>isValidKeySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ts::CipherChaining::isValidKeySize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a size in bytes is a valid key size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Suggested key size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>size</em> is a valid key size for the algorithm. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#a9a0800da419889257151ea1fb1bb82b3">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a361c840277d22493f238513b77c7668d">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a0b6440d21660ced2a68a5eece499c681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6440d21660ced2a68a5eece499c681">&#9670;&nbsp;</a></span>minRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::minRounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum number of rounds for the algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum number of rounds for the algorithm. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#ad0459f80f351298a7ec9c20ed5afa988">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a70e3041bbdb06bdfca4758c45d853ff4">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a086d6fae6f3422e9e549aefdaab7d331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086d6fae6f3422e9e549aefdaab7d331">&#9670;&nbsp;</a></span>maxRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::maxRounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of rounds for the algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of rounds for the algorithm. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#a1692084a0aad853d1f7852400db7d944">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a8aa62ebd5381284683acd700985e3de9">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a1f1daf9e41ef2f75a667fddc60b374dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1daf9e41ef2f75a667fddc60b374dd">&#9670;&nbsp;</a></span>defaultRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::defaultRounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default number of rounds for the algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>The default number of rounds for the algorithm. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#aa97dbd9df614bb0cd4ae5528266a5f92">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a223139f94f285df75c9b195e7093bf36">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="adc948d4c651ec7931971ba4838f1874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc948d4c651ec7931971ba4838f1874e">&#9670;&nbsp;</a></span>setKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ts::CipherChaining::setKey </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule a new key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Address of key value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_length</td><td>Key length in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rounds</td><td>Requested number of rounds. If zero, the default is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Implements <a class="el" href="classts_1_1_block_cipher.html#a74f8c0fe8774363de8a9b3982352f32a">ts::BlockCipher</a>.</p>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a5811e51ec2a3df44f64eb059e19fbf54">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a8325f3c779715cf9489b250e1f56294b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8325f3c779715cf9489b250e1f56294b">&#9670;&nbsp;</a></span>minIVSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::minIVSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum IV sizes in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum IV sizes in bytes. </dd></dl>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a8ee93eaea26319d6e7a10112965cf4bb">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="ac3bc8535776f3b6cf2874f65f5db615e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bc8535776f3b6cf2874f65f5db615e">&#9670;&nbsp;</a></span>maxIVSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t ts::CipherChaining::maxIVSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum IV sizes in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum IV sizes in bytes. </dd></dl>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#ad6061c5a25075126e1a2496e8b9115b8">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a76e7ab6b0558bed387fb3e7ff01db7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e7ab6b0558bed387fb3e7ff01db7a8">&#9670;&nbsp;</a></span>encryptInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ts::BlockCipher::encryptInPlace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>max_actual_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt one block of data in place. </p>
<p>The default implementation is to call <a class="el" href="classts_1_1_d_v_s042.html#aab35616368408546c3f5e5d392eb1d5e" title="Encrypt one block of data. ">encrypt()</a> and copy the data. A subclass may provide a more efficient implementation.</p>
<p>For pure block ciphers such as <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">AES</a> or <a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">DES</a>, the plain text and cipher text must have the block size of the algorithm. For cipher chainings, the acceptable message sizes depend on the chaining mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of data buffer to encrypt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>Input plain text length in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">max_actual_length</td><td>Optional, ignored if zero. On input, contain the maximum size of the data buffer, which can be larger than <em>data_length</em>. On output, receive the actual size of the encrypted data. For pure block ciphers, this is the same as <em>data_length</em>. For cipher chainings with padding, this can be larger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#a13ff14abaff83e5a8c4ba9331ff55142">ts::DVBCSA2</a>.</p>

</div>
</div>
<a id="a3e560b1b26c8c906cc4b507c7a3318bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e560b1b26c8c906cc4b507c7a3318bf">&#9670;&nbsp;</a></span>decryptInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ts::BlockCipher::decryptInPlace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>max_actual_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt one block of data in place. </p>
<p>The default implementation is to call <a class="el" href="classts_1_1_d_v_s042.html#ac8f47c3c92a8438c26bbc4dc9a70d782" title="Decrypt one block of data. ">decrypt()</a> and copy the data. A subclass may provide a more efficient implementation.</p>
<p>For pure block ciphers such as <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">AES</a> or <a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">DES</a>, the plain text and cipher text must have the block size of the algorithm. For cipher chainings, the acceptable message sizes depend on the chaining mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of data buffer to decrypt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>Input cipher text length in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">max_actual_length</td><td>Optional, ignored if zero. On input, contain the maximum size of the data buffer, which can be larger than <em>data_length</em>. On output, receive the actual size of the decrypted data. For pure block ciphers, this is the same as <em>data_length</em>. For cipher chainings with padding, this can be smaller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

<p>Reimplemented in <a class="el" href="classts_1_1_d_v_b_c_s_a2.html#ab58d8975fb32d372c35492e69948b58d">ts::DVBCSA2</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ts_s_c_t_e52_8h.html">tsSCTE52.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
