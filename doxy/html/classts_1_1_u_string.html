<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: ts::UString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.4</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classts_1_1_u_string.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classts_1_1_u_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ts::UString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of UTF-16 strings.  
 <a href="classts_1_1_u_string.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ts::UString:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_u_string__inherit__graph.png" border="0" usemap="#ts_1_1_u_string_inherit__map" alt="Inheritance graph"/></div>
<map name="ts_1_1_u_string_inherit__map" id="ts_1_1_u_string_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ts::UString:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_u_string__coll__graph.png" border="0" usemap="#ts_1_1_u_string_coll__map" alt="Collaboration graph"/></div>
<map name="ts_1_1_u_string_coll__map" id="ts_1_1_u_string_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee7ce465657a81ff26b97df471188cb0"><td class="memItemLeft" align="right" valign="top"><a id="aee7ce465657a81ff26b97df471188cb0"></a>
typedef std::u16string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a></td></tr>
<tr class="memdesc:aee7ce465657a81ff26b97df471188cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit reference to superclass. <br /></td></tr>
<tr class="separator:aee7ce465657a81ff26b97df471188cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9e07e631d13a10229b5eb840339efd7"><td class="memItemLeft" align="right" valign="top"><a id="ac9e07e631d13a10229b5eb840339efd7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac9e07e631d13a10229b5eb840339efd7">UString</a> () noexcept(noexcept(allocator_type()))</td></tr>
<tr class="memdesc:ac9e07e631d13a10229b5eb840339efd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac9e07e631d13a10229b5eb840339efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31440c72d769f58289151ad46f7513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7a31440c72d769f58289151ad46f7513">UString</a> (const allocator_type &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a7a31440c72d769f58289151ad46f7513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using an allocator.  <a href="#a7a31440c72d769f58289151ad46f7513">More...</a><br /></td></tr>
<tr class="separator:a7a31440c72d769f58289151ad46f7513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac9b39ae35147d3c1db888a0ed4ec603b">UString</a> (const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;other)</td></tr>
<tr class="memdesc:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac9b39ae35147d3c1db888a0ed4ec603b">More...</a><br /></td></tr>
<tr class="separator:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab3bc5c2b2f8ad7532406fbee57ccf958">UString</a> (<a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab3bc5c2b2f8ad7532406fbee57ccf958">More...</a><br /></td></tr>
<tr class="separator:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da08e8b553dee75af9516c03207146"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad4da08e8b553dee75af9516c03207146">UString</a> (size_type count, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> ch, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:ad4da08e8b553dee75af9516c03207146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a repetition of the same character.  <a href="#ad4da08e8b553dee75af9516c03207146">More...</a><br /></td></tr>
<tr class="separator:ad4da08e8b553dee75af9516c03207146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#acbe1d201f0c6f3cdf175442ca3c2190b">UString</a> (const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;other, size_type pos, size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a substring.  <a href="#acbe1d201f0c6f3cdf175442ca3c2190b">More...</a><br /></td></tr>
<tr class="separator:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb04716b7d224778c26c725ab4ea578"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1bb04716b7d224778c26c725ab4ea578">UString</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *s, size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1bb04716b7d224778c26c725ab4ea578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a Unicode string.  <a href="#a1bb04716b7d224778c26c725ab4ea578">More...</a><br /></td></tr>
<tr class="separator:a1bb04716b7d224778c26c725ab4ea578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a34703f374f7946dc6e29591b330ae8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1a34703f374f7946dc6e29591b330ae8">UString</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *s, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1a34703f374f7946dc6e29591b330ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a null-terminated Unicode string.  <a href="#a1a34703f374f7946dc6e29591b330ae8">More...</a><br /></td></tr>
<tr class="separator:a1a34703f374f7946dc6e29591b330ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff90a3d47d9103fc41846448834a7dd"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9ff90a3d47d9103fc41846448834a7dd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9ff90a3d47d9103fc41846448834a7dd">UString</a> (InputIt first, InputIt last, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a9ff90a3d47d9103fc41846448834a7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from iterators.  <a href="#a9ff90a3d47d9103fc41846448834a7dd">More...</a><br /></td></tr>
<tr class="separator:a9ff90a3d47d9103fc41846448834a7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa2ef21f8e1a9ac503c71375b8dbe0aa2">UString</a> (std::initializer_list&lt; <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> &gt; init, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an initializer list.  <a href="#aa2ef21f8e1a9ac503c71375b8dbe0aa2">More...</a><br /></td></tr>
<tr class="separator:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0de87d27027309dee3f54df1f53441"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#acd0de87d27027309dee3f54df1f53441">UString</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:acd0de87d27027309dee3f54df1f53441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#acd0de87d27027309dee3f54df1f53441">More...</a><br /></td></tr>
<tr class="separator:acd0de87d27027309dee3f54df1f53441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2599922bec48046341619bc9f7cb92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#adc2599922bec48046341619bc9f7cb92">UString</a> (const char *utf8)</td></tr>
<tr class="memdesc:adc2599922bec48046341619bc9f7cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#adc2599922bec48046341619bc9f7cb92">More...</a><br /></td></tr>
<tr class="separator:adc2599922bec48046341619bc9f7cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88905c4e822ed8b392d0e00a44f2324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af88905c4e822ed8b392d0e00a44f2324">UString</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:af88905c4e822ed8b392d0e00a44f2324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#af88905c4e822ed8b392d0e00a44f2324">More...</a><br /></td></tr>
<tr class="separator:af88905c4e822ed8b392d0e00a44f2324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee876ece8dca88451f3a0ceefc503c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9ee876ece8dca88451f3a0ceefc503c5">assignFromUTF8</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:a9ee876ece8dca88451f3a0ceefc503c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a9ee876ece8dca88451f3a0ceefc503c5">More...</a><br /></td></tr>
<tr class="separator:a9ee876ece8dca88451f3a0ceefc503c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967764daaa4aff678e7cc605a6cd1ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a967764daaa4aff678e7cc605a6cd1ed5">assignFromUTF8</a> (const char *utf8)</td></tr>
<tr class="memdesc:a967764daaa4aff678e7cc605a6cd1ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a967764daaa4aff678e7cc605a6cd1ed5">More...</a><br /></td></tr>
<tr class="separator:a967764daaa4aff678e7cc605a6cd1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f4081accc66418dfe274215e04dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a164f4081accc66418dfe274215e04dba">assignFromUTF8</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:a164f4081accc66418dfe274215e04dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a164f4081accc66418dfe274215e04dba">More...</a><br /></td></tr>
<tr class="separator:a164f4081accc66418dfe274215e04dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7c84148d5f72c940a9f9c6fe51c5e956">containSimilar</a> (const CONTAINER &amp;container) const</td></tr>
<tr class="memdesc:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a container of strings contains something similar to this string.  <a href="#a7c84148d5f72c940a9f9c6fe51c5e956">More...</a><br /></td></tr>
<tr class="separator:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b4570240cab5a86adf85009203df07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a18b4570240cab5a86adf85009203df07">convertToHTML</a> ()</td></tr>
<tr class="memdesc:a18b4570240cab5a86adf85009203df07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string into a suitable HTML representation.  <a href="#a18b4570240cab5a86adf85009203df07">More...</a><br /></td></tr>
<tr class="separator:a18b4570240cab5a86adf85009203df07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656525cfdf23336f2a01948af3503a5"><td class="memItemLeft" align="right" valign="top"><a id="a1656525cfdf23336f2a01948af3503a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1656525cfdf23336f2a01948af3503a5">convertToLower</a> ()</td></tr>
<tr class="memdesc:a1656525cfdf23336f2a01948af3503a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string to lower-case. <br /></td></tr>
<tr class="separator:a1656525cfdf23336f2a01948af3503a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04eb8789b348d7a142d54b057a45fc2"><td class="memItemLeft" align="right" valign="top"><a id="ad04eb8789b348d7a142d54b057a45fc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad04eb8789b348d7a142d54b057a45fc2">convertToUpper</a> ()</td></tr>
<tr class="memdesc:ad04eb8789b348d7a142d54b057a45fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string to uper-case. <br /></td></tr>
<tr class="separator:ad04eb8789b348d7a142d54b057a45fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68009763ba4fd4c4cc238e0d63c183a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad68009763ba4fd4c4cc238e0d63c183a">endWith</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:ad68009763ba4fd4c4cc238e0d63c183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix.  <a href="#ad68009763ba4fd4c4cc238e0d63c183a">More...</a><br /></td></tr>
<tr class="separator:ad68009763ba4fd4c4cc238e0d63c183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf113b52dce36304c7b8162752f9739"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:aebf113b52dce36304c7b8162752f9739"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aebf113b52dce36304c7b8162752f9739">findSimilar</a> (const CONTAINER &amp;container)</td></tr>
<tr class="memdesc:aebf113b52dce36304c7b8162752f9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate into a map an element with a similar string.  <a href="#aebf113b52dce36304c7b8162752f9739">More...</a><br /></td></tr>
<tr class="separator:aebf113b52dce36304c7b8162752f9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac95d367fa19ad64b1e977341bd9f39b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aac95d367fa19ad64b1e977341bd9f39b">getLine</a> (std::istream &amp;strm)</td></tr>
<tr class="memdesc:aac95d367fa19ad64b1e977341bd9f39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UTF-8 line from a text file and load it into this object.  <a href="#aac95d367fa19ad64b1e977341bd9f39b">More...</a><br /></td></tr>
<tr class="separator:aac95d367fa19ad64b1e977341bd9f39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a3bb4ddae1f320c30e45cbb090057c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a01a3bb4ddae1f320c30e45cbb090057c">justify</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;right, size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>)</td></tr>
<tr class="memdesc:a01a3bb4ddae1f320c30e45cbb090057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justify string, pad in the middle.  <a href="#a01a3bb4ddae1f320c30e45cbb090057c">More...</a><br /></td></tr>
<tr class="separator:a01a3bb4ddae1f320c30e45cbb090057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafed7c34cdb2245bb64a28eaf8dcebea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aafed7c34cdb2245bb64a28eaf8dcebea">justifyCentered</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false)</td></tr>
<tr class="memdesc:aafed7c34cdb2245bb64a28eaf8dcebea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centered-justified (pad and optionally truncate) string.  <a href="#aafed7c34cdb2245bb64a28eaf8dcebea">More...</a><br /></td></tr>
<tr class="separator:aafed7c34cdb2245bb64a28eaf8dcebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb1a1b6c1ec42981709421b80f1d0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1fb1a1b6c1ec42981709421b80f1d0f0">justifyLeft</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false)</td></tr>
<tr class="memdesc:a1fb1a1b6c1ec42981709421b80f1d0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justify (pad and optionally truncate) string.  <a href="#a1fb1a1b6c1ec42981709421b80f1d0f0">More...</a><br /></td></tr>
<tr class="separator:a1fb1a1b6c1ec42981709421b80f1d0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf158d9fad6f15a2c542610711f7e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9cf158d9fad6f15a2c542610711f7e3f">justifyRight</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false)</td></tr>
<tr class="memdesc:a9cf158d9fad6f15a2c542610711f7e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justified (pad and optionally truncate) string.  <a href="#a9cf158d9fad6f15a2c542610711f7e3f">More...</a><br /></td></tr>
<tr class="separator:a9cf158d9fad6f15a2c542610711f7e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b852b7b506c47a395158d6e67b1237f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a0b852b7b506c47a395158d6e67b1237f">remove</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;substr)</td></tr>
<tr class="memdesc:a0b852b7b506c47a395158d6e67b1237f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#a0b852b7b506c47a395158d6e67b1237f">More...</a><br /></td></tr>
<tr class="separator:a0b852b7b506c47a395158d6e67b1237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f30b9620c73d5d9651c1944a8c0632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa2f30b9620c73d5d9651c1944a8c0632">remove</a> (<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> c)</td></tr>
<tr class="memdesc:aa2f30b9620c73d5d9651c1944a8c0632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a character.  <a href="#aa2f30b9620c73d5d9651c1944a8c0632">More...</a><br /></td></tr>
<tr class="separator:aa2f30b9620c73d5d9651c1944a8c0632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9f0d4e4c2225f3f68a5817240e5ebc3b">removePrefix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>)</td></tr>
<tr class="memdesc:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#a9f0d4e4c2225f3f68a5817240e5ebc3b">More...</a><br /></td></tr>
<tr class="separator:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aba59b1e7cbe22ffa6eee81dfafacda32">removeSuffix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>)</td></tr>
<tr class="memdesc:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#aba59b1e7cbe22ffa6eee81dfafacda32">More...</a><br /></td></tr>
<tr class="separator:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4693cea00a3e14d15e15bc91631a97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97">similar</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;other) const</td></tr>
<tr class="memdesc:aca4693cea00a3e14d15e15bc91631a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#aca4693cea00a3e14d15e15bc91631a97">More...</a><br /></td></tr>
<tr class="separator:aca4693cea00a3e14d15e15bc91631a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf010e716088d287fbf11a182716a5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6cf010e716088d287fbf11a182716a5d">similar</a> (const void *addr, size_type size) const</td></tr>
<tr class="memdesc:a6cf010e716088d287fbf11a182716a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#a6cf010e716088d287fbf11a182716a5d">More...</a><br /></td></tr>
<tr class="separator:a6cf010e716088d287fbf11a182716a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926b8b598188f8883528be224838c9db"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a926b8b598188f8883528be224838c9db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a926b8b598188f8883528be224838c9db">split</a> (CONTAINER &amp;container, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> separator=<a class="el" href="namespacets.html#acddcf9feea154a5c67a07120d0012b0e">COMMA</a>, bool trimSpaces=true) const</td></tr>
<tr class="memdesc:a926b8b598188f8883528be224838c9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the string into segments based on a separator character (comma by default).  <a href="#a926b8b598188f8883528be224838c9db">More...</a><br /></td></tr>
<tr class="separator:a926b8b598188f8883528be224838c9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c75eda5c711a905f131a89713da584"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a40c75eda5c711a905f131a89713da584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a40c75eda5c711a905f131a89713da584">splitBlocks</a> (CONTAINER &amp;container, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> <a class="el" href="classts_1_1_u_string.html#a98d515c33c156e797977794f6f99b91d">startWith</a>=<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>('['), <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> <a class="el" href="classts_1_1_u_string.html#ad68009763ba4fd4c4cc238e0d63c183a">endWith</a>=<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>(']'), bool trimSpaces=true) const</td></tr>
<tr class="memdesc:a40c75eda5c711a905f131a89713da584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default).  <a href="#a40c75eda5c711a905f131a89713da584">More...</a><br /></td></tr>
<tr class="separator:a40c75eda5c711a905f131a89713da584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af47dad58edc1a404deb1bd1ebc1c165c">splitLines</a> (CONTAINER &amp;container, size_type maxWidth, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;otherSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;nextMargin=<a class="el" href="classts_1_1_u_string.html">UString</a>(), bool forceSplit=false) const</td></tr>
<tr class="memdesc:af47dad58edc1a404deb1bd1ebc1c165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into multiple lines which are not longer than a specified maximum width.  <a href="#af47dad58edc1a404deb1bd1ebc1c165c">More...</a><br /></td></tr>
<tr class="separator:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d515c33c156e797977794f6f99b91d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a98d515c33c156e797977794f6f99b91d">startWith</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a98d515c33c156e797977794f6f99b91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string starts with a specified prefix.  <a href="#a98d515c33c156e797977794f6f99b91d">More...</a><br /></td></tr>
<tr class="separator:a98d515c33c156e797977794f6f99b91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">substitute</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;replacement)</td></tr>
<tr class="memdesc:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all occurences of a string with another one.  <a href="#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">More...</a><br /></td></tr>
<tr class="separator:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56450a15e82d8a7f64844f34d58b629b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a56450a15e82d8a7f64844f34d58b629b">toDVB</a> (uint8_t *&amp;buffer, size_t &amp;size, size_t start=0, size_t count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:a56450a15e82d8a7f64844f34d58b629b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string.  <a href="#a56450a15e82d8a7f64844f34d58b629b">More...</a><br /></td></tr>
<tr class="separator:a56450a15e82d8a7f64844f34d58b629b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3c2d97cc89516ca2136472f9723c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abc3c2d97cc89516ca2136472f9723c26">toDVB</a> (size_t start=0, size_t count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:abc3c2d97cc89516ca2136472f9723c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string.  <a href="#abc3c2d97cc89516ca2136472f9723c26">More...</a><br /></td></tr>
<tr class="separator:abc3c2d97cc89516ca2136472f9723c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a8d60797f49ca406e10ae80ceb3ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2e3a8d60797f49ca406e10ae80ceb3ad">toDVBWithByteLength</a> (uint8_t *&amp;buffer, size_t &amp;size, size_t start=0, size_t count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:a2e3a8d60797f49ca406e10ae80ceb3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string (preceded by its one-byte length).  <a href="#a2e3a8d60797f49ca406e10ae80ceb3ad">More...</a><br /></td></tr>
<tr class="separator:a2e3a8d60797f49ca406e10ae80ceb3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9eed6b9969042d886f8aa97c33f2b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a5a9eed6b9969042d886f8aa97c33f2b6">toDVBWithByteLength</a> (size_t start=0, size_t count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:a5a9eed6b9969042d886f8aa97c33f2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string (preceded by its one-byte length).  <a href="#a5a9eed6b9969042d886f8aa97c33f2b6">More...</a><br /></td></tr>
<tr class="separator:a5a9eed6b9969042d886f8aa97c33f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab282b998920f3c08215565de93ea44f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aab282b998920f3c08215565de93ea44f">toHTML</a> () const</td></tr>
<tr class="memdesc:aab282b998920f3c08215565de93ea44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string in a suitable HTML representation.  <a href="#aab282b998920f3c08215565de93ea44f">More...</a><br /></td></tr>
<tr class="separator:aab282b998920f3c08215565de93ea44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5453032c03c56b5b38a41afadf706"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa5a5453032c03c56b5b38a41afadf706"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa5a5453032c03c56b5b38a41afadf706">toInteger</a> (INT &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;thousandSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>()) const</td></tr>
<tr class="memdesc:aa5a5453032c03c56b5b38a41afadf706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into an integer.  <a href="#aa5a5453032c03c56b5b38a41afadf706">More...</a><br /></td></tr>
<tr class="separator:aa5a5453032c03c56b5b38a41afadf706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc90718da1c4d93e82ff64a7054e204"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a6dc90718da1c4d93e82ff64a7054e204"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6dc90718da1c4d93e82ff64a7054e204">toIntegers</a> (CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;thousandSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;listSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,; &quot;)) const</td></tr>
<tr class="memdesc:a6dc90718da1c4d93e82ff64a7054e204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing a list of integers into a container of integers.  <a href="#a6dc90718da1c4d93e82ff64a7054e204">More...</a><br /></td></tr>
<tr class="separator:a6dc90718da1c4d93e82ff64a7054e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ef0014152fff1469653e3481f177ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac0ef0014152fff1469653e3481f177ce">toJustified</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;right, size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>) const</td></tr>
<tr class="memdesc:ac0ef0014152fff1469653e3481f177ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a justified string, pad in the middle.  <a href="#ac0ef0014152fff1469653e3481f177ce">More...</a><br /></td></tr>
<tr class="separator:ac0ef0014152fff1469653e3481f177ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481e930994b1f1da4b411302a32ef415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a481e930994b1f1da4b411302a32ef415">toJustifiedCentered</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false) const</td></tr>
<tr class="memdesc:a481e930994b1f1da4b411302a32ef415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a centered-justified (padded and optionally truncated) string.  <a href="#a481e930994b1f1da4b411302a32ef415">More...</a><br /></td></tr>
<tr class="separator:a481e930994b1f1da4b411302a32ef415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302a7659bc3224656ee3e722e39bff70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a302a7659bc3224656ee3e722e39bff70">toJustifiedLeft</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false) const</td></tr>
<tr class="memdesc:a302a7659bc3224656ee3e722e39bff70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a left-justified (padded and optionally truncated) string.  <a href="#a302a7659bc3224656ee3e722e39bff70">More...</a><br /></td></tr>
<tr class="separator:a302a7659bc3224656ee3e722e39bff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3df63e46bb38fcc378c54c8f96c3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8a3df63e46bb38fcc378c54c8f96c3e5">toJustifiedRight</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false) const</td></tr>
<tr class="memdesc:a8a3df63e46bb38fcc378c54c8f96c3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a right-justified (padded and optionally truncated) string.  <a href="#a8a3df63e46bb38fcc378c54c8f96c3e5">More...</a><br /></td></tr>
<tr class="separator:a8a3df63e46bb38fcc378c54c8f96c3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002290c2532a050424674a82fa504b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a002290c2532a050424674a82fa504b51">toLower</a> () const</td></tr>
<tr class="memdesc:a002290c2532a050424674a82fa504b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lower-case version of the string.  <a href="#a002290c2532a050424674a82fa504b51">More...</a><br /></td></tr>
<tr class="separator:a002290c2532a050424674a82fa504b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab419307fa43875cb5e81a0c3ad52625d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab419307fa43875cb5e81a0c3ad52625d">toRemoved</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;substr) const</td></tr>
<tr class="memdesc:ab419307fa43875cb5e81a0c3ad52625d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#ab419307fa43875cb5e81a0c3ad52625d">More...</a><br /></td></tr>
<tr class="separator:ab419307fa43875cb5e81a0c3ad52625d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd257233cc44c47a6e2d0edb6a892dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abd257233cc44c47a6e2d0edb6a892dbd">toRemoved</a> (<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> c) const</td></tr>
<tr class="memdesc:abd257233cc44c47a6e2d0edb6a892dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a character.  <a href="#abd257233cc44c47a6e2d0edb6a892dbd">More...</a><br /></td></tr>
<tr class="separator:abd257233cc44c47a6e2d0edb6a892dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e59bbf5a8df9fed0688e6ed0429463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a24e59bbf5a8df9fed0688e6ed0429463">toRemovedPrefix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a24e59bbf5a8df9fed0688e6ed0429463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#a24e59bbf5a8df9fed0688e6ed0429463">More...</a><br /></td></tr>
<tr class="separator:a24e59bbf5a8df9fed0688e6ed0429463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b73b9d3c2aabc966f75067a2f7e677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a13b73b9d3c2aabc966f75067a2f7e677">toRemovedSuffix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a13b73b9d3c2aabc966f75067a2f7e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#a13b73b9d3c2aabc966f75067a2f7e677">More...</a><br /></td></tr>
<tr class="separator:a13b73b9d3c2aabc966f75067a2f7e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1678f1645abba2cba8d3bae907116000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1678f1645abba2cba8d3bae907116000">toSplitLines</a> (size_type maxWidth, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;otherSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;nextMargin=<a class="el" href="classts_1_1_u_string.html">UString</a>(), bool forceSplit=false, const <a class="el" href="classts_1_1_u_string.html">UString</a> lineSeparator=<a class="el" href="classts_1_1_u_string.html">UString</a>(1, <a class="el" href="namespacets.html#a1f22b94dcc18ebb1ca080df4a0962533">LINE_FEED</a>)) const</td></tr>
<tr class="memdesc:a1678f1645abba2cba8d3bae907116000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into multiple lines which are not longer than a specified maximum width.  <a href="#a1678f1645abba2cba8d3bae907116000">More...</a><br /></td></tr>
<tr class="separator:a1678f1645abba2cba8d3bae907116000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cda0b113d6c880d572a153a732cf3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7cda0b113d6c880d572a153a732cf3b6">toSubstituted</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;replacement) const</td></tr>
<tr class="memdesc:a7cda0b113d6c880d572a153a732cf3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where all occurences of a string are substituted with another one.  <a href="#a7cda0b113d6c880d572a153a732cf3b6">More...</a><br /></td></tr>
<tr class="separator:a7cda0b113d6c880d572a153a732cf3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8695689c7b19d7fa010de40538457388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8695689c7b19d7fa010de40538457388">toTrimmed</a> (bool leading=true, bool trailing=true) const</td></tr>
<tr class="memdesc:a8695689c7b19d7fa010de40538457388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where leading and / or trailing spaces are trimmed.  <a href="#a8695689c7b19d7fa010de40538457388">More...</a><br /></td></tr>
<tr class="separator:a8695689c7b19d7fa010de40538457388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d33505aab6deaf9782d72fa11011d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3d33505aab6deaf9782d72fa11011d55">toUpper</a> () const</td></tr>
<tr class="memdesc:a3d33505aab6deaf9782d72fa11011d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an upper-case version of the string.  <a href="#a3d33505aab6deaf9782d72fa11011d55">More...</a><br /></td></tr>
<tr class="separator:a3d33505aab6deaf9782d72fa11011d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc79cf6e8fa375c618417785cc4af19d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afc79cf6e8fa375c618417785cc4af19d">toUTF8</a> () const</td></tr>
<tr class="memdesc:afc79cf6e8fa375c618417785cc4af19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this UTF-16 string into UTF-8.  <a href="#afc79cf6e8fa375c618417785cc4af19d">More...</a><br /></td></tr>
<tr class="separator:afc79cf6e8fa375c618417785cc4af19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e06a17d20d02a2eeeef09400b01669d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3e06a17d20d02a2eeeef09400b01669d">trim</a> (bool leading=true, bool trailing=true)</td></tr>
<tr class="memdesc:a3e06a17d20d02a2eeeef09400b01669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and / or trailing space characters.  <a href="#a3e06a17d20d02a2eeeef09400b01669d">More...</a><br /></td></tr>
<tr class="separator:a3e06a17d20d02a2eeeef09400b01669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c9e8a315f34bbc971b029af58555a3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a> () const</td></tr>
<tr class="memdesc:a34c9e8a315f34bbc971b029af58555a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the display width in characters.  <a href="#a34c9e8a315f34bbc971b029af58555a3">More...</a><br /></td></tr>
<tr class="separator:a34c9e8a315f34bbc971b029af58555a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2944af208289c54c40a82b6c819a8e8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2944af208289c54c40a82b6c819a8e8a">ConvertUTF16ToUTF8</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;inStart, const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *inEnd, char *&amp;outStart, char *outEnd)</td></tr>
<tr class="memdesc:a2944af208289c54c40a82b6c819a8e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General routine to convert from UTF-16 to UTF-8.  <a href="#a2944af208289c54c40a82b6c819a8e8a">More...</a><br /></td></tr>
<tr class="separator:a2944af208289c54c40a82b6c819a8e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">ConvertUTF8ToUTF16</a> (const char *&amp;inStart, const char *inEnd, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;outStart, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *outEnd)</td></tr>
<tr class="memdesc:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">General routine to convert from UTF-8 to UTF-16.  <a href="#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">More...</a><br /></td></tr>
<tr class="separator:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16c26a8d856cbead7185eb3a733b235"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab16c26a8d856cbead7185eb3a733b235">FromDVB</a> (const std::string &amp;dvb, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:ab16c26a8d856cbead7185eb3a733b235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16.  <a href="#ab16c26a8d856cbead7185eb3a733b235">More...</a><br /></td></tr>
<tr class="separator:ab16c26a8d856cbead7185eb3a733b235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a770b278271a413c1a0e02ecf70e0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af1a770b278271a413c1a0e02ecf70e0f">FromDVB</a> (const uint8_t *dvb, size_t dvbSize, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:af1a770b278271a413c1a0e02ecf70e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16.  <a href="#af1a770b278271a413c1a0e02ecf70e0f">More...</a><br /></td></tr>
<tr class="separator:af1a770b278271a413c1a0e02ecf70e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0944b55ecf6f9507cba1213e4eedea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a5d0944b55ecf6f9507cba1213e4eedea">FromDVBWithByteLength</a> (const uint8_t *&amp;buffer, size_t &amp;size, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:a5d0944b55ecf6f9507cba1213e4eedea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16 (preceded by its one-byte length).  <a href="#a5d0944b55ecf6f9507cba1213e4eedea">More...</a><br /></td></tr>
<tr class="separator:a5d0944b55ecf6f9507cba1213e4eedea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad271cf6c698902327f1f13dba1081732"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad271cf6c698902327f1f13dba1081732">FromUTF8</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:ad271cf6c698902327f1f13dba1081732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#ad271cf6c698902327f1f13dba1081732">More...</a><br /></td></tr>
<tr class="separator:ad271cf6c698902327f1f13dba1081732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87772f991912a5469b39243698ce413"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa87772f991912a5469b39243698ce413">FromUTF8</a> (const char *utf8)</td></tr>
<tr class="memdesc:aa87772f991912a5469b39243698ce413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#aa87772f991912a5469b39243698ce413">More...</a><br /></td></tr>
<tr class="separator:aa87772f991912a5469b39243698ce413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6f1dde40bb81fda96e23d91512c6ee0e">FromUTF8</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#a6f1dde40bb81fda96e23d91512c6ee0e">More...</a><br /></td></tr>
<tr class="separator:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9657437f5f6f6390c61c5b26af559ea0"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:a9657437f5f6f6390c61c5b26af559ea0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9657437f5f6f6390c61c5b26af559ea0">Join</a> (ITERATOR begin, ITERATOR end, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html">UString</a>(&quot;, &quot;))</td></tr>
<tr class="memdesc:a9657437f5f6f6390c61c5b26af559ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a part of a container of strings into one big string.  <a href="#a9657437f5f6f6390c61c5b26af559ea0">More...</a><br /></td></tr>
<tr class="separator:a9657437f5f6f6390c61c5b26af559ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a35447d73cb37f1d9d7694eee29cc8"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ad8a35447d73cb37f1d9d7694eee29cc8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad8a35447d73cb37f1d9d7694eee29cc8">Join</a> (const CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html">UString</a>(&quot;, &quot;))</td></tr>
<tr class="memdesc:ad8a35447d73cb37f1d9d7694eee29cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a container of strings into one big string.  <a href="#ad8a35447d73cb37f1d9d7694eee29cc8">More...</a><br /></td></tr>
<tr class="separator:ad8a35447d73cb37f1d9d7694eee29cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9152608e1eb2daeb4979e2184f5fde15"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a9152608e1eb2daeb4979e2184f5fde15"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9152608e1eb2daeb4979e2184f5fde15">Load</a> (CONTAINER &amp;container, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a9152608e1eb2daeb4979e2184f5fde15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container.  <a href="#a9152608e1eb2daeb4979e2184f5fde15">More...</a><br /></td></tr>
<tr class="separator:a9152608e1eb2daeb4979e2184f5fde15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02e675f653b1f050503230eca49f99"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:afd02e675f653b1f050503230eca49f99"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afd02e675f653b1f050503230eca49f99">LoadAppend</a> (CONTAINER &amp;container, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:afd02e675f653b1f050503230eca49f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container.  <a href="#afd02e675f653b1f050503230eca49f99">More...</a><br /></td></tr>
<tr class="separator:afd02e675f653b1f050503230eca49f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7049b2f840423a0106dc8e1935f5d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3b7049b2f840423a0106dc8e1935f5d6">OnOff</a> (bool b)</td></tr>
<tr class="memdesc:a3b7049b2f840423a0106dc8e1935f5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "on" or "off".  <a href="#a3b7049b2f840423a0106dc8e1935f5d6">More...</a><br /></td></tr>
<tr class="separator:a3b7049b2f840423a0106dc8e1935f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07da2bc1e89e32d230c2ee5011d43a61"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:a07da2bc1e89e32d230c2ee5011d43a61"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a07da2bc1e89e32d230c2ee5011d43a61">Save</a> (ITERATOR begin, ITERATOR end, const std::string &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:a07da2bc1e89e32d230c2ee5011d43a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, in UTF-8 format, one per line.  <a href="#a07da2bc1e89e32d230c2ee5011d43a61">More...</a><br /></td></tr>
<tr class="separator:a07da2bc1e89e32d230c2ee5011d43a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058848180707280605e60824bb80017f"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a058848180707280605e60824bb80017f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a058848180707280605e60824bb80017f">Save</a> (const CONTAINER &amp;container, const std::string &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:a058848180707280605e60824bb80017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, in UTF-8 format, one per line.  <a href="#a058848180707280605e60824bb80017f">More...</a><br /></td></tr>
<tr class="separator:a058848180707280605e60824bb80017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c1f90aff1a79985d15b5edd864355"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af22c1f90aff1a79985d15b5edd864355">TrueFalse</a> (bool b)</td></tr>
<tr class="memdesc:af22c1f90aff1a79985d15b5edd864355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "true" or "false".  <a href="#af22c1f90aff1a79985d15b5edd864355">More...</a><br /></td></tr>
<tr class="separator:af22c1f90aff1a79985d15b5edd864355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abcccd14ec7f4e0404c781a8eaf9becd2">YesNo</a> (bool b)</td></tr>
<tr class="memdesc:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "yes" or "no".  <a href="#abcccd14ec7f4e0404c781a8eaf9becd2">More...</a><br /></td></tr>
<tr class="separator:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="memItemLeft" align="right" valign="top">static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></td></tr>
<tr class="memdesc:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative value for the standard <code>npos</code> value.  <a href="#aab6ad2cee0b7043e14e3c833c6e3d263">More...</a><br /></td></tr>
<tr class="separator:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e270e77a9a7377f73cb0b698b4044"><td class="memItemLeft" align="right" valign="top"><a id="a2b6e270e77a9a7377f73cb0b698b4044"></a>
static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2b6e270e77a9a7377f73cb0b698b4044">UTF8_BOM</a></td></tr>
<tr class="memdesc:a2b6e270e77a9a7377f73cb0b698b4044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 3-byte so-called "UTF-8 Byte Order Mark". <br /></td></tr>
<tr class="separator:a2b6e270e77a9a7377f73cb0b698b4044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e48219259c59bcfd9089f3cabb7f55"><td class="memItemLeft" align="right" valign="top"><a id="ab0e48219259c59bcfd9089f3cabb7f55"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab0e48219259c59bcfd9089f3cabb7f55">UTF8_BOM_SIZE</a> = 3</td></tr>
<tr class="memdesc:ab0e48219259c59bcfd9089f3cabb7f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the so-called "UTF-8 Byte Order Mark". <br /></td></tr>
<tr class="separator:ab0e48219259c59bcfd9089f3cabb7f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56adcf2a989d3cd88c31e6b81d7b2720"><td class="memItemLeft" align="right" valign="top"><a id="a56adcf2a989d3cd88c31e6b81d7b2720"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a56adcf2a989d3cd88c31e6b81d7b2720">UTF8_CHAR_MAX_SIZE</a> = 4</td></tr>
<tr class="memdesc:a56adcf2a989d3cd88c31e6b81d7b2720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size in bytes of an UTF-8 encoded character. <br /></td></tr>
<tr class="separator:a56adcf2a989d3cd88c31e6b81d7b2720"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of UTF-16 strings. </p>
<p>This class is an extension of <code>std::u16string</code> with additional services.</p>
<p>Warning for maintainers: The standard classes <code>std::u16string</code> and <code>std::basic_string</code> do not have virtual destructors. The means that if a <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> is destroyed through, for instance, a <code>std::u16string*</code>, the destructor for the class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> will not be invoked. This is not a problem as long as the <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> subclass does not have any field to destroy, which is the case for the current implementation. When modifying the <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> class, make sure to avoid any issue with the absence of virtual destructor in the parent class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7a31440c72d769f58289151ad46f7513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a31440c72d769f58289151ad46f7513">&#9670;&nbsp;</a></span>UString() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using an allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b39ae35147d3c1db888a0ed4ec603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b39ae35147d3c1db888a0ed4ec603b">&#9670;&nbsp;</a></span>UString() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other instance to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bc5c2b2f8ad7532406fbee57ccf958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc5c2b2f8ad7532406fbee57ccf958">&#9670;&nbsp;</a></span>UString() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>Other instance to move. Upon return, <em>other</em> is left in valid, but unspecified state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4da08e8b553dee75af9516c03207146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da08e8b553dee75af9516c03207146">&#9670;&nbsp;</a></span>UString() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a repetition of the same character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Initial size of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Character to repeat <em>count</em> times. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe1d201f0c6f3cdf175442ca3c2190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe1d201f0c6f3cdf175442ca3c2190b">&#9670;&nbsp;</a></span>UString() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a substring. </p>
<p>The object receives the substring <em>other</em> [<em>pos</em>, <em>pos</em> + <em>count</em>). If <em>count</em> == <code>npos</code> or if the requested substring lasts past the end of the string, the resulting substring is [<em>pos</em>, <code>size()</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other instance to partially copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Initial position to copy in <em>other</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of character to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb04716b7d224778c26c725ab4ea578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb04716b7d224778c26c725ab4ea578">&#9670;&nbsp;</a></span>UString() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a Unicode string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Address of a string. Can be a null pointer if <em>count</em> is zero, in which case the string is empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of characters to copy from <em>s</em>. That number of characters is always copied, including null characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a34703f374f7946dc6e29591b330ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a34703f374f7946dc6e29591b330ae8">&#9670;&nbsp;</a></span>UString() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a null-terminated Unicode string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Address of a null-terminated string. Can be a null pointer, in which case the string is empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ff90a3d47d9103fc41846448834a7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff90a3d47d9103fc41846448834a7dd">&#9670;&nbsp;</a></span>UString() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from iterators. </p>
<p>Constructs the string with the contents of the range [<em>first</em>, @ last). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>An iterator type to containers of <code>Char</code>. If <em>InputIt</em> is an integral type, equivalent to <code>String(static_cast&lt;size_type&gt;(first), static_cast&lt;Char&gt;(last), alloc)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first position to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator after the last position to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2ef21f8e1a9ac503c71375b8dbe0aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ef21f8e1a9ac503c71375b8dbe0aa2">&#9670;&nbsp;</a></span>UString() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initializer list of <code>Char</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0de87d27027309dee3f54df1f53441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0de87d27027309dee3f54df1f53441">&#9670;&nbsp;</a></span>UString() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc2599922bec48046341619bc9f7cb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2599922bec48046341619bc9f7cb92">&#9670;&nbsp;</a></span>UString() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af88905c4e822ed8b392d0e00a44f2324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88905c4e822ed8b392d0e00a44f2324">&#9670;&nbsp;</a></span>UString() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad271cf6c698902327f1f13dba1081732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad271cf6c698902327f1f13dba1081732">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. </dd></dl>

</div>
</div>
<a id="aa87772f991912a5469b39243698ce413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87772f991912a5469b39243698ce413">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Empty string if <em>utf8</em> is a null pointer. </dd></dl>

</div>
</div>
<a id="a6f1dde40bb81fda96e23d91512c6ee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1dde40bb81fda96e23d91512c6ee0e">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Empty string if <em>utf8</em> is a null pointer. </dd></dl>

</div>
</div>
<a id="a9ee876ece8dca88451f3a0ceefc503c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee876ece8dca88451f3a0ceefc503c5">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a967764daaa4aff678e7cc605a6cd1ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967764daaa4aff678e7cc605a6cd1ed5">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a164f4081accc66418dfe274215e04dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164f4081accc66418dfe274215e04dba">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. Can be null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="afc79cf6e8fa375c618417785cc4af19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc79cf6e8fa375c618417785cc4af19d">&#9670;&nbsp;</a></span>toUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::UString::toUTF8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this UTF-16 string into UTF-8. </p>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-8 string. </dd></dl>

</div>
</div>
<a id="a2944af208289c54c40a82b6c819a8e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2944af208289c54c40a82b6c819a8e8a">&#9670;&nbsp;</a></span>ConvertUTF16ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ts::UString::ConvertUTF16ToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;&#160;</td>
          <td class="paramname"><em>inStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>inEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>outStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General routine to convert from UTF-16 to UTF-8. </p>
<p>Stop when the input buffer is empty or the output buffer is full, whichever comes first. Invalid input values are silently ignored and skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inStart</td><td>Address of the input UTF-16 buffer to convert. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inEnd</td><td>Address after the end of the input UTF-16 buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outStart</td><td>Address of the output UTF-8 buffer to fill. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outEnd</td><td>Address after the end of the output UTF-8 buffer to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2fdb093c4b8ffaa02144aa5e9f2fcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">&#9670;&nbsp;</a></span>ConvertUTF8ToUTF16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ts::UString::ConvertUTF8ToUTF16 </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>inStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;&#160;</td>
          <td class="paramname"><em>outStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>outEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General routine to convert from UTF-8 to UTF-16. </p>
<p>Stop when the input buffer is empty or the output buffer is full, whichever comes first. Invalid input values are silently ignored and skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inStart</td><td>Address of the input UTF-8 buffer to convert. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inEnd</td><td>Address after the end of the input UTF-8 buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outStart</td><td>Address of the output UTF-16 buffer to fill. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outEnd</td><td>Address after the end of the output UTF-16 buffer to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16c26a8d856cbead7185eb3a733b235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16c26a8d856cbead7185eb3a733b235">&#9670;&nbsp;</a></span>FromDVB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dvb</td><td>A string in DVB representation. The first bytes of the string indicate the DVB character set to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="af1a770b278271a413c1a0e02ecf70e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a770b278271a413c1a0e02ecf70e0f">&#9670;&nbsp;</a></span>FromDVB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVB </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dvbSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dvb</td><td>Address of a string in DVB representation. The first bytes of the string indicate the DVB character set to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dvbSize</td><td>Size in bytes of the DVB string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="a5d0944b55ecf6f9507cba1213e4eedea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0944b55ecf6f9507cba1213e4eedea">&#9670;&nbsp;</a></span>FromDVBWithByteLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16 (preceded by its one-byte length). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of a buffer containing a DVB string to read. The first byte in the buffer is the length in bytes of the string. Upon return, <em>buffer</em> is updated to point after the end of the string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size in bytes of the buffer, which may be larger than the DVB string. Upon return, <em>size</em> is updated, decremented by the same amount <em>buffer</em> was incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="a56450a15e82d8a7f64844f34d58b629b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56450a15e82d8a7f64844f34d58b629b">&#9670;&nbsp;</a></span>toDVB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::UString::toDVB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string. </p>
<p>Stop either when this string is serialized or when the buffer is full, whichever comes first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer where the DVB string is written. The address is updated to point after the encoded value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size of the buffer. Updated to remaining size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of serialized characters (which is usually not the same as the number of written bytes). </dd></dl>

</div>
</div>
<a id="abc3c2d97cc89516ca2136472f9723c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3c2d97cc89516ca2136472f9723c26">&#9670;&nbsp;</a></span>toDVB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> ts::UString::toDVB </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DVB string. </dd></dl>

</div>
</div>
<a id="a2e3a8d60797f49ca406e10ae80ceb3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a8d60797f49ca406e10ae80ceb3ad">&#9670;&nbsp;</a></span>toDVBWithByteLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ts::UString::toDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string (preceded by its one-byte length). </p>
<p>Stop either when this string is serialized or when the buffer is full or when 255 bytes are written, whichever comes first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer where the DVB string is written. The first byte will receive the size in bytes of the DVB string. The address is updated to point after the encoded value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size of the buffer. Updated to remaining size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of serialized characters (which is usually not the same as the number of written bytes). </dd></dl>

</div>
</div>
<a id="a5a9eed6b9969042d886f8aa97c33f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9eed6b9969042d886f8aa97c33f2b6">&#9670;&nbsp;</a></span>toDVBWithByteLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> ts::UString::toDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string (preceded by its one-byte length). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DVB string with the initial length byte. </dd></dl>

</div>
</div>
<a id="a34c9e8a315f34bbc971b029af58555a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c9e8a315f34bbc971b029af58555a3">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ts::UString::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the display width in characters. </p>
<p>Any combining diacritical character is not counted in the width since it is combined with the preceding character. </p><dl class="section return"><dt>Returns</dt><dd>The display width in characters. </dd></dl>

</div>
</div>
<a id="a3e06a17d20d02a2eeeef09400b01669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e06a17d20d02a2eeeef09400b01669d">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::trim </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading and / or trailing space characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8695689c7b19d7fa010de40538457388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8695689c7b19d7fa010de40538457388">&#9670;&nbsp;</a></span>toTrimmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toTrimmed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string where leading and / or trailing spaces are trimmed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this object after trimming. </dd></dl>

</div>
</div>
<a id="a002290c2532a050424674a82fa504b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002290c2532a050424674a82fa504b51">&#9670;&nbsp;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a lower-case version of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Lower-case version of the string. </dd></dl>

</div>
</div>
<a id="a3d33505aab6deaf9782d72fa11011d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d33505aab6deaf9782d72fa11011d55">&#9670;&nbsp;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an upper-case version of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Upper-case version of the string. </dd></dl>

</div>
</div>
<a id="a0b852b7b506c47a395158d6e67b1237f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b852b7b506c47a395158d6e67b1237f">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>substr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f30b9620c73d5d9651c1944a8c0632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f30b9620c73d5d9651c1944a8c0632">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab419307fa43875cb5e81a0c3ad52625d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab419307fa43875cb5e81a0c3ad52625d">&#9670;&nbsp;</a></span>toRemoved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemoved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>substr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This string with all occurences fo <em>substr</em> removed. </dd></dl>

</div>
</div>
<a id="abd257233cc44c47a6e2d0edb6a892dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd257233cc44c47a6e2d0edb6a892dbd">&#9670;&nbsp;</a></span>toRemoved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This string with all occurences fo <em>substr</em> removed. </dd></dl>

</div>
</div>
<a id="a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">&#9670;&nbsp;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all occurences of a string with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cda0b113d6c880d572a153a732cf3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cda0b113d6c880d572a153a732cf3b6">&#9670;&nbsp;</a></span>toSubstituted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toSubstituted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string where all occurences of a string are substituted with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy to this string where all occurences of <em>value</em> have been replaced by <em>replace</em>. </dd></dl>

</div>
</div>
<a id="a9f0d4e4c2225f3f68a5817240e5ebc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0d4e4c2225f3f68a5817240e5ebc3b">&#9670;&nbsp;</a></span>removePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::removePrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove, if present at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba59b1e7cbe22ffa6eee81dfafacda32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba59b1e7cbe22ffa6eee81dfafacda32">&#9670;&nbsp;</a></span>removeSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::removeSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove, if present at the end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e59bbf5a8df9fed0688e6ed0429463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e59bbf5a8df9fed0688e6ed0429463">&#9670;&nbsp;</a></span>toRemovedPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemovedPrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove, if present at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with prefix removed. </dd></dl>

</div>
</div>
<a id="a13b73b9d3c2aabc966f75067a2f7e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b73b9d3c2aabc966f75067a2f7e677">&#9670;&nbsp;</a></span>toRemovedSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemovedSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove, if present at the end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with suffix removed. </dd></dl>

</div>
</div>
<a id="a98d515c33c156e797977794f6f99b91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d515c33c156e797977794f6f99b91d">&#9670;&nbsp;</a></span>startWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::startWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the string starts with a specified prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A string prefix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="ad68009763ba4fd4c4cc238e0d63c183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68009763ba4fd4c4cc238e0d63c183a">&#9670;&nbsp;</a></span>endWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::endWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A string suffix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a926b8b598188f8883528be224838c9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926b8b598188f8883528be224838c9db">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::split </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="namespacets.html#acddcf9feea154a5c67a07120d0012b0e">COMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the string into segments based on a separator character (comma by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>The character which is used to separate the segments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c75eda5c711a905f131a89713da584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c75eda5c711a905f131a89713da584">&#9670;&nbsp;</a></span>splitBlocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::splitBlocks </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>startWith</em> = <code><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>('[')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>endWith</em> = <code><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>(']')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startWith</td><td>The character which is used to identify the start of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endWith</td><td>The character which is used to identify the end of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af47dad58edc1a404deb1bd1ebc1c165c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47dad58edc1a404deb1bd1ebc1c165c">&#9670;&nbsp;</a></span>splitLines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::splitLines </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>nextMargin</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSplit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into multiple lines which are not longer than a specified maximum width. </p>
<p>The splits occur on spaces or after any character in <em>otherSeparators</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the lines of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of each resulting line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSeparators</td><td>A string containing all characters which are acceptable as line break points (in addition to space characters which are always potential line break points). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMargin</td><td>A string which is prepended to all lines after the first one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSplit</td><td>If true, longer lines without separators are split at the maximum width (by default, longer lines without separators are not split, resulting in lines longer than <em>maxWidth</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1678f1645abba2cba8d3bae907116000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1678f1645abba2cba8d3bae907116000">&#9670;&nbsp;</a></span>toSplitLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toSplitLines </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>nextMargin</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSplit</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td>
          <td class="paramname"><em>lineSeparator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(1,&#160;<a class="el" href="namespacets.html#a1f22b94dcc18ebb1ca080df4a0962533">LINE_FEED</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into multiple lines which are not longer than a specified maximum width. </p>
<p>The splits occur on spaces or after any character in <em>otherSeparators</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of each resulting line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSeparators</td><td>A string containing all characters which are acceptable as line break points (in addition to space characters which are always potential line break points). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMargin</td><td>A string which is prepended to all lines after the first one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSplit</td><td>If true, longer lines without separators are split at the maximum width (by default, longer lines without separators are not split, resulting in lines longer than <em>maxWidth</em>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lineSeparator</td><td>The sequence of characters for line feed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The splitted string with embedded line separators. </dd></dl>

</div>
</div>
<a id="a9657437f5f6f6390c61c5b26af559ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9657437f5f6f6390c61c5b26af559ea0">&#9670;&nbsp;</a></span>Join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Join </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(&quot;,&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a part of a container of strings into one big string. </p>
<p>The strings are accessed through iterators in the container. All strings are concatenated into one big string. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="ad8a35447d73cb37f1d9d7694eee29cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a35447d73cb37f1d9d7694eee29cc8">&#9670;&nbsp;</a></span>Join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Join </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(&quot;,&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a container of strings into one big string. </p>
<p>All strings from the container are concatenated into one big string. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <code>std::string</code> containing all strings to concatenate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="a1fb1a1b6c1ec42981709421b80f1d0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb1a1b6c1ec42981709421b80f1d0f0">&#9670;&nbsp;</a></span>justifyLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyLeft </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justify (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to append to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, it is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302a7659bc3224656ee3e722e39bff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302a7659bc3224656ee3e722e39bff70">&#9670;&nbsp;</a></span>toJustifiedLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedLeft </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a left-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to append to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, it is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a9cf158d9fad6f15a2c542610711f7e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf158d9fad6f15a2c542610711f7e3f">&#9670;&nbsp;</a></span>justifyRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyRight </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justified (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to prepend to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, the beginning of <em>str</em> is truncated. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a3df63e46bb38fcc378c54c8f96c3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3df63e46bb38fcc378c54c8f96c3e5">&#9670;&nbsp;</a></span>toJustifiedRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedRight </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a right-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to prepend to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, the beginning of <em>str</em> is truncated. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="aafed7c34cdb2245bb64a28eaf8dcebea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafed7c34cdb2245bb64a28eaf8dcebea">&#9670;&nbsp;</a></span>justifyCentered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyCentered </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centered-justified (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended and appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The pad character for the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, this string is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a481e930994b1f1da4b411302a32ef415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481e930994b1f1da4b411302a32ef415">&#9670;&nbsp;</a></span>toJustifiedCentered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedCentered </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a centered-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended and appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The pad character for the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, this string is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a01a3bb4ddae1f320c30e45cbb090057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a3bb4ddae1f320c30e45cbb090057c">&#9670;&nbsp;</a></span>justify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Justify string, pad in the middle. </p>
<p>If the this string and <em>right</em> components are collectively shorter than the specified width, <em>pad</em> characters are inserted between <em>left</em> and <em>right</em>, up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right part of the string to justify. This string is used as left part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to insert between the two parts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0ef0014152fff1469653e3481f177ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ef0014152fff1469653e3481f177ce">&#9670;&nbsp;</a></span>toJustified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a justified string, pad in the middle. </p>
<p>If the this string and <em>right</em> components are collectively shorter than the specified width, <em>pad</em> characters are inserted between <em>left</em> and <em>right</em>, up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right part of the string to justify. This string is used as left part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to insert between the two parts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a18b4570240cab5a86adf85009203df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b4570240cab5a86adf85009203df07">&#9670;&nbsp;</a></span>convertToHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::convertToHTML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string into a suitable HTML representation. </p>
<p>All special characters are converted to the corresponding HTML entities. </p>

</div>
</div>
<a id="aab282b998920f3c08215565de93ea44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab282b998920f3c08215565de93ea44f">&#9670;&nbsp;</a></span>toHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toHTML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string in a suitable HTML representation. </p>
<p>All special characters are converted to the corresponding HTML entities. </p><dl class="section return"><dt>Returns</dt><dd>The string in a suitable HTML representation. </dd></dl>

</div>
</div>
<a id="abcccd14ec7f4e0404c781a8eaf9becd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcccd14ec7f4e0404c781a8eaf9becd2">&#9670;&nbsp;</a></span>YesNo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::YesNo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "yes" or "no". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"yes" is <em>b</em> is true, "no" otherwise. </dd></dl>

</div>
</div>
<a id="af22c1f90aff1a79985d15b5edd864355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c1f90aff1a79985d15b5edd864355">&#9670;&nbsp;</a></span>TrueFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::TrueFalse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "true" or "false". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" is <em>b</em> is true, "false" otherwise. </dd></dl>

</div>
</div>
<a id="a3b7049b2f840423a0106dc8e1935f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7049b2f840423a0106dc8e1935f5d6">&#9670;&nbsp;</a></span>OnOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::OnOff </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "on" or "off". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"on" is <em>b</em> is true, "off" otherwise. </dd></dl>

</div>
</div>
<a id="aca4693cea00a3e14d15e15bc91631a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4693cea00a3e14d15e15bc91631a97">&#9670;&nbsp;</a></span>similar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::similar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string and <em>other</em> are "similar", ie. identical, case-insensitive and ignoring blanks. </dd></dl>

</div>
</div>
<a id="a6cf010e716088d287fbf11a182716a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf010e716088d287fbf11a182716a5d">&#9670;&nbsp;</a></span>similar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::similar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of second string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of second string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings are "similar", ie. identical, case-insensitive and ignoring blanks </dd></dl>

</div>
</div>
<a id="a7c84148d5f72c940a9f9c6fe51c5e956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c84148d5f72c940a9f9c6fe51c5e956">&#9670;&nbsp;</a></span>containSimilar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::containSimilar </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a container of strings contains something similar to this string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>container</em> contains a string similar to this string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a> </dd></dl>

</div>
</div>
<a id="aebf113b52dce36304c7b8162752f9739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf113b52dce36304c7b8162752f9739">&#9670;&nbsp;</a></span>findSimilar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER::const_iterator ts::UString::findSimilar </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate into a map an element with a similar string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A map container class using <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A map container with <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first element of <em>container</em> with a key value which is similar to this string according to <a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a>. Return <em>container.end()</em> if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a> </dd></dl>

</div>
</div>
<a id="a07da2bc1e89e32d230c2ee5011d43a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07da2bc1e89e32d230c2ee5011d43a61">&#9670;&nbsp;</a></span>Save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a file, in UTF-8 format, one per line. </p>
<p>The strings must be located in a container and are accessed through iterators. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a058848180707280605e60824bb80017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058848180707280605e60824bb80017f">&#9670;&nbsp;</a></span>Save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a file, in UTF-8 format, one per line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> containing all strings to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a9152608e1eb2daeb4979e2184f5fde15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9152608e1eb2daeb4979e2184f5fde15">&#9670;&nbsp;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Load </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="afd02e675f653b1f050503230eca49f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd02e675f653b1f050503230eca49f99">&#9670;&nbsp;</a></span>LoadAppend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::LoadAppend </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. Each line of the text file is inserted as a separate string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="aac95d367fa19ad64b1e977341bd9f39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac95d367fa19ad64b1e977341bd9f39b">&#9670;&nbsp;</a></span>getLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::getLine </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one UTF-8 line from a text file and load it into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>A standard stream in input mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="aa5a5453032c03c56b5b38a41afadf706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a5453032c03c56b5b38a41afadf706">&#9670;&nbsp;</a></span>toInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::toInteger </td>
          <td>(</td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into an integer. </p>
<p>This string must contain the representation of an integer value in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. The toInteger function decodes integer values of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The returned decoded value. On error (invalid string), <em>value</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a6dc90718da1c4d93e82ff64a7054e204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc90718da1c4d93e82ff64a7054e204">&#9670;&nbsp;</a></span>toIntegers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::toIntegers </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>listSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,;&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string containing a list of integers into a container of integers. </p>
<p>This string must contain the representation of integer values in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored. The various integer values in the string are separated using list delimiters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of any integer type as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>The returned decoded values. The previous content of the container is discarded. The integer values are added in the container in the order of the decoded string. On error (invalid string), <em>container</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listSeparators</td><td>A string of characters which are interpreted as list separators. Distinct integer values must be separated by one or more of these separators. <em>Any character</em> from the <em>listSeparators</em> string is interpreted as a separator. Note that this implies that the list separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aab6ad2cee0b7043e14e3c833c6e3d263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ad2cee0b7043e14e3c833c6e3d263">&#9670;&nbsp;</a></span>NPOS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_type ts::UString::NPOS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"></div><div class="line">            size_type(-1)</div></div><!-- fragment -->
<p>An alternative value for the standard <code>npos</code> value. </p>
<p>Required on Windows to avoid linking issue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ts_u_string_8h.html">tsUString.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
