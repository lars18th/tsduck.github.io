<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: ts::UString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.6</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classts_1_1_u_string.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classts_1_1_u_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ts::UString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of UTF-16 strings.  
 <a href="classts_1_1_u_string.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ts::UString:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_u_string__inherit__graph.png" border="0" usemap="#ts_1_1_u_string_inherit__map" alt="Inheritance graph"/></div>
<map name="ts_1_1_u_string_inherit__map" id="ts_1_1_u_string_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ts::UString:</div>
<div class="dyncontent">
<div class="center"><img src="classts_1_1_u_string__coll__graph.png" border="0" usemap="#ts_1_1_u_string_coll__map" alt="Collaboration graph"/></div>
<map name="ts_1_1_u_string_coll__map" id="ts_1_1_u_string_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95e758037651fab003f10b568b08cb46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46">HexaFlags</a> { <br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46a7b28ae996daf573879de011a9272213e">ASCII</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46a1fe85f01480cd855bab2b74584decc18">OFFSET</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aeb77a0b83f6ffb378b7aa4bfd2ea92ec">WIDE_OFFSET</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46ab48832764b88fc047c7240a4db697bf6">SINGLE_LINE</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46a5bd17b48ecd9481285308f1de417c869">BPL</a> = 0x0020, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46a4a731657054e8daa7bcdc57addbdf2e8">C_STYLE</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46ab64e5ff12cf560fa6b044102cb03ba57">BINARY</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46ae537565b2b54076ff5177385d44b0e9f">BIN_NIBBLE</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46addb530d5c14f429cbf46e9496ea22ed5">COMPACT</a> = 0x0200
<br />
 }<tr class="memdesc:a95e758037651fab003f10b568b08cb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for the <a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42" title="Format a string containing an hexadecimal value. ">Hexa()</a> family of methods.  <a href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a95e758037651fab003f10b568b08cb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7ce465657a81ff26b97df471188cb0"><td class="memItemLeft" align="right" valign="top"><a id="aee7ce465657a81ff26b97df471188cb0"></a>
typedef std::u16string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a></td></tr>
<tr class="memdesc:aee7ce465657a81ff26b97df471188cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit reference to superclass. <br /></td></tr>
<tr class="separator:aee7ce465657a81ff26b97df471188cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9e07e631d13a10229b5eb840339efd7"><td class="memItemLeft" align="right" valign="top"><a id="ac9e07e631d13a10229b5eb840339efd7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac9e07e631d13a10229b5eb840339efd7">UString</a> () noexcept(noexcept(allocator_type()))</td></tr>
<tr class="memdesc:ac9e07e631d13a10229b5eb840339efd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac9e07e631d13a10229b5eb840339efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31440c72d769f58289151ad46f7513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7a31440c72d769f58289151ad46f7513">UString</a> (const allocator_type &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a7a31440c72d769f58289151ad46f7513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using an allocator.  <a href="#a7a31440c72d769f58289151ad46f7513">More...</a><br /></td></tr>
<tr class="separator:a7a31440c72d769f58289151ad46f7513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac9b39ae35147d3c1db888a0ed4ec603b">UString</a> (const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;other)</td></tr>
<tr class="memdesc:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac9b39ae35147d3c1db888a0ed4ec603b">More...</a><br /></td></tr>
<tr class="separator:ac9b39ae35147d3c1db888a0ed4ec603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab3bc5c2b2f8ad7532406fbee57ccf958">UString</a> (<a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab3bc5c2b2f8ad7532406fbee57ccf958">More...</a><br /></td></tr>
<tr class="separator:ab3bc5c2b2f8ad7532406fbee57ccf958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da08e8b553dee75af9516c03207146"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad4da08e8b553dee75af9516c03207146">UString</a> (size_type count, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> ch, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:ad4da08e8b553dee75af9516c03207146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a repetition of the same character.  <a href="#ad4da08e8b553dee75af9516c03207146">More...</a><br /></td></tr>
<tr class="separator:ad4da08e8b553dee75af9516c03207146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#acbe1d201f0c6f3cdf175442ca3c2190b">UString</a> (const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;other, size_type pos, size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a substring.  <a href="#acbe1d201f0c6f3cdf175442ca3c2190b">More...</a><br /></td></tr>
<tr class="separator:acbe1d201f0c6f3cdf175442ca3c2190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb04716b7d224778c26c725ab4ea578"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1bb04716b7d224778c26c725ab4ea578">UString</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *s, size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1bb04716b7d224778c26c725ab4ea578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a Unicode string.  <a href="#a1bb04716b7d224778c26c725ab4ea578">More...</a><br /></td></tr>
<tr class="separator:a1bb04716b7d224778c26c725ab4ea578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a34703f374f7946dc6e29591b330ae8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1a34703f374f7946dc6e29591b330ae8">UString</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *s, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1a34703f374f7946dc6e29591b330ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a null-terminated Unicode string.  <a href="#a1a34703f374f7946dc6e29591b330ae8">More...</a><br /></td></tr>
<tr class="separator:a1a34703f374f7946dc6e29591b330ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeda3998f754d6de7b3c62dd7460f78e"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afeda3998f754d6de7b3c62dd7460f78e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afeda3998f754d6de7b3c62dd7460f78e">UString</a> (const std::vector&lt; CHARTYPE &gt; &amp;vec, INT count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:afeda3998f754d6de7b3c62dd7460f78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a <code>std::vector</code> of 16-bit characters of any type.  <a href="#afeda3998f754d6de7b3c62dd7460f78e">More...</a><br /></td></tr>
<tr class="separator:afeda3998f754d6de7b3c62dd7460f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7140e9d00ddf163509052fb12e3a98e1"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE &gt; </td></tr>
<tr class="memitem:a7140e9d00ddf163509052fb12e3a98e1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7140e9d00ddf163509052fb12e3a98e1">UString</a> (const std::vector&lt; CHARTYPE &gt; &amp;vec, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a7140e9d00ddf163509052fb12e3a98e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a <code>std::vector</code> of 16-bit characters of any type.  <a href="#a7140e9d00ddf163509052fb12e3a98e1">More...</a><br /></td></tr>
<tr class="separator:a7140e9d00ddf163509052fb12e3a98e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04706a597606a7db176aba33f22bb2cd"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , std::size_t SIZE, typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a04706a597606a7db176aba33f22bb2cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a04706a597606a7db176aba33f22bb2cd">UString</a> (const std::array&lt; CHARTYPE, SIZE &gt; &amp;arr, INT count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a04706a597606a7db176aba33f22bb2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a <code>std::array</code> of 16-bit characters of any type.  <a href="#a04706a597606a7db176aba33f22bb2cd">More...</a><br /></td></tr>
<tr class="separator:a04706a597606a7db176aba33f22bb2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12141f76f3a68149ea8de11e7b0671a8"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a12141f76f3a68149ea8de11e7b0671a8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a12141f76f3a68149ea8de11e7b0671a8">UString</a> (const std::array&lt; CHARTYPE, SIZE &gt; &amp;arr, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a12141f76f3a68149ea8de11e7b0671a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a <code>std::array</code> of 16-bit characters of any type.  <a href="#a12141f76f3a68149ea8de11e7b0671a8">More...</a><br /></td></tr>
<tr class="separator:a12141f76f3a68149ea8de11e7b0671a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff90a3d47d9103fc41846448834a7dd"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9ff90a3d47d9103fc41846448834a7dd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9ff90a3d47d9103fc41846448834a7dd">UString</a> (InputIt first, InputIt <a class="el" href="classts_1_1_u_string.html#a8e5fc68d56c4f4e06929ae588819f055">last</a>, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a9ff90a3d47d9103fc41846448834a7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from iterators.  <a href="#a9ff90a3d47d9103fc41846448834a7dd">More...</a><br /></td></tr>
<tr class="separator:a9ff90a3d47d9103fc41846448834a7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa2ef21f8e1a9ac503c71375b8dbe0aa2">UString</a> (std::initializer_list&lt; <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> &gt; init, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an initializer list.  <a href="#aa2ef21f8e1a9ac503c71375b8dbe0aa2">More...</a><br /></td></tr>
<tr class="separator:aa2ef21f8e1a9ac503c71375b8dbe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0de87d27027309dee3f54df1f53441"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#acd0de87d27027309dee3f54df1f53441">UString</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:acd0de87d27027309dee3f54df1f53441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#acd0de87d27027309dee3f54df1f53441">More...</a><br /></td></tr>
<tr class="separator:acd0de87d27027309dee3f54df1f53441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2599922bec48046341619bc9f7cb92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#adc2599922bec48046341619bc9f7cb92">UString</a> (const char *utf8)</td></tr>
<tr class="memdesc:adc2599922bec48046341619bc9f7cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#adc2599922bec48046341619bc9f7cb92">More...</a><br /></td></tr>
<tr class="separator:adc2599922bec48046341619bc9f7cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88905c4e822ed8b392d0e00a44f2324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af88905c4e822ed8b392d0e00a44f2324">UString</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:af88905c4e822ed8b392d0e00a44f2324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an UTF-8 string.  <a href="#af88905c4e822ed8b392d0e00a44f2324">More...</a><br /></td></tr>
<tr class="separator:af88905c4e822ed8b392d0e00a44f2324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fa13dc84b89c0c90a0b1f7e7e87030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af0fa13dc84b89c0c90a0b1f7e7e87030">appendDump</a> (const void *data, size_type size, uint32_t flags=<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a>, size_type <a class="el" href="namespacets.html#a45875f9eaab18c02b57b9fbd2e216d3d">indent</a>=0, size_type line_width=<a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a>, size_type init_offset=0, size_type inner_indent=0)</td></tr>
<tr class="memdesc:af0fa13dc84b89c0c90a0b1f7e7e87030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a multi-line string containing the hexadecimal dump of a memory area.  <a href="#af0fa13dc84b89c0c90a0b1f7e7e87030">More...</a><br /></td></tr>
<tr class="separator:af0fa13dc84b89c0c90a0b1f7e7e87030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b1b093a337106fbf885e2dafa8c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9c7b1b093a337106fbf885e2dafa8c2d">appendDump</a> (const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;bb, uint32_t flags=<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a>, size_type <a class="el" href="namespacets.html#a45875f9eaab18c02b57b9fbd2e216d3d">indent</a>=0, size_type line_width=<a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a>, size_type init_offset=0, size_type inner_indent=0)</td></tr>
<tr class="memdesc:a9c7b1b093a337106fbf885e2dafa8c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a multi-line string containing the hexadecimal dump of a memory area.  <a href="#a9c7b1b093a337106fbf885e2dafa8c2d">More...</a><br /></td></tr>
<tr class="separator:a9c7b1b093a337106fbf885e2dafa8c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee8b02a88e409c18afb41b3a7c68b67"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aaee8b02a88e409c18afb41b3a7c68b67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aaee8b02a88e409c18afb41b3a7c68b67">assign</a> (const std::vector&lt; CHARTYPE &gt; &amp;vec, INT count)</td></tr>
<tr class="memdesc:aaee8b02a88e409c18afb41b3a7c68b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a <code>std::vector</code> of 16-bit characters of any type.  <a href="#aaee8b02a88e409c18afb41b3a7c68b67">More...</a><br /></td></tr>
<tr class="separator:aaee8b02a88e409c18afb41b3a7c68b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc017319630b84e5e355771efe4b39c"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE &gt; </td></tr>
<tr class="memitem:aedc017319630b84e5e355771efe4b39c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aedc017319630b84e5e355771efe4b39c">assign</a> (const std::vector&lt; CHARTYPE &gt; &amp;vec)</td></tr>
<tr class="memdesc:aedc017319630b84e5e355771efe4b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a <code>std::vector</code> of 16-bit characters of any type.  <a href="#aedc017319630b84e5e355771efe4b39c">More...</a><br /></td></tr>
<tr class="separator:aedc017319630b84e5e355771efe4b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8f8622c7db313e6e725463b3923996"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , std::size_t SIZE, typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aec8f8622c7db313e6e725463b3923996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aec8f8622c7db313e6e725463b3923996">assign</a> (const std::array&lt; CHARTYPE, SIZE &gt; &amp;arr, INT count)</td></tr>
<tr class="memdesc:aec8f8622c7db313e6e725463b3923996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a <code>std::array</code> of 16-bit characters of any type.  <a href="#aec8f8622c7db313e6e725463b3923996">More...</a><br /></td></tr>
<tr class="separator:aec8f8622c7db313e6e725463b3923996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c0789989342c0cca83f38c27cace9"><td class="memTemplParams" colspan="2">template&lt;typename CHARTYPE , std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a2d4c0789989342c0cca83f38c27cace9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2d4c0789989342c0cca83f38c27cace9">assign</a> (const std::array&lt; CHARTYPE, SIZE &gt; &amp;arr)</td></tr>
<tr class="memdesc:a2d4c0789989342c0cca83f38c27cace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a <code>std::array</code> of 16-bit characters of any type.  <a href="#a2d4c0789989342c0cca83f38c27cace9">More...</a><br /></td></tr>
<tr class="separator:a2d4c0789989342c0cca83f38c27cace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee876ece8dca88451f3a0ceefc503c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9ee876ece8dca88451f3a0ceefc503c5">assignFromUTF8</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:a9ee876ece8dca88451f3a0ceefc503c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a9ee876ece8dca88451f3a0ceefc503c5">More...</a><br /></td></tr>
<tr class="separator:a9ee876ece8dca88451f3a0ceefc503c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967764daaa4aff678e7cc605a6cd1ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a967764daaa4aff678e7cc605a6cd1ed5">assignFromUTF8</a> (const char *utf8)</td></tr>
<tr class="memdesc:a967764daaa4aff678e7cc605a6cd1ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a967764daaa4aff678e7cc605a6cd1ed5">More...</a><br /></td></tr>
<tr class="separator:a967764daaa4aff678e7cc605a6cd1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f4081accc66418dfe274215e04dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a164f4081accc66418dfe274215e04dba">assignFromUTF8</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:a164f4081accc66418dfe274215e04dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into this object.  <a href="#a164f4081accc66418dfe274215e04dba">More...</a><br /></td></tr>
<tr class="separator:a164f4081accc66418dfe274215e04dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7c84148d5f72c940a9f9c6fe51c5e956">containSimilar</a> (const CONTAINER &amp;container) const</td></tr>
<tr class="memdesc:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a container of strings contains something similar to this string.  <a href="#a7c84148d5f72c940a9f9c6fe51c5e956">More...</a><br /></td></tr>
<tr class="separator:a7c84148d5f72c940a9f9c6fe51c5e956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d49099cc36621a318153d6e9cccecd"><td class="memItemLeft" align="right" valign="top"><a id="a69d49099cc36621a318153d6e9cccecd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a69d49099cc36621a318153d6e9cccecd">convertFromHTML</a> ()</td></tr>
<tr class="memdesc:a69d49099cc36621a318153d6e9cccecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all HTML entities in the string into plain characters. <br /></td></tr>
<tr class="separator:a69d49099cc36621a318153d6e9cccecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31c7acdc2b6e73e07d39dd9d1f3309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a0b31c7acdc2b6e73e07d39dd9d1f3309">convertToHTML</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;convert=<a class="el" href="classts_1_1_u_string.html">UString</a>())</td></tr>
<tr class="memdesc:a0b31c7acdc2b6e73e07d39dd9d1f3309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string into a suitable HTML representation.  <a href="#a0b31c7acdc2b6e73e07d39dd9d1f3309">More...</a><br /></td></tr>
<tr class="separator:a0b31c7acdc2b6e73e07d39dd9d1f3309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656525cfdf23336f2a01948af3503a5"><td class="memItemLeft" align="right" valign="top"><a id="a1656525cfdf23336f2a01948af3503a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1656525cfdf23336f2a01948af3503a5">convertToLower</a> ()</td></tr>
<tr class="memdesc:a1656525cfdf23336f2a01948af3503a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string to lower-case. <br /></td></tr>
<tr class="separator:a1656525cfdf23336f2a01948af3503a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04eb8789b348d7a142d54b057a45fc2"><td class="memItemLeft" align="right" valign="top"><a id="ad04eb8789b348d7a142d54b057a45fc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad04eb8789b348d7a142d54b057a45fc2">convertToUpper</a> ()</td></tr>
<tr class="memdesc:ad04eb8789b348d7a142d54b057a45fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string to uper-case. <br /></td></tr>
<tr class="separator:ad04eb8789b348d7a142d54b057a45fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f3c24b274ab1c047ba1ab030637707"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab0f3c24b274ab1c047ba1ab030637707">displayPosition</a> (size_type count, size_type from=0, <a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a> direction=<a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a>) const</td></tr>
<tr class="memdesc:ab0f3c24b274ab1c047ba1ab030637707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count displayed positions inside a string.  <a href="#ab0f3c24b274ab1c047ba1ab030637707">More...</a><br /></td></tr>
<tr class="separator:ab0f3c24b274ab1c047ba1ab030637707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68009763ba4fd4c4cc238e0d63c183a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad68009763ba4fd4c4cc238e0d63c183a">endWith</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:ad68009763ba4fd4c4cc238e0d63c183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string ends with a specified suffix.  <a href="#ad68009763ba4fd4c4cc238e0d63c183a">More...</a><br /></td></tr>
<tr class="separator:ad68009763ba4fd4c4cc238e0d63c183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca55557dc10c702ed78a1e36172f3117"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:aca55557dc10c702ed78a1e36172f3117"><td class="memTemplItemLeft" align="right" valign="top">CONTAINER::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aca55557dc10c702ed78a1e36172f3117">findSimilar</a> (const CONTAINER &amp;container) const</td></tr>
<tr class="memdesc:aca55557dc10c702ed78a1e36172f3117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate into a map an element with a similar string.  <a href="#aca55557dc10c702ed78a1e36172f3117">More...</a><br /></td></tr>
<tr class="separator:aca55557dc10c702ed78a1e36172f3117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463edf09edb30f813f25078a06faaba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a463edf09edb30f813f25078a06faaba9">FromHTML</a> () const</td></tr>
<tr class="memdesc:a463edf09edb30f813f25078a06faaba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string with all HTML entities converted into plain characters.  <a href="#a463edf09edb30f813f25078a06faaba9">More...</a><br /></td></tr>
<tr class="separator:a463edf09edb30f813f25078a06faaba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac95d367fa19ad64b1e977341bd9f39b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aac95d367fa19ad64b1e977341bd9f39b">getLine</a> (std::istream &amp;strm)</td></tr>
<tr class="memdesc:aac95d367fa19ad64b1e977341bd9f39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UTF-8 line from a text file and load it into this object.  <a href="#aac95d367fa19ad64b1e977341bd9f39b">More...</a><br /></td></tr>
<tr class="separator:aac95d367fa19ad64b1e977341bd9f39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac324e7e61aa81936d8adbce4028c577e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac324e7e61aa81936d8adbce4028c577e">hexaDecode</a> (<a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;result) const</td></tr>
<tr class="memdesc:ac324e7e61aa81936d8adbce4028c577e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret this string as a sequence of hexadecimal digits (ignore blanks).  <a href="#ac324e7e61aa81936d8adbce4028c577e">More...</a><br /></td></tr>
<tr class="separator:ac324e7e61aa81936d8adbce4028c577e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b306525a16c1cc533e0c6c9f4e7e75c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1b306525a16c1cc533e0c6c9f4e7e75c">hexaDecodeAppend</a> (<a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;result) const</td></tr>
<tr class="memdesc:a1b306525a16c1cc533e0c6c9f4e7e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret this string as a sequence of hexadecimal digits (ignore blanks).  <a href="#a1b306525a16c1cc533e0c6c9f4e7e75c">More...</a><br /></td></tr>
<tr class="separator:a1b306525a16c1cc533e0c6c9f4e7e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da20ba1436ffe0405a024124a69f1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a4da20ba1436ffe0405a024124a69f1a3">justify</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;right, size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, size_t spacesAroundPad=0)</td></tr>
<tr class="memdesc:a4da20ba1436ffe0405a024124a69f1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justify string, pad in the middle.  <a href="#a4da20ba1436ffe0405a024124a69f1a3">More...</a><br /></td></tr>
<tr class="separator:a4da20ba1436ffe0405a024124a69f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36004a34eb9916a0fb9c7226e8a7ff3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a36004a34eb9916a0fb9c7226e8a7ff3e">justifyCentered</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesAroundPad=0)</td></tr>
<tr class="memdesc:a36004a34eb9916a0fb9c7226e8a7ff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centered-justified (pad and optionally truncate) string.  <a href="#a36004a34eb9916a0fb9c7226e8a7ff3e">More...</a><br /></td></tr>
<tr class="separator:a36004a34eb9916a0fb9c7226e8a7ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d454a8d9c6cd32f7528c3978e1b960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af6d454a8d9c6cd32f7528c3978e1b960">justifyLeft</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesBeforePad=0)</td></tr>
<tr class="memdesc:af6d454a8d9c6cd32f7528c3978e1b960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justify (pad and optionally truncate) string.  <a href="#af6d454a8d9c6cd32f7528c3978e1b960">More...</a><br /></td></tr>
<tr class="separator:af6d454a8d9c6cd32f7528c3978e1b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae571d4cd09eb160eaac0ac02ac3be18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aae571d4cd09eb160eaac0ac02ac3be18">justifyRight</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesAfterPad=0)</td></tr>
<tr class="memdesc:aae571d4cd09eb160eaac0ac02ac3be18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justified (pad and optionally truncate) string.  <a href="#aae571d4cd09eb160eaac0ac02ac3be18">More...</a><br /></td></tr>
<tr class="separator:aae571d4cd09eb160eaac0ac02ac3be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5fc68d56c4f4e06929ae588819f055"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8e5fc68d56c4f4e06929ae588819f055">last</a> () const</td></tr>
<tr class="memdesc:a8e5fc68d56c4f4e06929ae588819f055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address after the last character in the string.  <a href="#a8e5fc68d56c4f4e06929ae588819f055">More...</a><br /></td></tr>
<tr class="separator:a8e5fc68d56c4f4e06929ae588819f055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d26d5a81d0754f1ac664f2688b1c195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2d26d5a81d0754f1ac664f2688b1c195">last</a> ()</td></tr>
<tr class="memdesc:a2d26d5a81d0754f1ac664f2688b1c195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address after the last character in the string (C++17).  <a href="#a2d26d5a81d0754f1ac664f2688b1c195">More...</a><br /></td></tr>
<tr class="separator:a2d26d5a81d0754f1ac664f2688b1c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b852b7b506c47a395158d6e67b1237f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a0b852b7b506c47a395158d6e67b1237f">remove</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;substr)</td></tr>
<tr class="memdesc:a0b852b7b506c47a395158d6e67b1237f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#a0b852b7b506c47a395158d6e67b1237f">More...</a><br /></td></tr>
<tr class="separator:a0b852b7b506c47a395158d6e67b1237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f30b9620c73d5d9651c1944a8c0632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa2f30b9620c73d5d9651c1944a8c0632">remove</a> (<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> c)</td></tr>
<tr class="memdesc:aa2f30b9620c73d5d9651c1944a8c0632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a character.  <a href="#aa2f30b9620c73d5d9651c1944a8c0632">More...</a><br /></td></tr>
<tr class="separator:aa2f30b9620c73d5d9651c1944a8c0632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9f0d4e4c2225f3f68a5817240e5ebc3b">removePrefix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>)</td></tr>
<tr class="memdesc:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#a9f0d4e4c2225f3f68a5817240e5ebc3b">More...</a><br /></td></tr>
<tr class="separator:a9f0d4e4c2225f3f68a5817240e5ebc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aba59b1e7cbe22ffa6eee81dfafacda32">removeSuffix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>)</td></tr>
<tr class="memdesc:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#aba59b1e7cbe22ffa6eee81dfafacda32">More...</a><br /></td></tr>
<tr class="separator:aba59b1e7cbe22ffa6eee81dfafacda32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33fc61eb3d72d8d190f62b712294527"><td class="memItemLeft" align="right" valign="top"><a id="af33fc61eb3d72d8d190f62b712294527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af33fc61eb3d72d8d190f62b712294527">reverse</a> ()</td></tr>
<tr class="memdesc:af33fc61eb3d72d8d190f62b712294527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of characters in the string. <br /></td></tr>
<tr class="separator:af33fc61eb3d72d8d190f62b712294527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad4436655c7622b184598f5dd7593d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ae9ad4436655c7622b184598f5dd7593d">scan</a> (size_t &amp;extractedCount, size_type &amp;endIndex, const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt; args) const</td></tr>
<tr class="memdesc:ae9ad4436655c7622b184598f5dd7593d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan this string for integer or character values using a template and arguments.  <a href="#ae9ad4436655c7622b184598f5dd7593d">More...</a><br /></td></tr>
<tr class="separator:ae9ad4436655c7622b184598f5dd7593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9de7b15c4eb481e5a70c2572da364a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afe9de7b15c4eb481e5a70c2572da364a">scan</a> (size_t &amp;extractedCount, size_type &amp;endIndex, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt; args) const</td></tr>
<tr class="memdesc:afe9de7b15c4eb481e5a70c2572da364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan this string for integer or character values using a template and arguments.  <a href="#afe9de7b15c4eb481e5a70c2572da364a">More...</a><br /></td></tr>
<tr class="separator:afe9de7b15c4eb481e5a70c2572da364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1bd56f7f7481745ba4c1c4893ed1e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2a1bd56f7f7481745ba4c1c4893ed1e8">scan</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt; args) const</td></tr>
<tr class="memdesc:a2a1bd56f7f7481745ba4c1c4893ed1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan this string for integer or character values using a template and arguments.  <a href="#a2a1bd56f7f7481745ba4c1c4893ed1e8">More...</a><br /></td></tr>
<tr class="separator:a2a1bd56f7f7481745ba4c1c4893ed1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e4169ede0882538404ddf66ca1e32e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac8e4169ede0882538404ddf66ca1e32e">scan</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt; args) const</td></tr>
<tr class="memdesc:ac8e4169ede0882538404ddf66ca1e32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan this string for integer or character values using a template and arguments.  <a href="#ac8e4169ede0882538404ddf66ca1e32e">More...</a><br /></td></tr>
<tr class="separator:ac8e4169ede0882538404ddf66ca1e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4693cea00a3e14d15e15bc91631a97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97">similar</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;other) const</td></tr>
<tr class="memdesc:aca4693cea00a3e14d15e15bc91631a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#aca4693cea00a3e14d15e15bc91631a97">More...</a><br /></td></tr>
<tr class="separator:aca4693cea00a3e14d15e15bc91631a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf010e716088d287fbf11a182716a5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6cf010e716088d287fbf11a182716a5d">similar</a> (const void *addr, size_type size) const</td></tr>
<tr class="memdesc:a6cf010e716088d287fbf11a182716a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two strings are identical, case-insensitive and ignoring blanks.  <a href="#a6cf010e716088d287fbf11a182716a5d">More...</a><br /></td></tr>
<tr class="separator:a6cf010e716088d287fbf11a182716a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae901036faf692860190b1736c6b6087d"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ae901036faf692860190b1736c6b6087d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ae901036faf692860190b1736c6b6087d">split</a> (CONTAINER &amp;container, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> separator=<a class="el" href="namespacets.html#acddcf9feea154a5c67a07120d0012b0e">COMMA</a>, bool trimSpaces=true, bool removeEmpty=false) const</td></tr>
<tr class="memdesc:ae901036faf692860190b1736c6b6087d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the string into segments based on a separator character (comma by default).  <a href="#ae901036faf692860190b1736c6b6087d">More...</a><br /></td></tr>
<tr class="separator:ae901036faf692860190b1736c6b6087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c75eda5c711a905f131a89713da584"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a40c75eda5c711a905f131a89713da584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a40c75eda5c711a905f131a89713da584">splitBlocks</a> (CONTAINER &amp;container, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> <a class="el" href="classts_1_1_u_string.html#a98d515c33c156e797977794f6f99b91d">startWith</a>=<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>('['), <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> <a class="el" href="classts_1_1_u_string.html#ad68009763ba4fd4c4cc238e0d63c183a">endWith</a>=<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>(']'), bool trimSpaces=true) const</td></tr>
<tr class="memdesc:a40c75eda5c711a905f131a89713da584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default).  <a href="#a40c75eda5c711a905f131a89713da584">More...</a><br /></td></tr>
<tr class="separator:a40c75eda5c711a905f131a89713da584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af47dad58edc1a404deb1bd1ebc1c165c">splitLines</a> (CONTAINER &amp;container, size_type maxWidth, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;otherSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;nextMargin=<a class="el" href="classts_1_1_u_string.html">UString</a>(), bool forceSplit=false) const</td></tr>
<tr class="memdesc:af47dad58edc1a404deb1bd1ebc1c165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into multiple lines which are not longer than a specified maximum width.  <a href="#af47dad58edc1a404deb1bd1ebc1c165c">More...</a><br /></td></tr>
<tr class="separator:af47dad58edc1a404deb1bd1ebc1c165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d515c33c156e797977794f6f99b91d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a98d515c33c156e797977794f6f99b91d">startWith</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a98d515c33c156e797977794f6f99b91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string starts with a specified prefix.  <a href="#a98d515c33c156e797977794f6f99b91d">More...</a><br /></td></tr>
<tr class="separator:a98d515c33c156e797977794f6f99b91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">substitute</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;replacement)</td></tr>
<tr class="memdesc:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all occurences of a string with another one.  <a href="#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">More...</a><br /></td></tr>
<tr class="separator:a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c92ff6f2e93e196e28f688f0cd8d23c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a5c92ff6f2e93e196e28f688f0cd8d23c">toDVB</a> (uint8_t *&amp;buffer, size_t &amp;size, size_type start=0, size_type count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:a5c92ff6f2e93e196e28f688f0cd8d23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string.  <a href="#a5c92ff6f2e93e196e28f688f0cd8d23c">More...</a><br /></td></tr>
<tr class="separator:a5c92ff6f2e93e196e28f688f0cd8d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb507ace0bbbf6687a60cf6b588d95f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abb507ace0bbbf6687a60cf6b588d95f3">toDVB</a> (size_type start=0, size_type count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:abb507ace0bbbf6687a60cf6b588d95f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string.  <a href="#abb507ace0bbbf6687a60cf6b588d95f3">More...</a><br /></td></tr>
<tr class="separator:abb507ace0bbbf6687a60cf6b588d95f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0efc4cc015bce842bce7a92ec62a414"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac0efc4cc015bce842bce7a92ec62a414">toDVBWithByteLength</a> (uint8_t *&amp;buffer, size_t &amp;size, size_type start=0, size_type count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:ac0efc4cc015bce842bce7a92ec62a414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string (preceded by its one-byte length).  <a href="#ac0efc4cc015bce842bce7a92ec62a414">More...</a><br /></td></tr>
<tr class="separator:ac0efc4cc015bce842bce7a92ec62a414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5823ba0c6efa73513a15815c32f56e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a5823ba0c6efa73513a15815c32f56e03">toDVBWithByteLength</a> (size_type start=0, size_type count=<a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a>, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0) const</td></tr>
<tr class="memdesc:a5823ba0c6efa73513a15815c32f56e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this UTF-16 string into a DVB string (preceded by its one-byte length).  <a href="#a5823ba0c6efa73513a15815c32f56e03">More...</a><br /></td></tr>
<tr class="separator:a5823ba0c6efa73513a15815c32f56e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cd8101f42d1ac30096d52e010c16d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a37cd8101f42d1ac30096d52e010c16d3">toHTML</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;convert=<a class="el" href="classts_1_1_u_string.html">UString</a>()) const</td></tr>
<tr class="memdesc:a37cd8101f42d1ac30096d52e010c16d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string in a suitable HTML representation.  <a href="#a37cd8101f42d1ac30096d52e010c16d3">More...</a><br /></td></tr>
<tr class="separator:a37cd8101f42d1ac30096d52e010c16d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449be4b2b6dd646f88ba339d68a328c2"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a449be4b2b6dd646f88ba339d68a328c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a449be4b2b6dd646f88ba339d68a328c2">toInteger</a> (INT &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;thousandSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>()) const</td></tr>
<tr class="memdesc:a449be4b2b6dd646f88ba339d68a328c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into an integer.  <a href="#a449be4b2b6dd646f88ba339d68a328c2">More...</a><br /></td></tr>
<tr class="separator:a449be4b2b6dd646f88ba339d68a328c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ab823727a0686132adce31ec684d2"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER , typename std::enable_if&lt; std::is_integral&lt; typename CONTAINER::value_type &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0f4ab823727a0686132adce31ec684d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a0f4ab823727a0686132adce31ec684d2">toIntegers</a> (CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;thousandSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;listSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,; &quot;)) const</td></tr>
<tr class="memdesc:a0f4ab823727a0686132adce31ec684d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing a list of integers into a container of integers.  <a href="#a0f4ab823727a0686132adce31ec684d2">More...</a><br /></td></tr>
<tr class="separator:a0f4ab823727a0686132adce31ec684d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836195d6f9ae3df3b7a08a69dbf2847c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a836195d6f9ae3df3b7a08a69dbf2847c">toJustified</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;right, size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, size_t spacesAroundPad=0) const</td></tr>
<tr class="memdesc:a836195d6f9ae3df3b7a08a69dbf2847c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a justified string, pad in the middle.  <a href="#a836195d6f9ae3df3b7a08a69dbf2847c">More...</a><br /></td></tr>
<tr class="separator:a836195d6f9ae3df3b7a08a69dbf2847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa915f082a6760fdadd5c0925205e19bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa915f082a6760fdadd5c0925205e19bb">toJustifiedCentered</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesAroundPad=0) const</td></tr>
<tr class="memdesc:aa915f082a6760fdadd5c0925205e19bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a centered-justified (padded and optionally truncated) string.  <a href="#aa915f082a6760fdadd5c0925205e19bb">More...</a><br /></td></tr>
<tr class="separator:aa915f082a6760fdadd5c0925205e19bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2698f08d50ea3ec94147d481e6b77620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2698f08d50ea3ec94147d481e6b77620">toJustifiedLeft</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesBeforePad=0) const</td></tr>
<tr class="memdesc:a2698f08d50ea3ec94147d481e6b77620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a left-justified (padded and optionally truncated) string.  <a href="#a2698f08d50ea3ec94147d481e6b77620">More...</a><br /></td></tr>
<tr class="separator:a2698f08d50ea3ec94147d481e6b77620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff55a599211ee4685ea23881e60ab73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aff55a599211ee4685ea23881e60ab73f">toJustifiedRight</a> (size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>, bool truncate=false, size_t spacesAfterPad=0) const</td></tr>
<tr class="memdesc:aff55a599211ee4685ea23881e60ab73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a right-justified (padded and optionally truncated) string.  <a href="#aff55a599211ee4685ea23881e60ab73f">More...</a><br /></td></tr>
<tr class="separator:aff55a599211ee4685ea23881e60ab73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002290c2532a050424674a82fa504b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a002290c2532a050424674a82fa504b51">toLower</a> () const</td></tr>
<tr class="memdesc:a002290c2532a050424674a82fa504b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lower-case version of the string.  <a href="#a002290c2532a050424674a82fa504b51">More...</a><br /></td></tr>
<tr class="separator:a002290c2532a050424674a82fa504b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab419307fa43875cb5e81a0c3ad52625d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab419307fa43875cb5e81a0c3ad52625d">toRemoved</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;substr) const</td></tr>
<tr class="memdesc:ab419307fa43875cb5e81a0c3ad52625d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a substring.  <a href="#ab419307fa43875cb5e81a0c3ad52625d">More...</a><br /></td></tr>
<tr class="separator:ab419307fa43875cb5e81a0c3ad52625d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd257233cc44c47a6e2d0edb6a892dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abd257233cc44c47a6e2d0edb6a892dbd">toRemoved</a> (<a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> c) const</td></tr>
<tr class="memdesc:abd257233cc44c47a6e2d0edb6a892dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurences of a character.  <a href="#abd257233cc44c47a6e2d0edb6a892dbd">More...</a><br /></td></tr>
<tr class="separator:abd257233cc44c47a6e2d0edb6a892dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e59bbf5a8df9fed0688e6ed0429463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a24e59bbf5a8df9fed0688e6ed0429463">toRemovedPrefix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;prefix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a24e59bbf5a8df9fed0688e6ed0429463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a prefix in string.  <a href="#a24e59bbf5a8df9fed0688e6ed0429463">More...</a><br /></td></tr>
<tr class="separator:a24e59bbf5a8df9fed0688e6ed0429463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b73b9d3c2aabc966f75067a2f7e677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a13b73b9d3c2aabc966f75067a2f7e677">toRemovedSuffix</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;suffix, <a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a> cs=<a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a>) const</td></tr>
<tr class="memdesc:a13b73b9d3c2aabc966f75067a2f7e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a suffix in string.  <a href="#a13b73b9d3c2aabc966f75067a2f7e677">More...</a><br /></td></tr>
<tr class="separator:a13b73b9d3c2aabc966f75067a2f7e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cab66002ed3a2c4c16b8fb32e61c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa5cab66002ed3a2c4c16b8fb32e61c53">toReversed</a> () const</td></tr>
<tr class="memdesc:aa5cab66002ed3a2c4c16b8fb32e61c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where characters are reversed.  <a href="#aa5cab66002ed3a2c4c16b8fb32e61c53">More...</a><br /></td></tr>
<tr class="separator:aa5cab66002ed3a2c4c16b8fb32e61c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1678f1645abba2cba8d3bae907116000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a1678f1645abba2cba8d3bae907116000">toSplitLines</a> (size_type maxWidth, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;otherSeparators=<a class="el" href="classts_1_1_u_string.html">UString</a>(), const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;nextMargin=<a class="el" href="classts_1_1_u_string.html">UString</a>(), bool forceSplit=false, const <a class="el" href="classts_1_1_u_string.html">UString</a> lineSeparator=<a class="el" href="classts_1_1_u_string.html">UString</a>(1, <a class="el" href="namespacets.html#a1f22b94dcc18ebb1ca080df4a0962533">LINE_FEED</a>)) const</td></tr>
<tr class="memdesc:a1678f1645abba2cba8d3bae907116000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into multiple lines which are not longer than a specified maximum width.  <a href="#a1678f1645abba2cba8d3bae907116000">More...</a><br /></td></tr>
<tr class="separator:a1678f1645abba2cba8d3bae907116000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cda0b113d6c880d572a153a732cf3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7cda0b113d6c880d572a153a732cf3b6">toSubstituted</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;replacement) const</td></tr>
<tr class="memdesc:a7cda0b113d6c880d572a153a732cf3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where all occurences of a string are substituted with another one.  <a href="#a7cda0b113d6c880d572a153a732cf3b6">More...</a><br /></td></tr>
<tr class="separator:a7cda0b113d6c880d572a153a732cf3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8695689c7b19d7fa010de40538457388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8695689c7b19d7fa010de40538457388">toTrimmed</a> (bool leading=true, bool trailing=true) const</td></tr>
<tr class="memdesc:a8695689c7b19d7fa010de40538457388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where leading and / or trailing spaces are trimmed.  <a href="#a8695689c7b19d7fa010de40538457388">More...</a><br /></td></tr>
<tr class="separator:a8695689c7b19d7fa010de40538457388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac737a46aec050edcaf18440712b40832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac737a46aec050edcaf18440712b40832">toTruncatedWidth</a> (size_type maxWidth, <a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a> direction=<a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a>) const</td></tr>
<tr class="memdesc:ac737a46aec050edcaf18440712b40832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this string, truncated to a given display width.  <a href="#ac737a46aec050edcaf18440712b40832">More...</a><br /></td></tr>
<tr class="separator:ac737a46aec050edcaf18440712b40832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d33505aab6deaf9782d72fa11011d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3d33505aab6deaf9782d72fa11011d55">toUpper</a> () const</td></tr>
<tr class="memdesc:a3d33505aab6deaf9782d72fa11011d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an upper-case version of the string.  <a href="#a3d33505aab6deaf9782d72fa11011d55">More...</a><br /></td></tr>
<tr class="separator:a3d33505aab6deaf9782d72fa11011d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc79cf6e8fa375c618417785cc4af19d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afc79cf6e8fa375c618417785cc4af19d">toUTF8</a> () const</td></tr>
<tr class="memdesc:afc79cf6e8fa375c618417785cc4af19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this UTF-16 string into UTF-8.  <a href="#afc79cf6e8fa375c618417785cc4af19d">More...</a><br /></td></tr>
<tr class="separator:afc79cf6e8fa375c618417785cc4af19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b98d881599eb358f9ced9bd0055e0ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8b98d881599eb358f9ced9bd0055e0ca">toUTF8</a> (std::string &amp;utf8) const</td></tr>
<tr class="memdesc:a8b98d881599eb358f9ced9bd0055e0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this UTF-16 string into UTF-8.  <a href="#a8b98d881599eb358f9ced9bd0055e0ca">More...</a><br /></td></tr>
<tr class="separator:a8b98d881599eb358f9ced9bd0055e0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e06a17d20d02a2eeeef09400b01669d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3e06a17d20d02a2eeeef09400b01669d">trim</a> (bool leading=true, bool trailing=true)</td></tr>
<tr class="memdesc:a3e06a17d20d02a2eeeef09400b01669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and / or trailing space characters.  <a href="#a3e06a17d20d02a2eeeef09400b01669d">More...</a><br /></td></tr>
<tr class="separator:a3e06a17d20d02a2eeeef09400b01669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75294cf252a668d4bf88ea026e6f3c83"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a75294cf252a668d4bf88ea026e6f3c83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a75294cf252a668d4bf88ea026e6f3c83">trimLength</a> (INT length, bool trimTrailingSpaces=true)</td></tr>
<tr class="memdesc:a75294cf252a668d4bf88ea026e6f3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the size of the string to a given length from an alien integer type.  <a href="#a75294cf252a668d4bf88ea026e6f3c83">More...</a><br /></td></tr>
<tr class="separator:a75294cf252a668d4bf88ea026e6f3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc41789063ebea5813478c7b8530fd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afc41789063ebea5813478c7b8530fd02">truncateWidth</a> (size_type maxWidth, <a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a> direction=<a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a>)</td></tr>
<tr class="memdesc:afc41789063ebea5813478c7b8530fd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate this string to a given display width.  <a href="#afc41789063ebea5813478c7b8530fd02">More...</a><br /></td></tr>
<tr class="separator:afc41789063ebea5813478c7b8530fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a15cf87a1e3453dafbe7ac1feca1ea"><td class="memItemLeft" align="right" valign="top">const ::WCHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a55a15cf87a1e3453dafbe7ac1feca1ea">wc_str</a> () const</td></tr>
<tr class="memdesc:a55a15cf87a1e3453dafbe7ac1feca1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the underlying null-terminated Unicode string (Windows-specific).  <a href="#a55a15cf87a1e3453dafbe7ac1feca1ea">More...</a><br /></td></tr>
<tr class="separator:a55a15cf87a1e3453dafbe7ac1feca1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f8469f96e5edc75beda2ddc80cfc5d"><td class="memItemLeft" align="right" valign="top">::WCHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a55f8469f96e5edc75beda2ddc80cfc5d">wc_str</a> ()</td></tr>
<tr class="memdesc:a55f8469f96e5edc75beda2ddc80cfc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the underlying null-terminated Unicode string (Windows-specific).  <a href="#a55f8469f96e5edc75beda2ddc80cfc5d">More...</a><br /></td></tr>
<tr class="separator:a55f8469f96e5edc75beda2ddc80cfc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c9e8a315f34bbc971b029af58555a3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a> () const</td></tr>
<tr class="memdesc:a34c9e8a315f34bbc971b029af58555a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the display width in characters.  <a href="#a34c9e8a315f34bbc971b029af58555a3">More...</a><br /></td></tr>
<tr class="separator:a34c9e8a315f34bbc971b029af58555a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8603bb308c210616a211a5df4eb1cc54"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a8603bb308c210616a211a5df4eb1cc54">AfterBytes</a> (const std::streampos &amp;position)</td></tr>
<tr class="memdesc:a8603bb308c210616a211a5df4eb1cc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an error message fragment indicating the number of bytes previously read in a binary file.  <a href="#a8603bb308c210616a211a5df4eb1cc54">More...</a><br /></td></tr>
<tr class="separator:a8603bb308c210616a211a5df4eb1cc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b158f71eccccebe0f571898fdb0956f"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a7b158f71eccccebe0f571898fdb0956f"><td class="memTemplItemLeft" align="right" valign="top">static CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a7b158f71eccccebe0f571898fdb0956f">Append</a> (CONTAINER &amp;container, int argc, const char *const argv[])</td></tr>
<tr class="memdesc:a7b158f71eccccebe0f571898fdb0956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of C-strings to a container of strings.  <a href="#a7b158f71eccccebe0f571898fdb0956f">More...</a><br /></td></tr>
<tr class="separator:a7b158f71eccccebe0f571898fdb0956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb773145eef27188125e102d1f491c5"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:adbb773145eef27188125e102d1f491c5"><td class="memTemplItemLeft" align="right" valign="top">static CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#adbb773145eef27188125e102d1f491c5">Append</a> (CONTAINER &amp;container, int argc, char *const argv[])</td></tr>
<tr class="memdesc:adbb773145eef27188125e102d1f491c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of C-strings to a container of strings.  <a href="#adbb773145eef27188125e102d1f491c5">More...</a><br /></td></tr>
<tr class="separator:adbb773145eef27188125e102d1f491c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47539b2921afa55f75b49bee47770dc5"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a47539b2921afa55f75b49bee47770dc5"><td class="memTemplItemLeft" align="right" valign="top">static CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a47539b2921afa55f75b49bee47770dc5">Assign</a> (CONTAINER &amp;container, int argc, const char *const argv[])</td></tr>
<tr class="memdesc:a47539b2921afa55f75b49bee47770dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an array of C-strings to a container of strings.  <a href="#a47539b2921afa55f75b49bee47770dc5">More...</a><br /></td></tr>
<tr class="separator:a47539b2921afa55f75b49bee47770dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3bb6eaa7ad0eb248c94d5ea40e5aef"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a2e3bb6eaa7ad0eb248c94d5ea40e5aef"><td class="memTemplItemLeft" align="right" valign="top">static CONTAINER &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2e3bb6eaa7ad0eb248c94d5ea40e5aef">Assign</a> (CONTAINER &amp;container, int argc, char *const argv[])</td></tr>
<tr class="memdesc:a2e3bb6eaa7ad0eb248c94d5ea40e5aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an array of C-strings to a container of strings.  <a href="#a2e3bb6eaa7ad0eb248c94d5ea40e5aef">More...</a><br /></td></tr>
<tr class="separator:a2e3bb6eaa7ad0eb248c94d5ea40e5aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2944af208289c54c40a82b6c819a8e8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2944af208289c54c40a82b6c819a8e8a">ConvertUTF16ToUTF8</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;inStart, const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *inEnd, char *&amp;outStart, char *outEnd)</td></tr>
<tr class="memdesc:a2944af208289c54c40a82b6c819a8e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General routine to convert from UTF-16 to UTF-8.  <a href="#a2944af208289c54c40a82b6c819a8e8a">More...</a><br /></td></tr>
<tr class="separator:a2944af208289c54c40a82b6c819a8e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">ConvertUTF8ToUTF16</a> (const char *&amp;inStart, const char *inEnd, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;outStart, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *outEnd)</td></tr>
<tr class="memdesc:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">General routine to convert from UTF-8 to UTF-16.  <a href="#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">More...</a><br /></td></tr>
<tr class="separator:ab2fdb093c4b8ffaa02144aa5e9f2fcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b50a1c0e877f78224e765fbba6548f9"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b50a1c0e877f78224e765fbba6548f9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3b50a1c0e877f78224e765fbba6548f9">Decimal</a> (INT value, size_type min_width=0, bool right_justified=true, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html#a9bd59e53d29608b017496aa06cf4092f">DEFAULT_THOUSANDS_SEPARATOR</a>, bool force_sign=false, <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> pad=<a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a>)</td></tr>
<tr class="memdesc:a3b50a1c0e877f78224e765fbba6548f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string containing a decimal value.  <a href="#a3b50a1c0e877f78224e765fbba6548f9">More...</a><br /></td></tr>
<tr class="separator:a3b50a1c0e877f78224e765fbba6548f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55f25f55f2cdc5ac4c203348f62c5c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac55f25f55f2cdc5ac4c203348f62c5c6">Dump</a> (const void *data, size_type size, uint32_t flags=<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a>, size_type <a class="el" href="namespacets.html#a45875f9eaab18c02b57b9fbd2e216d3d">indent</a>=0, size_type line_width=<a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a>, size_type init_offset=0, size_type inner_indent=0)</td></tr>
<tr class="memdesc:ac55f25f55f2cdc5ac4c203348f62c5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a multi-line string containing the hexadecimal dump of a memory area.  <a href="#ac55f25f55f2cdc5ac4c203348f62c5c6">More...</a><br /></td></tr>
<tr class="separator:ac55f25f55f2cdc5ac4c203348f62c5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5d06223a12ccb05bacf97e160c5d77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aed5d06223a12ccb05bacf97e160c5d77">Dump</a> (const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;bb, uint32_t flags=<a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a>, size_type <a class="el" href="namespacets.html#a45875f9eaab18c02b57b9fbd2e216d3d">indent</a>=0, size_type line_width=<a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a>, size_type init_offset=0, size_type inner_indent=0)</td></tr>
<tr class="memdesc:aed5d06223a12ccb05bacf97e160c5d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a multi-line string containing the hexadecimal dump of a memory area.  <a href="#aed5d06223a12ccb05bacf97e160c5d77">More...</a><br /></td></tr>
<tr class="separator:aed5d06223a12ccb05bacf97e160c5d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac700959acea9ad3915f6d19cae5b8612"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">Format</a> (const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_in.html">ArgMixIn</a> &gt; args)</td></tr>
<tr class="memdesc:ac700959acea9ad3915f6d19cae5b8612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string using a template and arguments.  <a href="#ac700959acea9ad3915f6d19cae5b8612">More...</a><br /></td></tr>
<tr class="separator:ac700959acea9ad3915f6d19cae5b8612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618790677ea9b093c381cb58526527f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a618790677ea9b093c381cb58526527f2">Format</a> (const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fmt, std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_in.html">ArgMixIn</a> &gt; args)</td></tr>
<tr class="memdesc:a618790677ea9b093c381cb58526527f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string using a template and arguments.  <a href="#a618790677ea9b093c381cb58526527f2">More...</a><br /></td></tr>
<tr class="separator:a618790677ea9b093c381cb58526527f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16c26a8d856cbead7185eb3a733b235"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ab16c26a8d856cbead7185eb3a733b235">FromDVB</a> (const std::string &amp;dvb, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:ab16c26a8d856cbead7185eb3a733b235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16.  <a href="#ab16c26a8d856cbead7185eb3a733b235">More...</a><br /></td></tr>
<tr class="separator:ab16c26a8d856cbead7185eb3a733b235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a10ffa3104cf15fdca38a1e01b3be6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a94a10ffa3104cf15fdca38a1e01b3be6">FromDVB</a> (const uint8_t *dvb, size_type dvbSize, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:a94a10ffa3104cf15fdca38a1e01b3be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16.  <a href="#a94a10ffa3104cf15fdca38a1e01b3be6">More...</a><br /></td></tr>
<tr class="separator:a94a10ffa3104cf15fdca38a1e01b3be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0944b55ecf6f9507cba1213e4eedea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a5d0944b55ecf6f9507cba1213e4eedea">FromDVBWithByteLength</a> (const uint8_t *&amp;buffer, size_t &amp;size, const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *charset=0)</td></tr>
<tr class="memdesc:a5d0944b55ecf6f9507cba1213e4eedea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DVB string into UTF-16 (preceded by its one-byte length).  <a href="#a5d0944b55ecf6f9507cba1213e4eedea">More...</a><br /></td></tr>
<tr class="separator:a5d0944b55ecf6f9507cba1213e4eedea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad271cf6c698902327f1f13dba1081732"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad271cf6c698902327f1f13dba1081732">FromUTF8</a> (const std::string &amp;utf8)</td></tr>
<tr class="memdesc:ad271cf6c698902327f1f13dba1081732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#ad271cf6c698902327f1f13dba1081732">More...</a><br /></td></tr>
<tr class="separator:ad271cf6c698902327f1f13dba1081732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87772f991912a5469b39243698ce413"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aa87772f991912a5469b39243698ce413">FromUTF8</a> (const char *utf8)</td></tr>
<tr class="memdesc:aa87772f991912a5469b39243698ce413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#aa87772f991912a5469b39243698ce413">More...</a><br /></td></tr>
<tr class="separator:aa87772f991912a5469b39243698ce413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6f1dde40bb81fda96e23d91512c6ee0e">FromUTF8</a> (const char *utf8, size_type count)</td></tr>
<tr class="memdesc:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF-8 string into UTF-16.  <a href="#a6f1dde40bb81fda96e23d91512c6ee0e">More...</a><br /></td></tr>
<tr class="separator:a6f1dde40bb81fda96e23d91512c6ee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e86799482cd921d27d074fd1a44e42"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a59e86799482cd921d27d074fd1a44e42"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42">Hexa</a> (INT value, size_type <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3">width</a>=0, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html">UString</a>(), bool use_prefix=true, bool use_upper=true)</td></tr>
<tr class="memdesc:a59e86799482cd921d27d074fd1a44e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string containing an hexadecimal value.  <a href="#a59e86799482cd921d27d074fd1a44e42">More...</a><br /></td></tr>
<tr class="separator:a59e86799482cd921d27d074fd1a44e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a57baf99dd4b3ab0eac7b86aa66deb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac4a57baf99dd4b3ab0eac7b86aa66deb">HumanSize</a> (int64_t value, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;units=u&quot;B&quot;, bool forceSign=false)</td></tr>
<tr class="memdesc:ac4a57baf99dd4b3ab0eac7b86aa66deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a human-readable size using MB, kB or B as appropriate.  <a href="#ac4a57baf99dd4b3ab0eac7b86aa66deb">More...</a><br /></td></tr>
<tr class="separator:ac4a57baf99dd4b3ab0eac7b86aa66deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc537ce77d01338e58ca62e4a13333e"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:a2bc537ce77d01338e58ca62e4a13333e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2bc537ce77d01338e58ca62e4a13333e">Join</a> (ITERATOR begin, ITERATOR end, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;, &quot;))</td></tr>
<tr class="memdesc:a2bc537ce77d01338e58ca62e4a13333e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a part of a container of strings into one big string.  <a href="#a2bc537ce77d01338e58ca62e4a13333e">More...</a><br /></td></tr>
<tr class="separator:a2bc537ce77d01338e58ca62e4a13333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad588ea96fd23a229717b2654f9ea4b"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a6ad588ea96fd23a229717b2654f9ea4b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a6ad588ea96fd23a229717b2654f9ea4b">Join</a> (const CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;separator=<a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;, &quot;))</td></tr>
<tr class="memdesc:a6ad588ea96fd23a229717b2654f9ea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a container of strings into one big string.  <a href="#a6ad588ea96fd23a229717b2654f9ea4b">More...</a><br /></td></tr>
<tr class="separator:a6ad588ea96fd23a229717b2654f9ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe629667846a5cf415f5c58bba702bab"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:afe629667846a5cf415f5c58bba702bab"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#afe629667846a5cf415f5c58bba702bab">Load</a> (CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fileName)</td></tr>
<tr class="memdesc:afe629667846a5cf415f5c58bba702bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container.  <a href="#afe629667846a5cf415f5c58bba702bab">More...</a><br /></td></tr>
<tr class="separator:afe629667846a5cf415f5c58bba702bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954c077cb499376b944878a196d40c02"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a954c077cb499376b944878a196d40c02"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a954c077cb499376b944878a196d40c02">Load</a> (CONTAINER &amp;container, std::istream &amp;strm)</td></tr>
<tr class="memdesc:a954c077cb499376b944878a196d40c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container.  <a href="#a954c077cb499376b944878a196d40c02">More...</a><br /></td></tr>
<tr class="separator:a954c077cb499376b944878a196d40c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13fec902f25f9317538fd8da1505025"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ad13fec902f25f9317538fd8da1505025"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad13fec902f25f9317538fd8da1505025">LoadAppend</a> (CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fileName)</td></tr>
<tr class="memdesc:ad13fec902f25f9317538fd8da1505025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container.  <a href="#ad13fec902f25f9317538fd8da1505025">More...</a><br /></td></tr>
<tr class="separator:ad13fec902f25f9317538fd8da1505025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739ac8da0afe4ef26ace80e88a1c0af"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:ad739ac8da0afe4ef26ace80e88a1c0af"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ad739ac8da0afe4ef26ace80e88a1c0af">LoadAppend</a> (CONTAINER &amp;container, std::istream &amp;strm)</td></tr>
<tr class="memdesc:ad739ac8da0afe4ef26ace80e88a1c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container.  <a href="#ad739ac8da0afe4ef26ace80e88a1c0af">More...</a><br /></td></tr>
<tr class="separator:ad739ac8da0afe4ef26ace80e88a1c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7049b2f840423a0106dc8e1935f5d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a3b7049b2f840423a0106dc8e1935f5d6">OnOff</a> (bool b)</td></tr>
<tr class="memdesc:a3b7049b2f840423a0106dc8e1935f5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "on" or "off".  <a href="#a3b7049b2f840423a0106dc8e1935f5d6">More...</a><br /></td></tr>
<tr class="separator:a3b7049b2f840423a0106dc8e1935f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db698cf1abf39e1ef090661809fd61a"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0db698cf1abf39e1ef090661809fd61a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a0db698cf1abf39e1ef090661809fd61a">Percentage</a> (INT value, INT total)</td></tr>
<tr class="memdesc:a0db698cf1abf39e1ef090661809fd61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a percentage string.  <a href="#a0db698cf1abf39e1ef090661809fd61a">More...</a><br /></td></tr>
<tr class="separator:a0db698cf1abf39e1ef090661809fd61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f7c50f262b91894244c9678153ee53"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:a46f7c50f262b91894244c9678153ee53"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a46f7c50f262b91894244c9678153ee53">Save</a> (ITERATOR begin, ITERATOR end, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:a46f7c50f262b91894244c9678153ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, in UTF-8 format, one per line.  <a href="#a46f7c50f262b91894244c9678153ee53">More...</a><br /></td></tr>
<tr class="separator:a46f7c50f262b91894244c9678153ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece15e68005ce38cb656afe125df8f54"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:aece15e68005ce38cb656afe125df8f54"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aece15e68005ce38cb656afe125df8f54">Save</a> (const CONTAINER &amp;container, const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;fileName, bool append=false)</td></tr>
<tr class="memdesc:aece15e68005ce38cb656afe125df8f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, in UTF-8 format, one per line.  <a href="#aece15e68005ce38cb656afe125df8f54">More...</a><br /></td></tr>
<tr class="separator:aece15e68005ce38cb656afe125df8f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f019a070c0a77d35be1eeba6b4af4f"><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr class="memitem:af7f019a070c0a77d35be1eeba6b4af4f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af7f019a070c0a77d35be1eeba6b4af4f">Save</a> (ITERATOR begin, ITERATOR end, std::ostream &amp;strm)</td></tr>
<tr class="memdesc:af7f019a070c0a77d35be1eeba6b4af4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a stream, in UTF-8 format, one per line.  <a href="#af7f019a070c0a77d35be1eeba6b4af4f">More...</a><br /></td></tr>
<tr class="separator:af7f019a070c0a77d35be1eeba6b4af4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b19e0136941b78723c0aa8e89f1b26"><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr class="memitem:a12b19e0136941b78723c0aa8e89f1b26"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a12b19e0136941b78723c0aa8e89f1b26">Save</a> (const CONTAINER &amp;container, std::ostream &amp;strm)</td></tr>
<tr class="memdesc:a12b19e0136941b78723c0aa8e89f1b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save strings from a container into a file, in UTF-8 format, one per line.  <a href="#a12b19e0136941b78723c0aa8e89f1b26">More...</a><br /></td></tr>
<tr class="separator:a12b19e0136941b78723c0aa8e89f1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c1f90aff1a79985d15b5edd864355"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#af22c1f90aff1a79985d15b5edd864355">TrueFalse</a> (bool b)</td></tr>
<tr class="memdesc:af22c1f90aff1a79985d15b5edd864355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "true" or "false".  <a href="#af22c1f90aff1a79985d15b5edd864355">More...</a><br /></td></tr>
<tr class="separator:af22c1f90aff1a79985d15b5edd864355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abcccd14ec7f4e0404c781a8eaf9becd2">YesNo</a> (bool b)</td></tr>
<tr class="memdesc:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a boolean value as "yes" or "no".  <a href="#abcccd14ec7f4e0404c781a8eaf9becd2">More...</a><br /></td></tr>
<tr class="separator:abcccd14ec7f4e0404c781a8eaf9becd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abb53f302e6507cbd34844f1b0a49f663"><td class="memItemLeft" align="right" valign="top"><a id="abb53f302e6507cbd34844f1b0a49f663"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a> = 78</td></tr>
<tr class="memdesc:abb53f302e6507cbd34844f1b0a49f663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default line width for the <a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42" title="Format a string containing an hexadecimal value. ">Hexa()</a> family of methods. <br /></td></tr>
<tr class="separator:abb53f302e6507cbd34844f1b0a49f663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd59e53d29608b017496aa06cf4092f"><td class="memItemLeft" align="right" valign="top"><a id="a9bd59e53d29608b017496aa06cf4092f"></a>
static const <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a9bd59e53d29608b017496aa06cf4092f">DEFAULT_THOUSANDS_SEPARATOR</a></td></tr>
<tr class="memdesc:a9bd59e53d29608b017496aa06cf4092f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default separator string for groups of thousands, a comma. <br /></td></tr>
<tr class="separator:a9bd59e53d29608b017496aa06cf4092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b86f4792daf9d739b122d1384da1a2"><td class="memItemLeft" align="right" valign="top"><a id="ac2b86f4792daf9d739b122d1384da1a2"></a>
static const <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#ac2b86f4792daf9d739b122d1384da1a2">EMPTY</a></td></tr>
<tr class="memdesc:ac2b86f4792daf9d739b122d1384da1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference empty string. <br /></td></tr>
<tr class="separator:ac2b86f4792daf9d739b122d1384da1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="memItemLeft" align="right" valign="top">static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></td></tr>
<tr class="memdesc:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative value for the standard <code>npos</code> value.  <a href="#aab6ad2cee0b7043e14e3c833c6e3d263">More...</a><br /></td></tr>
<tr class="separator:aab6ad2cee0b7043e14e3c833c6e3d263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e270e77a9a7377f73cb0b698b4044"><td class="memItemLeft" align="right" valign="top"><a id="a2b6e270e77a9a7377f73cb0b698b4044"></a>
static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a2b6e270e77a9a7377f73cb0b698b4044">UTF8_BOM</a></td></tr>
<tr class="memdesc:a2b6e270e77a9a7377f73cb0b698b4044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 3-byte so-called "UTF-8 Byte Order Mark". <br /></td></tr>
<tr class="separator:a2b6e270e77a9a7377f73cb0b698b4044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4534a29dd91c13770d304d07b08fdc"><td class="memItemLeft" align="right" valign="top"><a id="aec4534a29dd91c13770d304d07b08fdc"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#aec4534a29dd91c13770d304d07b08fdc">UTF8_BOM_SIZE</a> = 3</td></tr>
<tr class="memdesc:aec4534a29dd91c13770d304d07b08fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the so-called "UTF-8 Byte Order Mark". <br /></td></tr>
<tr class="separator:aec4534a29dd91c13770d304d07b08fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49492a6e6d9e8eb532264f7d1f780c6a"><td class="memItemLeft" align="right" valign="top"><a id="a49492a6e6d9e8eb532264f7d1f780c6a"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_u_string.html#a49492a6e6d9e8eb532264f7d1f780c6a">UTF8_CHAR_MAX_SIZE</a> = 4</td></tr>
<tr class="memdesc:a49492a6e6d9e8eb532264f7d1f780c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size in bytes of an UTF-8 encoded character. <br /></td></tr>
<tr class="separator:a49492a6e6d9e8eb532264f7d1f780c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of UTF-16 strings. </p>
<p>This class is an extension of <code>std::u16string</code> with additional services.</p>
<p>The class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> implements Java-like Unicode strings. Each character uses 16 bits of storage. Formally, <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> uses UTF-16 representation. This means that all characters from all modern languages can be represented as one single character. Characters from archaic languages may need two UTF-16 values, called a "surrogate pair".</p>
<p>The element of a <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> is a <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> (or <code>char16_t</code>). Nul-terminated strings of <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> are implicitly converted to <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> when necessary. Be aware that strings literals of <code>char16_t</code> are prefixed by a letter <code>u</code> as illustrated below:</p>
<div class="fragment"><div class="line"><a class="code" href="classts_1_1_u_string.html">ts::UString</a> s1(u<span class="stringliteral">&quot;abcd&quot;</span>);</div><div class="line"><a class="code" href="classts_1_1_u_string.html">ts::UString</a> s2 = s1 + u<span class="stringliteral">&quot;efgh&quot;</span>;</div></div><!-- fragment --><p>Some interesting features in class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> are:</p>
<ul>
<li>Explicit and implicit(*) conversions between UTF-8 and UTF-16.</li>
<li>Including automatic conversion to UTF-8 when writing to text streams.</li>
<li>Conversions with DVB character sets.</li>
<li>Conversions with HTML encoding.</li>
<li>Management of "display width", that is to say the amount of space which is used when the string is displayed. This can be different from the string length in the presence of combining diacritical characters or surrogate pairs.</li>
<li>String padding, trimming, truncation, justification, case conversions.</li>
<li>Substring, prefix or suffix detection, removal or substitution.</li>
<li>Splitting and joining strings based on separators or line widths.</li>
<li>Reading or writing text lines from or to a text file.</li>
<li>Data formatting using <a class="el" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612" title="Format a string using a template and arguments. ">Format()</a>, <a class="el" href="classts_1_1_u_string.html#a3b50a1c0e877f78224e765fbba6548f9" title="Format a string containing a decimal value. ">Decimal()</a>, <a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42" title="Format a string containing an hexadecimal value. ">Hexa()</a> or <a class="el" href="classts_1_1_u_string.html#ac55f25f55f2cdc5ac4c203348f62c5c6" title="Build a multi-line string containing the hexadecimal dump of a memory area. ">Dump()</a>.</li>
<li>Data scanning using <a class="el" href="classts_1_1_u_string.html#ae9ad4436655c7622b184598f5dd7593d" title="Scan this string for integer or character values using a template and arguments. ">scan()</a>.</li>
</ul>
<p>(*) Implicit conversions from UTF-8 C-strings (<code>const char*</code>) and <code>std::string</code> are disabled by default. You may enabled implicit conversions by defining <code>TS_ALLOW_IMPLICIT_UTF8_CONVERSION</code> before including <a class="el" href="ts_u_string_8h.html" title="Unicode string. ">tsUString.h</a>. Thus, there is no need to explicitly invoke <a class="el" href="classts_1_1_u_string.html#ad271cf6c698902327f1f13dba1081732" title="Convert an UTF-8 string into UTF-16. ">FromUTF8()</a> all the time. However, leaving the implicit conversions disabled has some advantages like flagging useless and costly UTF-8 conversions, for instance when string literals are incorrectly spelled as illustrated below:</p>
<div class="fragment"><div class="line"><a class="code" href="classts_1_1_u_string.html">ts::UString</a> us;</div><div class="line"></div><div class="line">us = <span class="stringliteral">&quot;efgh&quot;</span>;               <span class="comment">// only if implicit conversions are enabled</span></div><div class="line">us = u<span class="stringliteral">&quot;efgh&quot;</span>;              <span class="comment">// always ok and much faster</span></div><div class="line"></div><div class="line">std::string s;</div><div class="line">us = <a class="code" href="classts_1_1_u_string.html#ad271cf6c698902327f1f13dba1081732">UString::FromUTF8</a>(s); <span class="comment">// always ok</span></div><div class="line">us.<a class="code" href="classts_1_1_u_string.html#a9ee876ece8dca88451f3a0ceefc503c5">assignFromUTF8</a>(s);      <span class="comment">// always ok, probably faster</span></div><div class="line">us = s;                    <span class="comment">// only if implicit conversions are enabled</span></div></div><!-- fragment --><p>Unicode strings can be converted to and from DVB strings. Most DVB-defined character sets are implemented (see the class <a class="el" href="classts_1_1_d_v_b_charset.html" title="Definition of a character set for DVB encoding. ">DVBCharset</a>) and recognized when a string is read from a descriptor.</p>
<p>When a string is serialized into a binary DVB descriptor, the most appropriate DVB character set is used. In practice, a few known DVB character sets are used and when the string cannot be encoded in any of them UTF-8 is used (UTF-8 is a valid DVB character set).</p>
<p>Warning for maintainers: The standard classes <code>std::u16string</code> and <code>std::basic_string</code> do not have virtual destructors. The means that if a <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> is destroyed through, for instance, a <code>std::u16string*</code>, the destructor for the class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> will not be invoked. This is not a problem as long as the <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> subclass does not have any field to destroy, which is the case for the current implementation. When modifying the <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> class, make sure to avoid any issue with the absence of virtual destructor in the parent class. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a95e758037651fab003f10b568b08cb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e758037651fab003f10b568b08cb46">&#9670;&nbsp;</a></span>HexaFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46">ts::UString::HexaFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for the <a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42" title="Format a string containing an hexadecimal value. ">Hexa()</a> family of methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e"></a>HEXA&#160;</td><td class="fielddoc"><p>Dump hexa values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46a7b28ae996daf573879de011a9272213e"></a>ASCII&#160;</td><td class="fielddoc"><p>Dump ascii values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46a1fe85f01480cd855bab2b74584decc18"></a>OFFSET&#160;</td><td class="fielddoc"><p>Display address offsets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46aeb77a0b83f6ffb378b7aa4bfd2ea92ec"></a>WIDE_OFFSET&#160;</td><td class="fielddoc"><p>Always wide offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46ab48832764b88fc047c7240a4db697bf6"></a>SINGLE_LINE&#160;</td><td class="fielddoc"><p>Hexa on one single line, no line feed, ignore other flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46a5bd17b48ecd9481285308f1de417c869"></a>BPL&#160;</td><td class="fielddoc"><p>Interpret <em>max_line_width</em> as number of displayed Bytes Per Line (BPL). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46a4a731657054e8daa7bcdc57addbdf2e8"></a>C_STYLE&#160;</td><td class="fielddoc"><p>C-style hexa value(u"0xXX," instead of "XX"). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46ab64e5ff12cf560fa6b044102cb03ba57"></a>BINARY&#160;</td><td class="fielddoc"><p>Dump binary values ("XXXXXXXX" binary digits). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46ae537565b2b54076ff5177385d44b0e9f"></a>BIN_NIBBLE&#160;</td><td class="fielddoc"><p>Binary values are grouped by nibble ("XXXX XXXX"). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95e758037651fab003f10b568b08cb46addb530d5c14f429cbf46e9496ea22ed5"></a>COMPACT&#160;</td><td class="fielddoc"><p>Same as SINGLE_LINE but use a compact display without space. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7a31440c72d769f58289151ad46f7513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a31440c72d769f58289151ad46f7513">&#9670;&nbsp;</a></span>UString() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using an allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b39ae35147d3c1db888a0ed4ec603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b39ae35147d3c1db888a0ed4ec603b">&#9670;&nbsp;</a></span>UString() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other instance to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bc5c2b2f8ad7532406fbee57ccf958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc5c2b2f8ad7532406fbee57ccf958">&#9670;&nbsp;</a></span>UString() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>Other instance to move. Upon return, <em>other</em> is left in valid, but unspecified state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4da08e8b553dee75af9516c03207146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da08e8b553dee75af9516c03207146">&#9670;&nbsp;</a></span>UString() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a repetition of the same character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Initial size of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Character to repeat <em>count</em> times. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe1d201f0c6f3cdf175442ca3c2190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe1d201f0c6f3cdf175442ca3c2190b">&#9670;&nbsp;</a></span>UString() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html#aee7ce465657a81ff26b97df471188cb0">SuperClass</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a substring. </p>
<p>The object receives the substring <em>other</em> [<em>pos</em>, <em>pos</em> + <em>count</em>). If <em>count</em> == <code>npos</code> or if the requested substring lasts past the end of the string, the resulting substring is [<em>pos</em>, <code>size()</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other instance to partially copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Initial position to copy in <em>other</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of character to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb04716b7d224778c26c725ab4ea578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb04716b7d224778c26c725ab4ea578">&#9670;&nbsp;</a></span>UString() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a Unicode string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Address of a string. Can be a null pointer if <em>count</em> is zero, in which case the string is empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of characters to copy from <em>s</em>. That number of characters is always copied, including null characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a34703f374f7946dc6e29591b330ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a34703f374f7946dc6e29591b330ae8">&#9670;&nbsp;</a></span>UString() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a null-terminated Unicode string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Address of a null-terminated string. Can be a null pointer, in which case the string is empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeda3998f754d6de7b3c62dd7460f78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeda3998f754d6de7b3c62dd7460f78e">&#9670;&nbsp;</a></span>UString() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CHARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using a <code>std::vector</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>The vector of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to include in the string. Stop before the first nul character before <em>max</em>. Can be of any integer type, including a signed type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7140e9d00ddf163509052fb12e3a98e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7140e9d00ddf163509052fb12e3a98e1">&#9670;&nbsp;</a></span>UString() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CHARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using a <code>std::vector</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>The vector of characters. Nul-terminated string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04706a597606a7db176aba33f22bb2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04706a597606a7db176aba33f22bb2cd">&#9670;&nbsp;</a></span>UString() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , std::size_t SIZE, typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; CHARTYPE, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using a <code>std::array</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">SIZE</td><td>The size of the array. </td></tr>
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to include in the string. Stop before the first nul character before <em>max</em>. Can be of any integer type, including a signed type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12141f76f3a68149ea8de11e7b0671a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12141f76f3a68149ea8de11e7b0671a8">&#9670;&nbsp;</a></span>UString() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; CHARTYPE, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using a <code>std::array</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">SIZE</td><td>The size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array of characters. Nul-terminated string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ff90a3d47d9103fc41846448834a7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff90a3d47d9103fc41846448834a7dd">&#9670;&nbsp;</a></span>UString() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from iterators. </p>
<p>Constructs the string with the contents of the range [<em>first</em>, @ last). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>An iterator type to containers of <code>Char</code>. If <em>InputIt</em> is an integral type, equivalent to <code>String(static_cast&lt;size_type&gt;(first), static_cast&lt;Char&gt;(last), alloc)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first position to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator after the last position to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2ef21f8e1a9ac503c71375b8dbe0aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ef21f8e1a9ac503c71375b8dbe0aa2">&#9670;&nbsp;</a></span>UString() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initializer list of <code>Char</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0de87d27027309dee3f54df1f53441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0de87d27027309dee3f54df1f53441">&#9670;&nbsp;</a></span>UString() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<p>Available only when the macro <code>TS_ALLOW_IMPLICIT_UTF8_CONVERSION</code> is externally defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc2599922bec48046341619bc9f7cb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2599922bec48046341619bc9f7cb92">&#9670;&nbsp;</a></span>UString() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<p>Available only when the macro <code>TS_ALLOW_IMPLICIT_UTF8_CONVERSION</code> is externally defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af88905c4e822ed8b392d0e00a44f2324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88905c4e822ed8b392d0e00a44f2324">&#9670;&nbsp;</a></span>UString() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ts::UString::UString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an UTF-8 string. </p>
<p>Available only when the macro <code>TS_ALLOW_IMPLICIT_UTF8_CONVERSION</code> is externally defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad271cf6c698902327f1f13dba1081732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad271cf6c698902327f1f13dba1081732">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. </dd></dl>

</div>
</div>
<a id="aa87772f991912a5469b39243698ce413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87772f991912a5469b39243698ce413">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Empty string if <em>utf8</em> is a null pointer. </dd></dl>

</div>
</div>
<a id="a6f1dde40bb81fda96e23d91512c6ee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1dde40bb81fda96e23d91512c6ee0e">&#9670;&nbsp;</a></span>FromUTF8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Empty string if <em>utf8</em> is a null pointer. </dd></dl>

</div>
</div>
<a id="a9ee876ece8dca88451f3a0ceefc503c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee876ece8dca88451f3a0ceefc503c5">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>A string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a967764daaa4aff678e7cc605a6cd1ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967764daaa4aff678e7cc605a6cd1ed5">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a nul-terminated string in UTF-8 representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a164f4081accc66418dfe274215e04dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164f4081accc66418dfe274215e04dba">&#9670;&nbsp;</a></span>assignFromUTF8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assignFromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF-8 string into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8</td><td>Address of a string in UTF-8 representation. Can be null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size in bytes of the UTF-8 string (not necessarily a number of characters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="afc79cf6e8fa375c618417785cc4af19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc79cf6e8fa375c618417785cc4af19d">&#9670;&nbsp;</a></span>toUTF8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ts::UString::toUTF8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this UTF-16 string into UTF-8. </p>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-8 string. </dd></dl>

</div>
</div>
<a id="a8b98d881599eb358f9ced9bd0055e0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b98d881599eb358f9ced9bd0055e0ca">&#9670;&nbsp;</a></span>toUTF8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::toUTF8 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this UTF-16 string into UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">utf8</td><td>The equivalent UTF-8 string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2944af208289c54c40a82b6c819a8e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2944af208289c54c40a82b6c819a8e8a">&#9670;&nbsp;</a></span>ConvertUTF16ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ts::UString::ConvertUTF16ToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;&#160;</td>
          <td class="paramname"><em>inStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>inEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>outStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General routine to convert from UTF-16 to UTF-8. </p>
<p>Stop when the input buffer is empty or the output buffer is full, whichever comes first. Invalid input values are silently ignored and skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inStart</td><td>Address of the input UTF-16 buffer to convert. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inEnd</td><td>Address after the end of the input UTF-16 buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outStart</td><td>Address of the output UTF-8 buffer to fill. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outEnd</td><td>Address after the end of the output UTF-8 buffer to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2fdb093c4b8ffaa02144aa5e9f2fcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fdb093c4b8ffaa02144aa5e9f2fcfe">&#9670;&nbsp;</a></span>ConvertUTF8ToUTF16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ts::UString::ConvertUTF8ToUTF16 </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>inStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&amp;&#160;</td>
          <td class="paramname"><em>outStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>outEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General routine to convert from UTF-8 to UTF-16. </p>
<p>Stop when the input buffer is empty or the output buffer is full, whichever comes first. Invalid input values are silently ignored and skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inStart</td><td>Address of the input UTF-8 buffer to convert. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inEnd</td><td>Address after the end of the input UTF-8 buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outStart</td><td>Address of the output UTF-16 buffer to fill. Updated upon return to point after the last converted character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outEnd</td><td>Address after the end of the output UTF-16 buffer to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16c26a8d856cbead7185eb3a733b235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16c26a8d856cbead7185eb3a733b235">&#9670;&nbsp;</a></span>FromDVB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dvb</td><td>A string in DVB representation. The first bytes of the string indicate the DVB character set to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="a94a10ffa3104cf15fdca38a1e01b3be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a10ffa3104cf15fdca38a1e01b3be6">&#9670;&nbsp;</a></span>FromDVB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVB </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>dvbSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dvb</td><td>Address of a string in DVB representation. The first bytes of the string indicate the DVB character set to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dvbSize</td><td>Size in bytes of the DVB string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="a5d0944b55ecf6f9507cba1213e4eedea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0944b55ecf6f9507cba1213e4eedea">&#9670;&nbsp;</a></span>FromDVBWithByteLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a DVB string into UTF-16 (preceded by its one-byte length). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of a buffer containing a DVB string to read. The first byte in the buffer is the length in bytes of the string. Upon return, <em>buffer</em> is updated to point after the end of the string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size in bytes of the buffer, which may be larger than the DVB string. Upon return, <em>size</em> is updated, decremented by the same amount <em>buffer</em> was incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>If not zero, use this character set if no explicit table code is present, instead of the standard default ISO-6937. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent UTF-16 string. Stop on untranslatable character, if any. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>ETSI EN 300 468, Annex A. </dd></dl>

</div>
</div>
<a id="a5c92ff6f2e93e196e28f688f0cd8d23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c92ff6f2e93e196e28f688f0cd8d23c">&#9670;&nbsp;</a></span>toDVB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ts::UString::toDVB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string. </p>
<p>Stop either when this string is serialized or when the buffer is full, whichever comes first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer where the DVB string is written. The address is updated to point after the encoded value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size of the buffer. Updated to remaining size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of serialized characters (which is usually not the same as the number of written bytes). </dd></dl>

</div>
</div>
<a id="abb507ace0bbbf6687a60cf6b588d95f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb507ace0bbbf6687a60cf6b588d95f3">&#9670;&nbsp;</a></span>toDVB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> ts::UString::toDVB </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DVB string. </dd></dl>

</div>
</div>
<a id="ac0efc4cc015bce842bce7a92ec62a414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0efc4cc015bce842bce7a92ec62a414">&#9670;&nbsp;</a></span>toDVBWithByteLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ts::UString::toDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string (preceded by its one-byte length). </p>
<p>Stop either when this string is serialized or when the buffer is full or when 255 bytes are written, whichever comes first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer where the DVB string is written. The first byte will receive the size in bytes of the DVB string. The address is updated to point after the encoded value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Size of the buffer. Updated to remaining size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of serialized characters (which is usually not the same as the number of written bytes). </dd></dl>

</div>
</div>
<a id="a5823ba0c6efa73513a15815c32f56e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5823ba0c6efa73513a15815c32f56e03">&#9670;&nbsp;</a></span>toDVBWithByteLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> ts::UString::toDVBWithByteLength </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classts_1_1_u_string.html#aab6ad2cee0b7043e14e3c833c6e3d263">NPOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_d_v_b_charset.html">DVBCharset</a> *&#160;</td>
          <td class="paramname"><em>charset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode this UTF-16 string into a DVB string (preceded by its one-byte length). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Starting offset to convert in this UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Preferred character set for DVB encoding. If omitted or if the string cannot be represented in the specified character set, an alternative one will be automatically selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DVB string with the initial length byte. </dd></dl>

</div>
</div>
<a id="aaee8b02a88e409c18afb41b3a7c68b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee8b02a88e409c18afb41b3a7c68b67">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CHARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from a <code>std::vector</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>The vector of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to include in the string. Stop before the first nul character before <em>max</em>. Can be of any integer type, including a signed type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="aedc017319630b84e5e355771efe4b39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc017319630b84e5e355771efe4b39c">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CHARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from a <code>std::vector</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>The vector of characters. Nul-terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="aec8f8622c7db313e6e725463b3923996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8f8622c7db313e6e725463b3923996">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , std::size_t SIZE, typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assign </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; CHARTYPE, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from a <code>std::array</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">SIZE</td><td>The size of the array. </td></tr>
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of characters to include in the string. Stop before the first nul character before <em>max</em>. Can be of any integer type, including a signed type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a2d4c0789989342c0cca83f38c27cace9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4c0789989342c0cca83f38c27cace9">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHARTYPE , std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a>&amp; ts::UString::assign </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; CHARTYPE, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from a <code>std::array</code> of 16-bit characters of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHARTYPE</td><td>A 16-bit character or integer type. </td></tr>
    <tr><td class="paramname">SIZE</td><td>The size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>The array of characters. Nul-terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a34c9e8a315f34bbc971b029af58555a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c9e8a315f34bbc971b029af58555a3">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ts::UString::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the display width in characters. </p>
<p>Any combining diacritical character is not counted in the width since it is combined with the preceding character. Similarly, any surrogate pair is considered as one single character. As a general rule, <a class="el" href="classts_1_1_u_string.html#a34c9e8a315f34bbc971b029af58555a3" title="Get the display width in characters. ">width()</a> is always lower than or equal to length(), the number of characters in the string. </p><dl class="section return"><dt>Returns</dt><dd>The display width in characters. </dd></dl>

</div>
</div>
<a id="ab0f3c24b274ab1c047ba1ab030637707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f3c24b274ab1c047ba1ab030637707">&#9670;&nbsp;</a></span>displayPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ts::UString::displayPosition </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>from</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count displayed positions inside a string. </p>
<p>Any combining diacritical character is not counted in display position. Similarly, any surrogate pair is considered as one single character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of display positions to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Starting index in the string. This is an index, not a display position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Direction to move when counting display positions. When counting RIGHT_TO_LEFT, <em>from</em> is the position after the right-most character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index in the string after moving. When the display position is outside the string, return length() when moving LEFT_TO_RIGHT and return zero when moving RIGHT_TO_LEFT. The returned index is never in the middle of a combining diacritical sequence or of a surrogate pair, always at the start of this sequence. </dd></dl>

</div>
</div>
<a id="afc41789063ebea5813478c7b8530fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc41789063ebea5813478c7b8530fd02">&#9670;&nbsp;</a></span>truncateWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::truncateWidth </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate this string to a given display width. </p>
<p>Any combining diacritical character is not counted in display position. Similarly, any surrogate pair is considered as one single character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum display width, after which the string is truncated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Direction to move when counting width. When RIGHT_TO_LEFT, the width is counted from the end of the string and the beginning of the string is truncated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac737a46aec050edcaf18440712b40832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac737a46aec050edcaf18440712b40832">&#9670;&nbsp;</a></span>toTruncatedWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toTruncatedWidth </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423">StringDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespacets.html#a192e3a523b2e9cdb0a27852f1b3e8423aeb97c1482353aa7767b83ad2c356b401">LEFT_TO_RIGHT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of this string, truncated to a given display width. </p>
<p>Any combining diacritical character is not counted in display position. Similarly, any surrogate pair is considered as one single character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum display width, after which the string is truncated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Direction to move when counting width. When RIGHT_TO_LEFT, the width is counted from the end of the string and the beginning of the string is truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the string, truncated to the given display width. </dd></dl>

</div>
</div>
<a id="a55a15cf87a1e3453dafbe7ac1feca1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a15cf87a1e3453dafbe7ac1feca1ea">&#9670;&nbsp;</a></span>wc_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::WCHAR* ts::UString::wc_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address of the underlying null-terminated Unicode string (Windows-specific). </p>
<dl class="section return"><dt>Returns</dt><dd>The address of the underlying null-terminated Unicode string . </dd></dl>

</div>
</div>
<a id="a55f8469f96e5edc75beda2ddc80cfc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f8469f96e5edc75beda2ddc80cfc5d">&#9670;&nbsp;</a></span>wc_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::WCHAR* ts::UString::wc_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address of the underlying null-terminated Unicode string (Windows-specific). </p>
<dl class="section return"><dt>Returns</dt><dd>The address of the underlying null-terminated Unicode string . </dd></dl>

</div>
</div>
<a id="a8e5fc68d56c4f4e06929ae588819f055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5fc68d56c4f4e06929ae588819f055">&#9670;&nbsp;</a></span>last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>* ts::UString::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address after the last character in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The address after the last character in the string. </dd></dl>

</div>
</div>
<a id="a2d26d5a81d0754f1ac664f2688b1c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d26d5a81d0754f1ac664f2688b1c195">&#9670;&nbsp;</a></span>last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>* ts::UString::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address after the last character in the string (C++17). </p>
<dl class="section return"><dt>Returns</dt><dd>The address after the last character in the string. </dd></dl>

</div>
</div>
<a id="a75294cf252a668d4bf88ea026e6f3c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75294cf252a668d4bf88ea026e6f3c83">&#9670;&nbsp;</a></span>trimLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::trimLength </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimTrailingSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the size of the string to a given length from an alien integer type. </p>
<p>This method is useful when the string has been used as an input buffer. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>New size of the string. Ignored if negative or greater than the current string length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimTrailingSpaces</td><td>If true, also remove any trailing space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5cab66002ed3a2c4c16b8fb32e61c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cab66002ed3a2c4c16b8fb32e61c53">&#9670;&nbsp;</a></span>toReversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toReversed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string where characters are reversed. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the string where characters are reversed. </dd></dl>

</div>
</div>
<a id="a3e06a17d20d02a2eeeef09400b01669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e06a17d20d02a2eeeef09400b01669d">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::trim </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading and / or trailing space characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8695689c7b19d7fa010de40538457388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8695689c7b19d7fa010de40538457388">&#9670;&nbsp;</a></span>toTrimmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toTrimmed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trailing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string where leading and / or trailing spaces are trimmed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leading</td><td>If true (the default), remove all space characters at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trailing</td><td>If true (the default), remove all space characters at the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this object after trimming. </dd></dl>

</div>
</div>
<a id="a002290c2532a050424674a82fa504b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002290c2532a050424674a82fa504b51">&#9670;&nbsp;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a lower-case version of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Lower-case version of the string. </dd></dl>

</div>
</div>
<a id="a3d33505aab6deaf9782d72fa11011d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d33505aab6deaf9782d72fa11011d55">&#9670;&nbsp;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an upper-case version of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Upper-case version of the string. </dd></dl>

</div>
</div>
<a id="a0b852b7b506c47a395158d6e67b1237f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b852b7b506c47a395158d6e67b1237f">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>substr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f30b9620c73d5d9651c1944a8c0632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f30b9620c73d5d9651c1944a8c0632">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab419307fa43875cb5e81a0c3ad52625d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab419307fa43875cb5e81a0c3ad52625d">&#9670;&nbsp;</a></span>toRemoved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemoved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>substr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>Substring to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This string with all occurences fo <em>substr</em> removed. </dd></dl>

</div>
</div>
<a id="abd257233cc44c47a6e2d0edb6a892dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd257233cc44c47a6e2d0edb6a892dbd">&#9670;&nbsp;</a></span>toRemoved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurences of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This string with all occurences fo <em>substr</em> removed. </dd></dl>

</div>
</div>
<a id="a8d5bbc6b19f8bf00a70e2ec0d7e9afa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bbc6b19f8bf00a70e2ec0d7e9afa8">&#9670;&nbsp;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all occurences of a string with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cda0b113d6c880d572a153a732cf3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cda0b113d6c880d572a153a732cf3b6">&#9670;&nbsp;</a></span>toSubstituted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toSubstituted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string where all occurences of a string are substituted with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Replacement string for <em>value</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy to this string where all occurences of <em>value</em> have been replaced by <em>replace</em>. </dd></dl>

</div>
</div>
<a id="a9f0d4e4c2225f3f68a5817240e5ebc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0d4e4c2225f3f68a5817240e5ebc3b">&#9670;&nbsp;</a></span>removePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::removePrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove, if present at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba59b1e7cbe22ffa6eee81dfafacda32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba59b1e7cbe22ffa6eee81dfafacda32">&#9670;&nbsp;</a></span>removeSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::removeSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove, if present at the end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e59bbf5a8df9fed0688e6ed0429463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e59bbf5a8df9fed0688e6ed0429463">&#9670;&nbsp;</a></span>toRemovedPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemovedPrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a prefix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A prefix to remove, if present at the beginning of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with prefix removed. </dd></dl>

</div>
</div>
<a id="a13b73b9d3c2aabc966f75067a2f7e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b73b9d3c2aabc966f75067a2f7e677">&#9670;&nbsp;</a></span>toRemovedSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toRemovedSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a suffix in string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A suffix to remove, if present at the end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with suffix removed. </dd></dl>

</div>
</div>
<a id="a98d515c33c156e797977794f6f99b91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d515c33c156e797977794f6f99b91d">&#9670;&nbsp;</a></span>startWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::startWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the string starts with a specified prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>A string prefix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string starts with <em>prefix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="ad68009763ba4fd4c4cc238e0d63c183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68009763ba4fd4c4cc238e0d63c183a">&#9670;&nbsp;</a></span>endWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::endWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47">CaseSensitivity</a>&#160;</td>
          <td class="paramname"><em>cs</em> = <code><a class="el" href="namespacets.html#acabdd963f028076d6599f6712b236b47a7a39a55c5b22c9b352ea346bcebb06fd">CASE_SENSITIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string ends with a specified suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>A string suffix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>Indicate if the comparison is case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string ends with <em>suffix</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="ae901036faf692860190b1736c6b6087d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae901036faf692860190b1736c6b6087d">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::split </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="namespacets.html#acddcf9feea154a5c67a07120d0012b0e">COMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeEmpty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the string into segments based on a separator character (comma by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>The character which is used to separate the segments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeEmpty</td><td>If true, empty segments are ignored i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c75eda5c711a905f131a89713da584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c75eda5c711a905f131a89713da584">&#9670;&nbsp;</a></span>splitBlocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::splitBlocks </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>startWith</em> = <code><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>('[')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>endWith</em> = <code><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>(']')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trimSpaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into segments which are identified by their starting / ending characters (respectively "[" and "]" by default). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the segments of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startWith</td><td>The character which is used to identify the start of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endWith</td><td>The character which is used to identify the end of a segment of <em>input</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trimSpaces</td><td>If true (the default), each segment is trimmed, i.e. all leading and trailing space characters are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af47dad58edc1a404deb1bd1ebc1c165c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47dad58edc1a404deb1bd1ebc1c165c">&#9670;&nbsp;</a></span>splitLines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::splitLines </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>nextMargin</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSplit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into multiple lines which are not longer than a specified maximum width. </p>
<p>The splits occur on spaces or after any character in <em>otherSeparators</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> which receives the lines of the splitted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of each resulting line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSeparators</td><td>A string containing all characters which are acceptable as line break points (in addition to space characters which are always potential line break points). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMargin</td><td>A string which is prepended to all lines after the first one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSplit</td><td>If true, longer lines without separators are split at the maximum width (by default, longer lines without separators are not split, resulting in lines longer than <em>maxWidth</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1678f1645abba2cba8d3bae907116000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1678f1645abba2cba8d3bae907116000">&#9670;&nbsp;</a></span>toSplitLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toSplitLines </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>nextMargin</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSplit</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a>&#160;</td>
          <td class="paramname"><em>lineSeparator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(1,&#160;<a class="el" href="namespacets.html#a1f22b94dcc18ebb1ca080df4a0962533">LINE_FEED</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into multiple lines which are not longer than a specified maximum width. </p>
<p>The splits occur on spaces or after any character in <em>otherSeparators</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of each resulting line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSeparators</td><td>A string containing all characters which are acceptable as line break points (in addition to space characters which are always potential line break points). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMargin</td><td>A string which is prepended to all lines after the first one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSplit</td><td>If true, longer lines without separators are split at the maximum width (by default, longer lines without separators are not split, resulting in lines longer than <em>maxWidth</em>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lineSeparator</td><td>The sequence of characters for line feed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The splitted string with embedded line separators. </dd></dl>

</div>
</div>
<a id="a2bc537ce77d01338e58ca62e4a13333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc537ce77d01338e58ca62e4a13333e">&#9670;&nbsp;</a></span>Join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Join </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a part of a container of strings into one big string. </p>
<p>The strings are accessed through iterators in the container. All strings are concatenated into one big string. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="a6ad588ea96fd23a229717b2654f9ea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad588ea96fd23a229717b2654f9ea4b">&#9670;&nbsp;</a></span>Join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Join </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a container of strings into one big string. </p>
<p>All strings from the container are concatenated into one big string. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <code><a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a></code> containing all strings to concatenate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>A string to insert between all segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The big string containing all segments and separators. </dd></dl>

</div>
</div>
<a id="af6d454a8d9c6cd32f7528c3978e1b960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d454a8d9c6cd32f7528c3978e1b960">&#9670;&nbsp;</a></span>justifyLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyLeft </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesBeforePad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justify (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to append to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, it is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesBeforePad</td><td>Number of spaces before padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2698f08d50ea3ec94147d481e6b77620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2698f08d50ea3ec94147d481e6b77620">&#9670;&nbsp;</a></span>toJustifiedLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedLeft </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesBeforePad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a left-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to append to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, it is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesBeforePad</td><td>Number of spaces before padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="aae571d4cd09eb160eaac0ac02ac3be18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae571d4cd09eb160eaac0ac02ac3be18">&#9670;&nbsp;</a></span>justifyRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyRight </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAfterPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justified (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to prepend to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, the beginning of <em>str</em> is truncated. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAfterPad</td><td>Number of spaces after padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff55a599211ee4685ea23881e60ab73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff55a599211ee4685ea23881e60ab73f">&#9670;&nbsp;</a></span>toJustifiedRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedRight </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAfterPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a right-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to prepend to the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, the beginning of <em>str</em> is truncated. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAfterPad</td><td>Number of spaces after padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a36004a34eb9916a0fb9c7226e8a7ff3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36004a34eb9916a0fb9c7226e8a7ff3e">&#9670;&nbsp;</a></span>justifyCentered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justifyCentered </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAroundPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centered-justified (pad and optionally truncate) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended and appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The pad character for the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, this string is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAroundPad</td><td>Number of spaces around padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa915f082a6760fdadd5c0925205e19bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa915f082a6760fdadd5c0925205e19bb">&#9670;&nbsp;</a></span>toJustifiedCentered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustifiedCentered </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAroundPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a centered-justified (padded and optionally truncated) string. </p>
<p>If this string is shorter than the specified width, <em>pad</em> characters are prepended and appended to the string up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The pad character for the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>If true and this string is longer than <em>width</em>, this string is truncated to <em>width</em> character. If false, this string is never truncated, possibly resulting in a string longer than <em>width</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAroundPad</td><td>Number of spaces around padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a4da20ba1436ffe0405a024124a69f1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da20ba1436ffe0405a024124a69f1a3">&#9670;&nbsp;</a></span>justify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::justify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAroundPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Justify string, pad in the middle. </p>
<p>If the this string and <em>right</em> components are collectively shorter than the specified width, <em>pad</em> characters are inserted between <em>left</em> and <em>right</em>, up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right part of the string to justify. This string is used as left part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to insert between the two parts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAroundPad</td><td>Number of spaces around padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a836195d6f9ae3df3b7a08a69dbf2847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836195d6f9ae3df3b7a08a69dbf2847c">&#9670;&nbsp;</a></span>toJustified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toJustified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spacesAroundPad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a justified string, pad in the middle. </p>
<p>If the this string and <em>right</em> components are collectively shorter than the specified width, <em>pad</em> characters are inserted between <em>left</em> and <em>right</em>, up to the specified width. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right part of the string to justify. This string is used as left part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The required width of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The character to insert between the two parts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacesAroundPad</td><td>Number of spaces around padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The justified string. </dd></dl>

</div>
</div>
<a id="a0b31c7acdc2b6e73e07d39dd9d1f3309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b31c7acdc2b6e73e07d39dd9d1f3309">&#9670;&nbsp;</a></span>convertToHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::convertToHTML </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>convert</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string into a suitable HTML representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convert</td><td>A string containing all characters to convert into their corresponding HTML entities. If empty, all characters are converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37cd8101f42d1ac30096d52e010c16d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cd8101f42d1ac30096d52e010c16d3">&#9670;&nbsp;</a></span>toHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::toHTML </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>convert</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string in a suitable HTML representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convert</td><td>A string containing all characters to convert into their corresponding HTML entities. If empty, all characters are converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string with HTML entities replacing special characters. </dd></dl>

</div>
</div>
<a id="a463edf09edb30f813f25078a06faaba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463edf09edb30f813f25078a06faaba9">&#9670;&nbsp;</a></span>FromHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::FromHTML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string with all HTML entities converted into plain characters. </p>
<dl class="section return"><dt>Returns</dt><dd>The string with HTML entities translated. </dd></dl>

</div>
</div>
<a id="abcccd14ec7f4e0404c781a8eaf9becd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcccd14ec7f4e0404c781a8eaf9becd2">&#9670;&nbsp;</a></span>YesNo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::YesNo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "yes" or "no". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"yes" is <em>b</em> is true, "no" otherwise. </dd></dl>

</div>
</div>
<a id="af22c1f90aff1a79985d15b5edd864355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c1f90aff1a79985d15b5edd864355">&#9670;&nbsp;</a></span>TrueFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::TrueFalse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "true" or "false". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" is <em>b</em> is true, "false" otherwise. </dd></dl>

</div>
</div>
<a id="a3b7049b2f840423a0106dc8e1935f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7049b2f840423a0106dc8e1935f5d6">&#9670;&nbsp;</a></span>OnOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::OnOff </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a boolean value as "on" or "off". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"on" is <em>b</em> is true, "off" otherwise. </dd></dl>

</div>
</div>
<a id="a8603bb308c210616a211a5df4eb1cc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8603bb308c210616a211a5df4eb1cc54">&#9670;&nbsp;</a></span>AfterBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::AfterBytes </td>
          <td>(</td>
          <td class="paramtype">const std::streampos &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build an error message fragment indicating the number of bytes previously read in a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>A stream position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string like " after XX bytes" if <em>position</em> is greater than zero, an empty string otherwise. </dd></dl>

</div>
</div>
<a id="ac4a57baf99dd4b3ab0eac7b86aa66deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a57baf99dd4b3ab0eac7b86aa66deb">&#9670;&nbsp;</a></span>HumanSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::HumanSize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>units</em> = <code>u&quot;B&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSign</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a human-readable size using MB, kB or B as appropriate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A size value in basic units. This is a signed value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">units</td><td>A string for the units. The default is "B" (for bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceSign</td><td>If true, use a '+' sign for positive value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable representation of the size value. </dd></dl>

</div>
</div>
<a id="a0db698cf1abf39e1ef090661809fd61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db698cf1abf39e1ef090661809fd61a">&#9670;&nbsp;</a></span>Percentage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Percentage </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a percentage string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An integer value, a portion of <em>total</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total</td><td>The total value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string reprenting the percentage of <em>value</em> in <em>total</em>. </dd></dl>

</div>
</div>
<a id="aca4693cea00a3e14d15e15bc91631a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4693cea00a3e14d15e15bc91631a97">&#9670;&nbsp;</a></span>similar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::similar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string and <em>other</em> are "similar", ie. identical, case-insensitive and ignoring blanks. </dd></dl>

</div>
</div>
<a id="a6cf010e716088d287fbf11a182716a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf010e716088d287fbf11a182716a5d">&#9670;&nbsp;</a></span>similar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::similar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two strings are identical, case-insensitive and ignoring blanks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of second string in UTF-8 representation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of second string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings are "similar", ie. identical, case-insensitive and ignoring blanks </dd></dl>

</div>
</div>
<a id="a7c84148d5f72c940a9f9c6fe51c5e956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c84148d5f72c940a9f9c6fe51c5e956">&#9670;&nbsp;</a></span>containSimilar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::containSimilar </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a container of strings contains something similar to this string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>container</em> contains a string similar to this string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a> </dd></dl>

</div>
</div>
<a id="aca55557dc10c702ed78a1e36172f3117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca55557dc10c702ed78a1e36172f3117">&#9670;&nbsp;</a></span>findSimilar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER::const_iterator ts::UString::findSimilar </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate into a map an element with a similar string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A map container class using <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A map container with <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first element of <em>container</em> with a key value which is similar to this string according to <a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a>. Return <em>container.end()</em> if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#aca4693cea00a3e14d15e15bc91631a97" title="Check if two strings are identical, case-insensitive and ignoring blanks. ">similar()</a> </dd></dl>

</div>
</div>
<a id="a46f7c50f262b91894244c9678153ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f7c50f262b91894244c9678153ee53">&#9670;&nbsp;</a></span>Save() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a file, in UTF-8 format, one per line. </p>
<p>The strings must be located in a container and are accessed through iterators. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="aece15e68005ce38cb656afe125df8f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece15e68005ce38cb656afe125df8f54">&#9670;&nbsp;</a></span>Save() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a file, in UTF-8 format, one per line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> containing all strings to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file where to save the strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">append</td><td>If true, append the strings at the end of the file. If false (the default), overwrite the file if it already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="af7f019a070c0a77d35be1eeba6b4af4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f019a070c0a77d35be1eeba6b4af4f">&#9670;&nbsp;</a></span>Save() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a stream, in UTF-8 format, one per line. </p>
<p>The strings must be located in a container and are accessed through iterators. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITERATOR</td><td>An iterator class over <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing <em>after</em> the last string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strm</td><td>Output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a12b19e0136941b78723c0aa8e89f1b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b19e0136941b78723c0aa8e89f1b26">&#9670;&nbsp;</a></span>Save() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Save </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save strings from a container into a file, in UTF-8 format, one per line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> containing all strings to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strm</td><td>Output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="afe629667846a5cf415f5c58bba702bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe629667846a5cf415f5c58bba702bab">&#9670;&nbsp;</a></span>Load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Load </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="ad13fec902f25f9317538fd8da1505025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13fec902f25f9317538fd8da1505025">&#9670;&nbsp;</a></span>LoadAppend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::LoadAppend </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>The name of the text file from where to load the strings. Each line of the text file is inserted as a separate string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a954c077cb499376b944878a196d40c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954c077cb499376b944878a196d40c02">&#9670;&nbsp;</a></span>Load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::Load </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s into a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>A standard text stream in input mode. Each line of the text file is inserted as a separate string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="ad739ac8da0afe4ef26ace80e88a1c0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad739ac8da0afe4ef26ace80e88a1c0af">&#9670;&nbsp;</a></span>LoadAppend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ts::UString::LoadAppend </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all lines of a text file in UTF-8 format as <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>'s and append them in a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> receiving all lines of the file. Each line of the text file is a separate string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>A standard text stream in input mode. Each line of the text file is inserted as a separate string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="aac95d367fa19ad64b1e977341bd9f39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac95d367fa19ad64b1e977341bd9f39b">&#9670;&nbsp;</a></span>getLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::getLine </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one UTF-8 line from a text file and load it into this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strm</td><td>A standard stream in input mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (mostly file errors). </dd></dl>

</div>
</div>
<a id="a449be4b2b6dd646f88ba339d68a328c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449be4b2b6dd646f88ba339d68a328c2">&#9670;&nbsp;</a></span>toInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::toInteger </td>
          <td>(</td>
          <td class="paramtype">INT &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into an integer. </p>
<p>This string must contain the representation of an integer value in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type, any size, signed or unsigned. The toInteger function decodes integer values of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The returned decoded value. On error (invalid string), <em>value</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a0f4ab823727a0686132adce31ec684d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4ab823727a0686132adce31ec684d2">&#9670;&nbsp;</a></span>toIntegers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER , typename std::enable_if&lt; std::is_integral&lt; typename CONTAINER::value_type &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::toIntegers </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>thousandSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>listSeparators</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>(u&quot;,;&#160;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string containing a list of integers into a container of integers. </p>
<p>This string must contain the representation of integer values in decimal or hexadecimal (prefix <code>0x</code>). Hexadecimal values are case-insensitive, including the <code>0x</code> prefix. Leading and trailing spaces are ignored. Optional thousands separators are ignored. The various integer values in the string are separated using list delimiters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of any integer type as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>The returned decoded values. The previous content of the container is discarded. The integer values are added in the container in the order of the decoded string. On error (invalid string), <em>container</em> contains what could be decoded up to the first invalid character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thousandSeparators</td><td>A string of characters which are interpreted as thousands separators and are ignored. <em>Any character</em> from the <em>thousandSeparators</em> string is interpreted as a separator. Note that this implies that the optional thousands separators may have one character only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listSeparators</td><td>A string of characters which are interpreted as list separators. Distinct integer values must be separated by one or more of these separators. <em>Any character</em> from the <em>listSeparators</em> string is interpreted as a separator. Note that this implies that the list separators may have one character only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid string). </dd></dl>

</div>
</div>
<a id="a3b50a1c0e877f78224e765fbba6548f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b50a1c0e877f78224e765fbba6548f9">&#9670;&nbsp;</a></span>Decimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Decimal </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_justified</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html#a9bd59e53d29608b017496aa06cf4092f">DEFAULT_THOUSANDS_SEPARATOR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_sign</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a>&#160;</td>
          <td class="paramname"><em>pad</em> = <code><a class="el" href="namespacets.html#aa0b82d207cbd796a6e1b23a1b7622d21">SPACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a string containing a decimal value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer value to format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_width</td><td>Minimum width of the returned string. Padded with spaces if larger than the number of characters in the formatted number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_justified</td><td>If true (the default), return a right-justified string. When false, return a left-justified string. Ignored if <em>min_width</em> is lower than the number of characters in the formatted number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Separator string for groups of thousands, a comma by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force_sign</td><td>If true, force a '+' sign for positive values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>The padding character to adjust the width. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. </dd></dl>

</div>
</div>
<a id="a59e86799482cd921d27d074fd1a44e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e86799482cd921d27d074fd1a44e42">&#9670;&nbsp;</a></span>Hexa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT , typename std::enable_if&lt; std::is_integral&lt; INT &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Hexa </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classts_1_1_u_string.html">UString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_prefix</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_upper</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a string containing an hexadecimal value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INT</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer value to format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the formatted number, not including the optional prefix and separator. By default, use the "natural" size of <em>INT</em> (e.g. 8 for 32-bit integer). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Separator string for groups of 4 digits, empty by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_prefix</td><td>If true, prepend the standard hexa prefix "0x". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_upper</td><td>If true, use upper-case hexadecimal digits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. </dd></dl>

</div>
</div>
<a id="ac700959acea9ad3915f6d19cae5b8612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac700959acea9ad3915f6d19cae5b8612">&#9670;&nbsp;</a></span>Format() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_in.html">ArgMixIn</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a string using a template and arguments. </p>
<p>This method is similar in principle to <code>printf()</code>. The <em>fmt</em> paramter is used as a <em>format</em> or <em>template</em> where sequences starting with '%' are place-holders for arguments. The main different with <code>printf()</code> is that the argument list is typed, thanks to C++ features. Thus, the risk of mismatch or crash is eliminated. When a '%' sequence is formatted, the presence and type of the corresponding argument is known. For this reason, the syntax of the '%' sequences is simplified.</p>
<p>The available '%' sequences are:</p><ul>
<li><code>%s</code> : String. Treated as <code>%d</code> if the argument is an integer.</li>
<li><code>%c</code> : Character. Use integer argument as Unicode code point. Treated as <code>%s</code> if the argument is a string.</li>
<li><code>%d</code> : Integer in decimal. Treated as <code>%s</code> if the argument is a string.</li>
<li><code>%x</code> : Integer in lowercase hexadecimal. Treated as <code>%s</code> if the argument is a string.</li>
<li><code>%X</code> : Integer in uppercase hexadecimal. Treated as <code>%s</code> if the argument is a string.</li>
<li><code>%%</code> : Insert a literal %.</li>
</ul>
<p>The allowed options, between the '%' and the letter are, in this order:</p><ul>
<li><code>-</code> : Left-justified (right-justified by default).</li>
<li><code>+</code> : Force a '+' sign with positive decimal integers (<code>%d</code> only).</li>
<li><code>0</code> : Zero padding for integers. This is the default with <code>%x</code> and <code>%X</code>.</li>
<li><em>digits</em> : Minimum field width. This is a display width, not a number of characters. With <code>%x</code> or <code>%X</code>, the default width is the "natural" width of the parameter (e.g. 4 digits for a <code>uint16_t</code> value).</li>
<li><code></code>. <em>digits</em> : Starting with a dot. Maximum field width for strings. Ignored for integers.</li>
<li><code>'</code> : For integer conversions, use a separator for groups of thousands.</li>
<li><code>*</code> : Can be used instead of <em>digits</em>. The integer value is taken from the argument list.</li>
</ul>
<p>Since the argument list is typed, it is possible to mix integers and strings of various types and sizes. Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = -1234;</div><div class="line">uint16_t u16 = 128;</div><div class="line"><a class="code" href="classts_1_1_u_string.html">ts::UString</a> us(u<span class="stringliteral">&quot;abc&quot;</span>);</div><div class="line">std::string s(<span class="stringliteral">&quot;def&quot;</span>);</div><div class="line">std::cout &lt;&lt; <a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;i = %&#39;d, u16 = 0x%X, %d %s %s %s %s&quot;</span>, {i, u16, 27, us, s, u<span class="stringliteral">&quot;ghi&quot;</span>, <span class="stringliteral">&quot;jkl&quot;</span>});</div></div><!-- fragment --><p> displays: </p><div class="fragment"><div class="line">i = -1,234, u16 = 0x0080, 27 abc def ghi jkl</div></div><!-- fragment --><p>Incorrect format specifiers are silently ignored. Extraneous or missing parameters are also silently ignored. Incorrect types are fixed when possible. To report all these discrepancies, define the environment variable <code>TSDUCK_FORMAT_DEBUG</code> and error messages will be reported on standard error.</p>
<p>Sample incorrect formats or combination of arguments: </p><div class="fragment"><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;a) %d %d&quot;</span>, {1, 2, 3, 4});  <span class="comment">// return &quot;a) 1 2&quot;</span></div><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;b) %d %d&quot;</span>, {1});           <span class="comment">// return &quot;b) 1 &quot;</span></div><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;c) %d %d&quot;</span>, {1, u<span class="stringliteral">&quot;abc&quot;</span>});   <span class="comment">// return &quot;c) 1 abc&quot;</span></div><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;d) %d %s&quot;</span>, {1, 2});        <span class="comment">// return &quot;d) 1 2&quot;</span></div><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;e) ab%scd%sef&quot;</span>, {u<span class="stringliteral">&quot;X&quot;</span>});   <span class="comment">// return &quot;e) abXcdef&quot;</span></div><div class="line"><a class="code" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">ts::UString::Format</a>(u<span class="stringliteral">&quot;f) %d %01&quot;</span>, {1, 2, 3});    <span class="comment">// return &quot;f) 1 &quot;</span></div></div><!-- fragment --><p>To report errors which are otherwise silently fixed: </p><div class="fragment"><div class="line">$ utests</div><div class="line">$</div><div class="line">$ export TSDUCK_FORMAT_DEBUG=<span class="keyword">true</span></div><div class="line">$ utests</div><div class="line">[FORMATDBG] extraneous 2 arguments at position 8 in format string: <span class="stringliteral">&quot;a) %d %d&quot;</span></div><div class="line">[FORMATDBG] missing argument <span class="keywordflow">for</span> sequence %d at position 8 in format string: <span class="stringliteral">&quot;b) %d %d&quot;</span></div><div class="line">[FORMATDBG] type mismatch, got a <span class="keywordtype">string</span> <span class="keywordflow">for</span> sequence %d at position 8 in format string: <span class="stringliteral">&quot;c) %d %d&quot;</span></div><div class="line">[FORMATDBG] type mismatch, got an integer <span class="keywordflow">for</span> sequence %s at position 8 in format string: <span class="stringliteral">&quot;d) %d %s&quot;</span></div><div class="line">[FORMATDBG] missing argument <span class="keywordflow">for</span> sequence %s at position 11 in format string: <span class="stringliteral">&quot;e) ab%scd%sef&quot;</span></div><div class="line">[FORMATDBG] invalid <span class="charliteral">&#39;%&#39;</span> sequence at position 9 in format string: <span class="stringliteral">&quot;f) %d %01&quot;</span></div><div class="line">[FORMATDBG] extraneous 2 arguments at position 9 in format string: <span class="stringliteral">&quot;f) %d %01&quot;</span></div><div class="line">$</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of arguments to substitute in the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. </dd></dl>

</div>
</div>
<a id="a618790677ea9b093c381cb58526527f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618790677ea9b093c381cb58526527f2">&#9670;&nbsp;</a></span>Format() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_in.html">ArgMixIn</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format a string using a template and arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of arguments to substitute in the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612" title="Format a string using a template and arguments. ">Format()</a> </dd></dl>

</div>
</div>
<a id="ae9ad4436655c7622b184598f5dd7593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ad4436655c7622b184598f5dd7593d">&#9670;&nbsp;</a></span>scan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::scan </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>extractedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan this string for integer or character values using a template and arguments. </p>
<p>This method is similar in principle to <code>scanf()</code>. The <em>fmt</em> paramter is used as a <em>format</em> or <em>template</em> where sequences starting with '%' are place-holders for arguments. The main different with <code>scanf()</code> is that the argument list is typed, thanks to C++ features. Thus, the risk of mismatch or crash is eliminated. When a '%' sequence is matched, the presence and type of the corresponding argument is known. For this reason, the syntax of the '%' sequences is simplified.</p>
<p>All spaces in the input string are ignored. A sequence of space characters only forces a separation between two fields. Other characters in <em>fmt</em>, outside '' sequences, must match the corresponding character in the input string. Scanning the input string stops when a match fails.</p>
<p>The available '%' sequences are:</p><ul>
<li><code>%d</code> : Matches an integer in decimal or hexadecimal. If the field starts with 0x or 0X, the value is interpreted as hexadecimal. Decimal otherwise.</li>
<li><code>%i</code> : Same as %d.</li>
<li><code>%x</code> : Matches an integer in hexadecimal, case-insensitive, without 0x or 0X prefix.</li>
<li><code>%X</code> : Same as %x.</li>
<li><code>%c</code> : Matches the next non-space character. The Unicode code point is returned.</li>
<li><code>%%</code> : Matches a literal %.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">extractedCount</td><td>The number of successfully extracted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endIndex</td><td>The index in this string after the last extracted value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of output arguments to receive extracted values. The <em>args</em> list is built from pointers to integer data of any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire string is consumed and the entire format is parsed. False otherwise. In other words, the method returns true when this object string exactly matches the format in <em>fmt</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612" title="Format a string using a template and arguments. ">Format(const UChar* fmt, std::initializer_list&lt;ArgMixIn&gt; args)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">extractedCount</td><td>The number of successfully extracted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endIndex</td><td>The index in this string after the last extracted value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of output arguments to receive extracted values. The <em>args</em> list is built from pointers to integer data of any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire string is consumed and the entire format is parsed. False otherwise. In other words, the method returns true when this object string exactly matches the format in <em>fmt</em>. </dd></dl>

</div>
</div>
<a id="afe9de7b15c4eb481e5a70c2572da364a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9de7b15c4eb481e5a70c2572da364a">&#9670;&nbsp;</a></span>scan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::scan </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>extractedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan this string for integer or character values using a template and arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">extractedCount</td><td>The number of successfully extracted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endIndex</td><td>The index in this string after the last extracted value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of output arguments to receive extracted values. The <em>args</em> list is built from pointers to integer data of any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire string is consumed and the entire format is parsed. False otherwise. In other words, the method returns true when this object string exactly matches the format in <em>fmt</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#ae9ad4436655c7622b184598f5dd7593d" title="Scan this string for integer or character values using a template and arguments. ">scan()</a> </dd></dl>

</div>
</div>
<a id="a2a1bd56f7f7481745ba4c1c4893ed1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1bd56f7f7481745ba4c1c4893ed1e8">&#9670;&nbsp;</a></span>scan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0">UChar</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan this string for integer or character values using a template and arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of output arguments to receive extracted values. The <em>args</em> list is built from pointers to integer data of any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire string is consumed and the entire format is parsed. False otherwise. In other words, the method returns true when this object string exactly matches the format in <em>fmt</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>scan(size_t&amp;, size_type&amp;, const UChar*, std::initializer_list&lt;ArgMixOut&gt;) </dd></dl>

</div>
</div>
<a id="ac8e4169ede0882538404ddf66ca1e32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e4169ede0882538404ddf66ca1e32e">&#9670;&nbsp;</a></span>scan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classts_1_1_arg_mix_out.html">ArgMixOut</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan this string for integer or character values using a template and arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string with embedded '%' sequences. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>List of output arguments to receive extracted values. The <em>args</em> list is built from pointers to integer data of any size, signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire string is consumed and the entire format is parsed. False otherwise. In other words, the method returns true when this object string exactly matches the format in <em>fmt</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>scan(size_t&amp;, size_type&amp;, const UChar*, std::initializer_list&lt;ArgMixOut&gt;) </dd></dl>

</div>
</div>
<a id="ac55f25f55f2cdc5ac4c203348f62c5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55f25f55f2cdc5ac4c203348f62c5c6">&#9670;&nbsp;</a></span>Dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Dump </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Starting address of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type HexaFlags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag BPL is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag OFFSET is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the formatted hexadecimal dump. Lines are separated with embedded new-line characters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46" title="Flags for the Hexa() family of methods. ">HexaFlags</a> </dd></dl>

</div>
</div>
<a id="aed5d06223a12ccb05bacf97e160c5d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5d06223a12ccb05bacf97e160c5d77">&#9670;&nbsp;</a></span>Dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classts_1_1_u_string.html">UString</a> ts::UString::Dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bb</td><td>Byte block to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type HexaFlags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag BPL is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag OFFSET is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the formatted hexadecimal dump. Lines are separated with embedded new-line characters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46" title="Flags for the Hexa() family of methods. ">HexaFlags</a> </dd></dl>

</div>
</div>
<a id="af0fa13dc84b89c0c90a0b1f7e7e87030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fa13dc84b89c0c90a0b1f7e7e87030">&#9670;&nbsp;</a></span>appendDump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::appendDump </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Starting address of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the memory area to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type HexaFlags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag BPL is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag OFFSET is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46" title="Flags for the Hexa() family of methods. ">HexaFlags</a> </dd></dl>

</div>
</div>
<a id="a9c7b1b093a337106fbf885e2dafa8c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7b1b093a337106fbf885e2dafa8c2d">&#9670;&nbsp;</a></span>appendDump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ts::UString::appendDump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46aa7bd3c423691aa596e8b2caa703e5e2e">HEXA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>line_width</em> = <code><a class="el" href="classts_1_1_u_string.html#abb53f302e6507cbd34844f1b0a49f663">DEFAULT_HEXA_LINE_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>init_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>inner_indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a multi-line string containing the hexadecimal dump of a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bb</td><td>Byte block to dump. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of option flags indicating how to format the data. This is typically the result of or'ed values from the enum type HexaFlags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>Each line is indented by this number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_width</td><td>Maximum number of characters per line. If the flag BPL is specified, <em>line_width</em> is interpreted as the number of displayed byte values per line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_offset</td><td>If the flag OFFSET is specified, an offset in the memory area is displayed at the beginning of each line. In this case, <em>init_offset</em> specified the offset value for the first byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_indent</td><td>Add this indentation before hexa/ascii dump, after offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classts_1_1_u_string.html#a95e758037651fab003f10b568b08cb46" title="Flags for the Hexa() family of methods. ">HexaFlags</a> </dd></dl>

</div>
</div>
<a id="ac324e7e61aa81936d8adbce4028c577e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac324e7e61aa81936d8adbce4028c577e">&#9670;&nbsp;</a></span>hexaDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::hexaDecode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret this string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Decoded bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="a1b306525a16c1cc533e0c6c9f4e7e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b306525a16c1cc533e0c6c9f4e7e75c">&#9670;&nbsp;</a></span>hexaDecodeAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ts::UString::hexaDecodeAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classts_1_1_byte_block.html">ByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret this string as a sequence of hexadecimal digits (ignore blanks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The decoded bytes are added at the end of the previous content. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (invalid hexa format). When returning false, the result contains everything that could be decoded before getting the error. </dd></dl>

</div>
</div>
<a id="a7b158f71eccccebe0f571898fdb0956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b158f71eccccebe0f571898fdb0956f">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CONTAINER&amp; ts::UString::Append </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an array of C-strings to a container of strings. </p>
<p>All C-strings from an array are appended at the end of a container. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="adbb773145eef27188125e102d1f491c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb773145eef27188125e102d1f491c5">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CONTAINER&amp; ts::UString::Append </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an array of C-strings to a container of strings. </p>
<p>All C-strings from an array are appended at the end of a container. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a47539b2921afa55f75b49bee47770dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47539b2921afa55f75b49bee47770dc5">&#9670;&nbsp;</a></span>Assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CONTAINER&amp; ts::UString::Assign </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an array of C-strings to a container of strings. </p>
<p>The container is assigned using all C-strings from an array. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<a id="a2e3bb6eaa7ad0eb248c94d5ea40e5aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3bb6eaa7ad0eb248c94d5ea40e5aef">&#9670;&nbsp;</a></span>Assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CONTAINER&amp; ts::UString::Assign </td>
          <td>(</td>
          <td class="paramtype">CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an array of C-strings to a container of strings. </p>
<p>The container is assigned using all C-strings from an array. The <em>argc</em> / <em>argv</em> pair is typically received by a main program from a command line. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONTAINER</td><td>A container class of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a> as defined by the C++ Standard Template Library (STL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>A container of <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">UString</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of C-strings in <em>argv</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of C-strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <em>container</em>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aab6ad2cee0b7043e14e3c833c6e3d263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ad2cee0b7043e14e3c833c6e3d263">&#9670;&nbsp;</a></span>NPOS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_type ts::UString::NPOS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"></div><div class="line">            size_type(-1)</div></div><!-- fragment -->
<p>An alternative value for the standard <code>npos</code> value. </p>
<p>Required on Windows to avoid linking issue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ts_u_string_8h.html">tsUString.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
