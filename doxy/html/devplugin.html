<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: Developing TSP Plugins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.3</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('devplugin.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Developing TSP Plugins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#pdevworkflow">Plugin development workflow</a></li>
<li class="level1"><a href="#pdevguidelines">Development guidelines</a><ul><li class="level2"><a href="#pdevtsp">Invoking tsp from a plugin, the ts::TSP callbacks</a></li>
<li class="level2"><a href="#pdevjtem">Joint termination support</a></li>
</ul>
</li>
<li class="level1"><a href="#pdevdesign">TSP design</a><ul><li class="level2"><a href="#pdevexec">Plugin Executors</a></li>
<li class="level2"><a href="#pdevbuffer">Transport packets buffer</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="pdevworkflow"></a>
Plugin development workflow</h1>
<p>When some new kind of transport stream processing is needed, several solutions are possible:</p>
<ul>
<li>First, check if an existing plugin or a combination of existing plugins can do the job.</li>
<li>Check if an existing plugin can be extended (by adding new options for instance).</li>
<li>As a last resort, develop a new plugin, which is relatively easy.</li>
</ul>
<p>To develop a new plugin named <code>foo</code>, follow these steps:</p>
<ul>
<li>Create a source file named <code>tsplugin_foo.cpp</code> in the <code>tsplugins</code> subdirectory.</li>
<li>On Linux or MacOS systems, this new source file will be automatically recognized by the Makefile and the new plugin will be built.</li>
<li>On Windows systems, create a project file named <code>tsplugin_foo.vcxproj</code> in the <code>msvc2015</code> subdirectory (or the corresponding directory for another version of Visual Studio). The fastest way is to copy another plugin's project file. Then, edit the file (this is an XML file) and replace the names of the project and source file. Finally, under Visual C++, add the new project in the solution (File / Add / Existing Project).</li>
</ul>
<p>In the source file, create a C++ class, derived from either <a class="el" href="classts_1_1_input_plugin.html" title="Input tsp plugin interface. ">ts::InputPlugin</a>, <a class="el" href="classts_1_1_output_plugin.html" title="Output tsp plugin interface. ">ts::OutputPlugin</a> or <a class="el" href="classts_1_1_processor_plugin.html" title="Packet processing tsp plugin interface. ">ts::ProcessorPlugin</a>. If your plugin implements two capabilities (both input and output for instance), implement the corresponding two classes.</p>
<p>See the class diagram of <a class="el" href="classts_1_1_plugin.html" title="Base class of all tsp plugins. ">ts::Plugin</a> for a global view of the plugin classes.</p>
<p>Specialized descrambling plugins derive from <a class="el" href="classts_1_1_abstract_descrambler.html" title="Abstract base class for DVB descrambler plugins. ">ts::AbstractDescrambler</a>. This abstract class performs the generic functions of a descrambler: service location, ECM collection, descrambling of elementary streams. The concrete classes which derive from <a class="el" href="classts_1_1_abstract_descrambler.html" title="Abstract base class for DVB descrambler plugins. ">ts::AbstractDescrambler</a> must perform CAS-specific operations: ECM streams filtering, ECM deciphering, control words extraction. Most of the time, these concrete classes must interact with a smartcard reader containing a smartcard for the specific CAS.</p>
<h1><a class="anchor" id="pdevguidelines"></a>
Development guidelines</h1>
<p>Don't write a plugin from scratch. Use an existing plugin as code base (beware however of the pitfalls of careless copy / paste). The simplest code bases can be found in the plugins <code>null</code> (input), <code>drop</code> (output) , <code>skip</code> (basic packet processing), <code>nitscan</code> (reading content of PSI/SI), <code>svrename</code> (modifying PSI/SI on the fly).</p>
<p>A last advice: Always create plugins which perform simple and elementary processing. If your requirements can be divided into two independent processing, create two distinct plugins. The strength of TSDuck is the flexibility, that is to say the ability to combine elementary processing independently and in any order.</p>
<h2><a class="anchor" id="pdevtsp"></a>
Invoking tsp from a plugin, the ts::TSP callbacks</h2>
<p>In its constructor, each plugin receives an associated <a class="el" href="classts_1_1_t_s_p.html" title="TSP callback for plugins. ">ts::TSP</a> object to communicate with the Transport Stream Processor main executable. A plugin shared library must exclusively use the <code>tsp</code> object for text display and must never use <code>std::cout</code>, <code>printf</code> or alike.</p>
<p>When called in multi-threaded context, the supplied <code>tsp</code> object is thread-safe and asynchronous (the methods return to the caller without waiting for the message to be printed).</p>
<h2><a class="anchor" id="pdevjtem"></a>
Joint termination support</h2>
<p>A plugin can decide to terminate <code>tsp</code> on its own (returning end of input, output error or <a class="el" href="classts_1_1_processor_plugin.html#ae2d04b1fe8008d7221d26a14f35bfba2a48bc3b71ae862118200ef63dec6afed1" title="End of processing, tell everybody to terminate. ">ts::ProcessorPlugin::TSP_END</a>). The termination is unconditional, regardless of the state of the other plugins. Thus, if several plugins have termination conditions, <code>tsp</code> stops when the first plugin decides to terminate. In other words, there is an "or" operator between the various termination conditions.</p>
<p>The idea behind joint termination is to terminate tsp when several plugins have jointly terminated their processing. If several plugins have a "joint termination" condition, <code>tsp</code> stops when the last plugin triggers the joint termination condition. In other words, there is an "and" operator between the various joint termination conditions.</p>
<p>First, a plugin must decide to use joint termination. This is usually done in method <a class="el" href="classts_1_1_plugin.html#a1e2964e9506e6788bd46bc96ca0f2670" title="The main application invokes start() to start the plugin. ">ts::Plugin::start()</a>, using <a class="el" href="classts_1_1_t_s_p.html#a248377e16e286a2a8e3d87bddc619760" title="Activates or deactivates &quot;joint termination&quot;. ">ts::TSP::useJointTermination(bool)</a> when the option <code>--joint-termination</code> is specified on the command line.</p>
<p>Then, when the plugin has completed its work, it reports this using <a class="el" href="classts_1_1_t_s_p.html#a17f412bba66c014fabbc728ab4f1479a" title="Signaling &quot;joint termination&quot;. ">ts::TSP::jointTerminate()</a>. After invoking this method, any packet which is processed by the plugin may be ignored by <code>tsp</code>.</p>
<h1><a class="anchor" id="pdevdesign"></a>
TSP design</h1>
<p>This section is a brief description of the design and internals of <code>tsp</code>. It contains some reference information for tsp maintainers.</p>
<p>This section is not useful to plugin developers. <code>tsp</code> is designed to clearly separate the technical aspects of the buffer management and dynamics of a chain of plugins from the specialized plugin processing (TS input, TS output, packet processing).</p>
<h2><a class="anchor" id="pdevexec"></a>
Plugin Executors</h2>
<p>Each plugin executes in a separate thread. The base class for all threads is <a class="el" href="classts_1_1tsp_1_1_plugin_executor.html" title="Execution context of a tsp plugin. ">ts::tsp::PluginExecutor</a>. Derived classes are used for input, output and packet processing plugins.</p>
<h2><a class="anchor" id="pdevbuffer"></a>
Transport packets buffer</h2>
<p>There is a global buffer for TS packets. Its structure is optimized for best performance.</p>
<p>The input thread writes incoming packets in the buffer. All packet processors update the packets and the output thread picks them at the same place. No packet is copied or moved in memory.</p>
<p>The buffer is an array of <a class="el" href="structts_1_1_t_s_packet.html" title="Basic definition of an MPEG-2 transport packet. ">ts::TSPacket</a>. It is a memory-resident buffer, locked in physical memory to avoid virtual memory paging (see class <a class="el" href="classts_1_1_resident_buffer.html" title="Implementation of memory buffer locked in physical memory. ">ts::ResidentBuffer</a>).</p>
<p>The buffer is managed in a circular way. It is divided into logical areas, one per plugin thread (including input and output). These logical areas are sliding windows which move when packets are processed.</p>
<p>Inside a ts::PluginExecutor object, the sliding window which is currently assigned to the plugin thread is defined by the index of its first packet (<code>_pkt_first</code>) and its size in packets (<code>_pkt_cnt</code>).</p>
<p>The documentation of class <a class="el" href="classts_1_1tsp_1_1_plugin_executor.html" title="Execution context of a tsp plugin. ">ts::tsp::PluginExecutor</a> contains a flat (non-circular) <a class="el" href="classts_1_1tsp_1_1_plugin_executor.html#PacketBufferModel">view of the buffer</a>.</p>
<p>When a thread terminates the processing of a bunch of packets, it moves up its first index and, consequently, decreases the size of its own area and accordingly increases the size of the area of the next plugin.</p>
<p>The modification of the starting index and size of any area must be performed under the protection of a mutex. There is one global mutex for simplicity. The resulting bottleneck is not so important since updating a few pointers is fast.</p>
<p>When the sliding window of a plugin is empty, the plugin thread sleeps on its <code>_to_do</code> condition variable. Consequently, when a thread passes packets to the next plugin (ie. increases the size of the sliding window of the next plugin), it must notify the <code>_to_do</code> condition variable of the next thread.</p>
<p>When a packet processor decides to drop a packet, the synchronization byte (first byte of the packet, normally 0x47) is reset to zero. When a packet processor or the output executor encounters a packet starting with a zero byte, it ignores it. Note that this is transparent to the plugin code in the shared library. The check is performed by the ts::ProcessorExecutor and ts::OutputExecutor objects. When a packet is marked as dropped, the plugin is not invoked.</p>
<p>All ts::PluginExecutor are chained in a ring. The first one is input and the last one is output. The output points back to the input so that the output executor can easily pass free packets to be reused by the input executor.</p>
<p>The <code>_input_end</code> flag indicates that there is no more packet to process after those in the plugin's area. This condition is signaled by the previous plugin in the chain. All plugins, except the output plugin, may signal this condition to their successor.</p>
<p>The <code>_aborted flag</code> indicates that the current plugin has encountered an error and has ceased to accept packets. This condition is checked by the previous plugin in the chain (which, in turn, will declare itself as aborted). All plugins, except the input plugin may signal this condition. In case of error, all plugins should also declare an <code>_input_end</code> to their successor. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
