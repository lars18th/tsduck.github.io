<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: ts::SafePtr&lt; T, MUTEX &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.11-710</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classts_1_1_safe_ptr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classts_1_1_safe_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ts::SafePtr&lt; T, MUTEX &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template safe pointer (reference-counted, auto-delete, thread-safe).  
 <a href="classts_1_1_safe_ptr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe15f31158e637bfffbf90af7c0e6f19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#abe15f31158e637bfffbf90af7c0e6f19">SafePtr</a> (T *p=0)</td></tr>
<tr class="memdesc:abe15f31158e637bfffbf90af7c0e6f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor using an optional unmanaged object.  <a href="#abe15f31158e637bfffbf90af7c0e6f19">More...</a><br /></td></tr>
<tr class="separator:abe15f31158e637bfffbf90af7c0e6f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0afe74d7f8abf5c96f3063b05f71c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#adf0afe74d7f8abf5c96f3063b05f71c0">SafePtr</a> (const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;sp)</td></tr>
<tr class="memdesc:adf0afe74d7f8abf5c96f3063b05f71c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#adf0afe74d7f8abf5c96f3063b05f71c0">More...</a><br /></td></tr>
<tr class="separator:adf0afe74d7f8abf5c96f3063b05f71c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964c52e0a1670190f67f519cc0944eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a5964c52e0a1670190f67f519cc0944eb">~SafePtr</a> ()</td></tr>
<tr class="memdesc:a5964c52e0a1670190f67f519cc0944eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5964c52e0a1670190f67f519cc0944eb">More...</a><br /></td></tr>
<tr class="separator:a5964c52e0a1670190f67f519cc0944eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe451273cda8ed75447995f35ed23bc"><td class="memTemplParams" colspan="2">template&lt;typename NEWMUTEX &gt; </td></tr>
<tr class="memitem:abfe451273cda8ed75447995f35ed23bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, NEWMUTEX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#abfe451273cda8ed75447995f35ed23bc">changeMutex</a> ()</td></tr>
<tr class="memdesc:abfe451273cda8ed75447995f35ed23bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change mutex type.  <a href="#abfe451273cda8ed75447995f35ed23bc">More...</a><br /></td></tr>
<tr class="separator:abfe451273cda8ed75447995f35ed23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cacc5bc83cff18e02210f26874cba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a75cacc5bc83cff18e02210f26874cba0">clear</a> ()</td></tr>
<tr class="memdesc:a75cacc5bc83cff18e02210f26874cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear this instance of the safe pointer.  <a href="#a75cacc5bc83cff18e02210f26874cba0">More...</a><br /></td></tr>
<tr class="separator:a75cacc5bc83cff18e02210f26874cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252de23e0b9a1af3367ccbc42b558703"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a252de23e0b9a1af3367ccbc42b558703">count</a> () const</td></tr>
<tr class="memdesc:a252de23e0b9a1af3367ccbc42b558703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count value.  <a href="#a252de23e0b9a1af3367ccbc42b558703">More...</a><br /></td></tr>
<tr class="separator:a252de23e0b9a1af3367ccbc42b558703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c05080eb15dc868f4260a56f1c1a23b"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename std::enable_if&lt; std::is_base_of&lt; T, ST &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9c05080eb15dc868f4260a56f1c1a23b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; ST, MUTEX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a9c05080eb15dc868f4260a56f1c1a23b">downcast</a> ()</td></tr>
<tr class="memdesc:a9c05080eb15dc868f4260a56f1c1a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast operation.  <a href="#a9c05080eb15dc868f4260a56f1c1a23b">More...</a><br /></td></tr>
<tr class="separator:a9c05080eb15dc868f4260a56f1c1a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a63c34b1854897d543548bd02a01950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a1a63c34b1854897d543548bd02a01950">isNull</a> () const</td></tr>
<tr class="memdesc:a1a63c34b1854897d543548bd02a01950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this safe pointer is a null pointer.  <a href="#a1a63c34b1854897d543548bd02a01950">More...</a><br /></td></tr>
<tr class="separator:a1a63c34b1854897d543548bd02a01950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135248fa8bb369cc0584c0dda075e2a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a135248fa8bb369cc0584c0dda075e2a8">operator!=</a> (const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;sp) const</td></tr>
<tr class="memdesc:a135248fa8bb369cc0584c0dda075e2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unequality operator.  <a href="#a135248fa8bb369cc0584c0dda075e2a8">More...</a><br /></td></tr>
<tr class="separator:a135248fa8bb369cc0584c0dda075e2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08ddf7ca5795e21b8cf86814e512b11"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#ac08ddf7ca5795e21b8cf86814e512b11">operator*</a> () const</td></tr>
<tr class="memdesc:ac08ddf7ca5795e21b8cf86814e512b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor operator.  <a href="#ac08ddf7ca5795e21b8cf86814e512b11">More...</a><br /></td></tr>
<tr class="separator:ac08ddf7ca5795e21b8cf86814e512b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9817515f76e8ef9e7f43eddda462a6b8"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a9817515f76e8ef9e7f43eddda462a6b8">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a9817515f76e8ef9e7f43eddda462a6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirection operator.  <a href="#a9817515f76e8ef9e7f43eddda462a6b8">More...</a><br /></td></tr>
<tr class="separator:a9817515f76e8ef9e7f43eddda462a6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa6e2c909992c0671930c61960a0b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a5fa6e2c909992c0671930c61960a0b0e">operator=</a> (const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;sp)</td></tr>
<tr class="memdesc:a5fa6e2c909992c0671930c61960a0b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment between safe pointers.  <a href="#a5fa6e2c909992c0671930c61960a0b0e">More...</a><br /></td></tr>
<tr class="separator:a5fa6e2c909992c0671930c61960a0b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739c62986b0f8e4bc0dcdd8f603f523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#ac739c62986b0f8e4bc0dcdd8f603f523">operator=</a> (T *p)</td></tr>
<tr class="memdesc:ac739c62986b0f8e4bc0dcdd8f603f523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from a standard pointer <code>T*</code>.  <a href="#ac739c62986b0f8e4bc0dcdd8f603f523">More...</a><br /></td></tr>
<tr class="separator:ac739c62986b0f8e4bc0dcdd8f603f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8a60fc18f00c3c12af7b00472dc98e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a4d8a60fc18f00c3c12af7b00472dc98e">operator==</a> (const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;sp) const</td></tr>
<tr class="memdesc:a4d8a60fc18f00c3c12af7b00472dc98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a4d8a60fc18f00c3c12af7b00472dc98e">More...</a><br /></td></tr>
<tr class="separator:a4d8a60fc18f00c3c12af7b00472dc98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86744709218aa9e93881c9a99506b252"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a86744709218aa9e93881c9a99506b252">pointer</a> () const</td></tr>
<tr class="memdesc:a86744709218aa9e93881c9a99506b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a standard pointer <code>T*</code> on the pointed object.  <a href="#a86744709218aa9e93881c9a99506b252">More...</a><br /></td></tr>
<tr class="separator:a86744709218aa9e93881c9a99506b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded64cd1ffe595489ee6a37ecf8ea379"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#aded64cd1ffe595489ee6a37ecf8ea379">release</a> ()</td></tr>
<tr class="memdesc:aded64cd1ffe595489ee6a37ecf8ea379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the pointed object from the safe pointer management.  <a href="#aded64cd1ffe595489ee6a37ecf8ea379">More...</a><br /></td></tr>
<tr class="separator:aded64cd1ffe595489ee6a37ecf8ea379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8313fa54cdeb0d0d69fa89f0d65f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#abd8313fa54cdeb0d0d69fa89f0d65f34">reset</a> (T *p=0)</td></tr>
<tr class="memdesc:abd8313fa54cdeb0d0d69fa89f0d65f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the previous pointed object and set the pointer to the new object.  <a href="#abd8313fa54cdeb0d0d69fa89f0d65f34">More...</a><br /></td></tr>
<tr class="separator:abd8313fa54cdeb0d0d69fa89f0d65f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c407af6712ae9d62e42db3a59dda44e"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename std::enable_if&lt; std::is_base_of&lt; ST, T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c407af6712ae9d62e42db3a59dda44e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; ST, MUTEX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classts_1_1_safe_ptr.html#a4c407af6712ae9d62e42db3a59dda44e">upcast</a> ()</td></tr>
<tr class="memdesc:a4c407af6712ae9d62e42db3a59dda44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast operation.  <a href="#a4c407af6712ae9d62e42db3a59dda44e">More...</a><br /></td></tr>
<tr class="separator:a4c407af6712ae9d62e42db3a59dda44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class MUTEX = NullMutex&gt;<br />
class ts::SafePtr&lt; T, MUTEX &gt;</h3>

<p>Template safe pointer (reference-counted, auto-delete, thread-safe). </p>
<p>The <a class="el" href="classts_1_1_safe_ptr.html" title="Template safe pointer (reference-counted, auto-delete, thread-safe). ">ts::SafePtr</a> template class is an implementation of the <em>safe</em> <em>pointer</em> design pattern. A safe pointer implements the semantics of a standard pointer with automatic memory management.</p>
<p>Safe pointer objects pointing to the same object can be assigned like any standard pointer (elementary type). A reference counter on the pointed object is maintained and the pointed object is automatically deleted when no more safe pointer references the object.</p>
<p><b>Limitation:</b> The automatic deletion of the pointed object occurs <em>only</em> when the reference counter reaches zero. There are cases where this never happens. Typically, when two objects reference each other but are no longer referenced anywhere else, these two objects are lost forever and will never be deleted. So, beware that smart pointers do not prevent from memory leaks in some pathological cases. As usual, be sure to design safely.</p>
<p><b>Limitation:</b> Because the automatic deletion is performed using the operator <code>delete</code>, safe pointers cannot point on array types since arrays must be deleted using the operator <code>delete</code>[].</p>
<p>The standard operators for elementary type pointers also exist for safe pointers (assignment, comparison, dereferencing, etc.)</p>
<p>A safe pointer can be <em>null</em>, this is the default value. In this case, the safe pointer does not reference any object. To test if a safe pointer is a null pointer, use the method <code><a class="el" href="classts_1_1_safe_ptr.html#a1a63c34b1854897d543548bd02a01950" title="Check if this safe pointer is a null pointer. ">isNull()</a></code>. Do not use comparisons such as <code>p == 0</code>, the result will be incorrect.</p>
<p>The <a class="el" href="classts_1_1_safe_ptr.html" title="Template safe pointer (reference-counted, auto-delete, thread-safe). ">ts::SafePtr</a> template class can be made thread-safe using a mutex. The type of mutex to use is given by the template parameter <em>MUTEX</em> which must be a subclass of <a class="el" href="classts_1_1_mutex_interface.html" title="Interface class for mutex objects. ">ts::MutexInterface</a>. By default, <a class="el" href="classts_1_1_null_mutex.html" title="Empty mutex implementation. ">ts::NullMutex</a> is used. The default implementation is consequently not thread-safe but there is no synchronization overhead. To use safe pointers in a multi-thread environment, specify an actual mutex implementation for the target environment.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointed object. Cannot be an array type. </td></tr>
    <tr><td class="paramname">MUTEX</td><td>A subclass of <a class="el" href="classts_1_1_mutex_interface.html" title="Interface class for mutex objects. ">ts::MutexInterface</a> which is used to synchronize access to the safe pointer internal state. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe15f31158e637bfffbf90af7c0e6f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe15f31158e637bfffbf90af7c0e6f19">&#9670;&nbsp;</a></span>SafePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::<a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor using an optional unmanaged object. </p>
<p>The optional argument <em>p</em> can be either <code>0</code> (null pointer) or the address of an <em>unmanaged</em> dynamically allocated object (i.e. which has been allocated using the operator <code>new</code>). In this case, <em>unmanaged</em> means that the object must not be already controlled by another set of safe pointers.</p>
<p>This constructor is typically used in combination with the operator <code>new</code> to allocate an object which is immediatly managed by safe pointers.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classts_1_1_safe_ptr.html">ts::SafePtr&lt;Foo&gt;</a> ptr (<span class="keyword">new</span> Foo (...));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to an object of class <em>T</em>. The default value is <code>0</code>, the null pointer. In this case, the safe pointer is a null pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if insufficient memory is available for internal safe pointer management. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf0afe74d7f8abf5c96f3063b05f71c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0afe74d7f8abf5c96f3063b05f71c0">&#9670;&nbsp;</a></span>SafePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::<a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>This object references the same <em>T</em> object as <em>sp</em>. If <em>sp</em> is a null pointer, this object is also a null pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Another safe pointer instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5964c52e0a1670190f67f519cc0944eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5964c52e0a1670190f67f519cc0944eb">&#9670;&nbsp;</a></span>~SafePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::~<a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If this object is not a null pointer, the reference counter is decremented. When the reference counter reaches zero, the pointed object is automatically deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fa6e2c909992c0671930c61960a0b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa6e2c909992c0671930c61960a0b0e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt;T,MUTEX&gt;&amp; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment between safe pointers. </p>
<p>After the assignment, this object references the same <em>T</em> object as <em>sp</em>. If this object was previously not the null pointer, the reference counter of the previously referenced <em>T</em> object is decremented. If the reference counter reaches zero, the previously pointed object is automatically deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>The value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="ac739c62986b0f8e4bc0dcdd8f603f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac739c62986b0f8e4bc0dcdd8f603f523">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt;T,MUTEX&gt;&amp; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment from a standard pointer <code>T*</code>. </p>
<p>The pointed <code>T</code> object becomes managed by this safe pointer.</p>
<p>The standard pointer <em>p</em> can be either <code>0</code> (null pointer) or the address of an <em>unmanaged</em> dynamically allocated object (i.e. which has been allocated using the operator <code>new</code>). In this case, <em>unmanaged</em> means that the object must not be already controlled by another set of safe pointers.</p>
<p>After the assignment, this object references the <em>T</em> object. If this safe pointer object was previously not the null pointer, the reference counter of the previously referenced <em>T</em> object is decremented. If the reference counter reaches zero, the previously pointed object is automatically deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to an object of class <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if insufficient memory is available for internal safe pointer management. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8a60fc18f00c3c12af7b00472dc98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8a60fc18f00c3c12af7b00472dc98e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Check if this safe pointer and the <em>sp</em> safe pointer point to same object.</p>
<p><b>Caveat:</b> Null pointers are not reliably compared with this operator. It shall not be used to compare against null pointer. Do not check <code>== 0</code>, use the method <code><a class="el" href="classts_1_1_safe_ptr.html#a1a63c34b1854897d543548bd02a01950" title="Check if this safe pointer is a null pointer. ">isNull()</a></code> instead. Also, if both safe pointers are null pointers, the result is unpredictable, it can be true or false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>A safe pointer to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both safe pointers reference the same object and false otherwise. </dd></dl>

</div>
</div>
<a id="a135248fa8bb369cc0584c0dda075e2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135248fa8bb369cc0584c0dda075e2a8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt; T, MUTEX &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unequality operator. </p>
<p>Check if this safe pointer and the <em>sp</em> safe pointer point to different objects.</p>
<p><b>Caveat:</b> Null pointers are not reliably compared with this operator. It shall not be used to compare against null pointer. Do not check <code>!= 0</code>, use the method <code><a class="el" href="classts_1_1_safe_ptr.html#a1a63c34b1854897d543548bd02a01950" title="Check if this safe pointer is a null pointer. ">isNull()</a></code> instead. Also, if both safe pointers are null pointers, the result is unpredictable, it can be true or false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>A safe pointer to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both safe pointers reference distinct objects and false otherwise. </dd></dl>

</div>
</div>
<a id="a9817515f76e8ef9e7f43eddda462a6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9817515f76e8ef9e7f43eddda462a6b8">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirection operator. </p>
<p>With this operator, a safe pointer can be used in the same way as a standard pointer.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> open();</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classts_1_1_safe_ptr.html">ts::SafePtr&lt;Foo&gt;</a> ptr(<span class="keyword">new</span> Foo);</div><div class="line">ptr-&gt;open();</div></div><!-- fragment --><p>If this object is the null pointer, the operator returns zero and the further dereferencing operation will likely throw an exception.</p>
<dl class="section return"><dt>Returns</dt><dd>A standard pointer <code>T*</code> to the pointed object or <code>0</code> if this object is the null pointer. </dd></dl>

</div>
</div>
<a id="ac08ddf7ca5795e21b8cf86814e512b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08ddf7ca5795e21b8cf86814e512b11">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor operator. </p>
<p>With this operator, a safe pointer can be used in the same way as a standard pointer.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(Foo&amp;);</div><div class="line"></div><div class="line"><a class="code" href="classts_1_1_safe_ptr.html">ts::SafePtr&lt;Foo&gt;</a> ptr(<span class="keyword">new</span> Foo);</div><div class="line">f(*ptr);</div></div><!-- fragment --><p>If this object is the null pointer, the operator will likely throw an exception.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference <code>T&amp;</code> to the pointed object. </dd></dl>

</div>
</div>
<a id="aded64cd1ffe595489ee6a37ecf8ea379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded64cd1ffe595489ee6a37ecf8ea379">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the pointed object from the safe pointer management. </p>
<p>The previously pointed object is not deallocated, its address is returned. All safe pointers which pointed to the object now point to <code>0</code> (null pointers).</p>
<p><b>Caveat:</b> The previously pointed object will no longer be automatically deleted. The caller must explicitly delete it later using the returned pointer value.</p>
<dl class="section return"><dt>Returns</dt><dd>A standard pointer <code>T*</code> to the previously pointed object. Return <code>0</code> if this object was the null pointer. </dd></dl>

</div>
</div>
<a id="abd8313fa54cdeb0d0d69fa89f0d65f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8313fa54cdeb0d0d69fa89f0d65f34">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the previous pointed object and set the pointer to the new object. </p>
<p>All safe pointers which pointed to the same object now point to the new one. The previously pointed object is deleted using the operator <code>delete</code>.</p>
<p>The standard pointer <em>p</em> can be either <code>0</code> (null pointer) or the address of an <em>unmanaged</em> dynamically allocated object (i.e. which has been allocated using the operator <code>new</code>). In this case, <em>unmanaged</em> means that the object must not be already controlled by another set of safe pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to an object of class <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75cacc5bc83cff18e02210f26874cba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cacc5bc83cff18e02210f26874cba0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear this instance of the safe pointer. </p>
<p>The referenced object is deallocated if no more reference exists. Then, this safe pointer becomes the null pointer. <code>sp.clear()</code> is equivalent to <code>sp = (T*)(0)</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if insufficient memory is available for internal safe pointer management. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a63c34b1854897d543548bd02a01950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a63c34b1854897d543548bd02a01950">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this safe pointer is a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this safe pointer is a null pointer, false otherwise. </dd></dl>

</div>
</div>
<a id="a4c407af6712ae9d62e42db3a59dda44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c407af6712ae9d62e42db3a59dda44e">&#9670;&nbsp;</a></span>upcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<div class="memtemplate">
template&lt;typename ST , typename std::enable_if&lt; std::is_base_of&lt; ST, T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt;ST,MUTEX&gt; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::upcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upcast operation. </p>
<p>This method converts a safe pointer to an object of class <em>T</em> into a safe pointer to an object of a super-class <em>ST</em> of <em>T</em>.</p>
<p>If this object is not the null pointer, the ownership of the pointed object is <em>transfered</em> to a new safe pointer to <em>ST</em>. This new safe pointer is returned. This object (the safe pointer to <em>T</em>) and all other safe pointers to <em>T</em> which pointed to the same object become null pointers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST</td><td>A super-class of <em>T</em> (immediate or indirect). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this object is not the null pointer, return a safe pointer to the same object, interpreted as <em>ST</em>. Otherwise, return the null pointer. The <em>MUTEX</em> type of the returned safe pointer is the same as used in this object. </dd></dl>

</div>
</div>
<a id="a9c05080eb15dc868f4260a56f1c1a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c05080eb15dc868f4260a56f1c1a23b">&#9670;&nbsp;</a></span>downcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<div class="memtemplate">
template&lt;typename ST , typename std::enable_if&lt; std::is_base_of&lt; T, ST &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt;ST,MUTEX&gt; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::downcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast operation. </p>
<p>This method converts a safe pointer to an object of class <em>T</em> into a safe pointer to an object of a subclass <em>ST</em> of <em>T</em>. This operation is equivalent to a <em>dynamic_cast</em> operator on regular pointers.</p>
<p>If this object is not the null pointer and points to an instance of <em>ST</em>, the ownership of the pointed object is <em>transfered</em> to a new safe pointer to <em>ST</em>. This new safe pointer is returned. This object (the safe pointer to <em>T</em>) and all other safe pointers to <em>T</em> which pointed to the same object become null pointers.</p>
<p>If this object is the null pointer or points to a <em>T</em> object which is not an instance of <em>ST</em>, the returned value is the null pointer and this object is unmodified.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST</td><td>A subclass of <em>T</em> (immediate or indirect). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this object is not the null pointer and points to an instance of <em>ST</em>, return a safe pointer to the same object, interpreted as <em>ST</em>. Otherwise, return the null pointer. The <em>MUTEX</em> type of the returned safe pointer is the same as used in this object. </dd></dl>

</div>
</div>
<a id="abfe451273cda8ed75447995f35ed23bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe451273cda8ed75447995f35ed23bc">&#9670;&nbsp;</a></span>changeMutex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<div class="memtemplate">
template&lt;typename NEWMUTEX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classts_1_1_safe_ptr.html">SafePtr</a>&lt;T,NEWMUTEX&gt; <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::changeMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change mutex type. </p>
<p>This method converts a safe pointer to an object of class <em>T</em> into a safe pointer to the same class <em>T</em> with a different class of mutex.</p>
<p>If this object is not the null pointer, the ownership of the pointed object is <em>transfered</em> to a new safe pointer. This new safe pointer is returned. This object and all other safe pointers of the same class which pointed to the same object become null pointers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NEWMUTEX</td><td>Another subclass of <a class="el" href="classts_1_1_mutex_interface.html" title="Interface class for mutex objects. ">ts::MutexInterface</a> which is used to synchronize access to the new safe pointer internal state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A safe pointer to the same object. </dd></dl>

</div>
</div>
<a id="a86744709218aa9e93881c9a99506b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86744709218aa9e93881c9a99506b252">&#9670;&nbsp;</a></span>pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a standard pointer <code>T*</code> on the pointed object. </p>
<p><b>Warning:</b> This is an unchecked operation. Do not store this pointer to dereference it later since the pointed object may have been deleted in the meantime if no more safe pointer reference the object.</p>
<dl class="section return"><dt>Returns</dt><dd>A standard pointer <code>T*</code> to the pointed object or <code>0</code> if this object is the null pointer. </dd></dl>

</div>
</div>
<a id="a252de23e0b9a1af3367ccbc42b558703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252de23e0b9a1af3367ccbc42b558703">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class MUTEX = NullMutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classts_1_1_safe_ptr.html">ts::SafePtr</a>&lt; T, MUTEX &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reference count value. </p>
<p>This is informational only. In multi-threaded environments, the actual reference count may change before the result is actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of safe pointer objects which reference the same pointed object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ts_safe_ptr_8h.html">tsSafePtr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
