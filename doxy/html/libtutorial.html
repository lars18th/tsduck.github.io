<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: TSDuck Library Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.9-574</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('libtutorial.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TSDuck Library Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cppfeatures">C++ features</a><ul><li class="level2"><a href="#portability">Portability issues</a></li>
<li class="level2"><a href="#cppstrings">C++ strings</a></li>
<li class="level2"><a href="#unicodestring">Unicode strings</a></li>
<li class="level2"><a href="#bindata">Binary data</a></li>
<li class="level2"><a href="#memmgmt">Memory management</a></li>
<li class="level2"><a href="#singletons">Variables, singletons and static data</a></li>
<li class="level2"><a href="#errreport">Error reporting</a></li>
<li class="level2"><a href="#except">Exceptions</a></li>
<li class="level2"><a href="#enums">Pseudo-enumeration data</a></li>
<li class="level2"><a href="#cmdargs">Command-line arguments</a></li>
<li class="level2"><a href="#xml">XML data</a></li>
<li class="level2"><a href="#json">JSON data</a></li>
</ul>
</li>
<li class="level1"><a href="#crypto">Cryptography</a></li>
<li class="level1"><a href="#osfeatures">Operating system features</a><ul><li class="level2"><a href="#sysutils">Miscelleaneous system utilities</a></li>
<li class="level2"><a href="#time">Time</a></li>
<li class="level2"><a href="#multithread">Multithreading</a></li>
<li class="level2"><a href="#virtmem">Virtual memory</a></li>
<li class="level2"><a href="#processes">Processes</a></li>
<li class="level2"><a href="#networking">Networking</a></li>
<li class="level2"><a href="#sharelibs">Shared libraries</a></li>
<li class="level2"><a href="#pcscinterface">Smart-card interface</a></li>
<li class="level2"><a href="#wincom">Windows specificities</a></li>
</ul>
</li>
<li class="level1"><a href="#mpegfeatures">MPEG/DVB features</a><ul><li class="level2"><a href="#tsclasses">Transport streams</a></li>
<li class="level2"><a href="#audiovideopes">Audio, video and PES packets</a></li>
<li class="level2"><a href="#siclasses">Signalization</a><ul><li class="level3"><a href="#sigformats">Binary, specialized and XML formats</a></li>
<li class="level3"><a href="#demux">Demux and packetization</a></li>
</ul>
</li>
<li class="level2"><a href="#dvbprotocols">DVB SimulCrypt protocols</a></li>
<li class="level2"><a href="#cassupport">Conditional access systems</a></li>
<li class="level2"><a href="#otherdemux">Other forms of demux</a></li>
<li class="level2"><a href="#dvbtuners">DVB tuners</a></li>
<li class="level2"><a href="#dektecops">Interface to Dektec devices</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The TSDuck library contains general-purpose C++ classes and utilities to handle MPEG transport streams.</p>
<p>Roughly, the TSDuck library provides two categories of features:</p>
<ul>
<li>Operating system abstraction layer to make the application code fully portable between heterogeneous platforms. This is similar to frameworks such as Qt, but much more lightweight.</li>
<li>Handling of MPEG/DVB transport streams and signalization.</li>
</ul>
<p>All C++ declarations are located inside the namespace <code>ts</code>, either directly within <code>ts</code> or inside inner namespaces. All preprocessor's macros are named with prefix <code>TS_</code>.</p>
<h1><a class="anchor" id="cppfeatures"></a>
C++ features</h1>
<h2><a class="anchor" id="portability"></a>
Portability issues</h2>
<p>The file <a class="el" href="ts_platform_8h.html" title="Cross-platforms portable base definitions for the TSDuck project. ">tsPlatform.h</a> contains some very low level definitions such as macros defining the environment (processor, compiler, operating system, endianness), byte and bit manipulation, etc.</p>
<h2><a class="anchor" id="cppstrings"></a>
C++ strings</h2>
<p>C and C++ strings are made of 8-bit characters which are notoriously unable to represent international character sets. The usage of <code>std::string</code> with the TSDuck library is now discouraged in favor of <a class="el" href="libtutorial.html#unicodestring">Unicode strings</a>.</p>
<h2><a class="anchor" id="unicodestring"></a>
Unicode strings</h2>
<p>The class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">ts::UString</a> implements Java-like Unicode strings. Each character uses 16 bits of storage. Formally, <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">ts::UString</a> uses UTF-16 representation. This means that all characters from all modern languages can be represented as one single character. Characters from archaic languages may need two UTF-16 values, called a "surrogate pair".</p>
<p>Technically, <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">ts::UString</a> is a subclass of <code>std::u16string</code>. So any operation on standard C++ strings is also available to <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">ts::UString</a>. But many more operations have been added to manipulate Unicode strings.</p>
<p>For consistency, the type <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0" title="UTF-16 character. ">ts::UChar</a> is a typedef for <code>char16_t</code>. The file <a class="el" href="ts_u_char_8h.html" title="Unicode characters. ">tsUChar.h</a> defines some utility functions on <a class="el" href="namespacets.html#a7e3244e77fae7815254d87d2ebdb7bd0" title="UTF-16 character. ">ts::UChar</a>. It also defines constants for most Unicode characters like <a class="el" href="namespacets.html#aa2b7b60f9b9006675d82656a7310a36c" title="ISO-8859 Unicode character. ">ts::COLON</a> or <a class="el" href="namespacets.html#a5b2083ec9f26bf27c7f6c9ad8fede3ed" title="ISO-8859 Unicode character. ">ts::LATIN_CAPITAL_LETTER_A_WITH_ACUTE</a>, among hundredths of others.</p>
<p>Some interesting features in class <a class="el" href="classts_1_1_u_string.html" title="An implementation of UTF-16 strings. ">ts::UString</a> are:</p><ul>
<li>Explicit and implicit conversions between UTF-8 and UTF-16.</li>
<li>Including automatic conversion to UTF-8 when writing to text streams.</li>
<li>Conversions with DVB character sets.</li>
<li>Conversions with HTML encoding.</li>
<li>Management of "display width", that is to say the amount of space which is used when the string is displayed. This can be different from the string length in the presence of combining diacritical characters or surrogate pairs.</li>
<li>String padding, trimming, truncation, justification, case conversions.</li>
<li>Substring, prefix or suffix detection, removal or substitution.</li>
<li>Splitting and joining strings based on separators or line widths.</li>
<li>Reading or writing text lines from or to a text file.</li>
<li>Data formatting using <a class="el" href="classts_1_1_u_string.html#ac700959acea9ad3915f6d19cae5b8612">Format()</a>, <a class="el" href="classts_1_1_u_string.html#a3b50a1c0e877f78224e765fbba6548f9">Decimal()</a>, <a class="el" href="classts_1_1_u_string.html#a59e86799482cd921d27d074fd1a44e42">Hexa()</a> or <a class="el" href="classts_1_1_u_string.html#ac55f25f55f2cdc5ac4c203348f62c5c6">Dump()</a>.</li>
<li>Data scanning using <a class="el" href="classts_1_1_u_string.html#ae9ad4436655c7622b184598f5dd7593d">scan()</a>.</li>
</ul>
<p>Unicode strings can be converted to and from DVB strings. Most DVB-defined character sets are implemented (see the class <a class="el" href="classts_1_1_d_v_b_charset.html" title="Definition of a character set for DVB encoding. ">ts::DVBCharset</a>) and recognized when a string is read from a descriptor. When a string is serialized into a binary descriptor, the most appropriate DVB character set is used. In practice, a few known DVB character sets are used and when the string cannot be encoded in any of them UTF-8 is used (UTF-8 is a valid DVB character set).</p>
<h2><a class="anchor" id="bindata"></a>
Binary data</h2>
<p>The class <a class="el" href="classts_1_1_byte_block.html" title="Definition of a generic block of bytes. ">ts::ByteBlock</a> represents a raw block of bytes. It is a subclass of <code>std::vector&lt;uint8_t&gt;</code> and consequently benefits from all standard vector operations. It also adds useful methods for data serialization or deserialization in any byte order.</p>
<p>For data serialization or deserialization over arbitrary memory areas, the header file <a class="el" href="ts_platform_8h.html" title="Cross-platforms portable base definitions for the TSDuck project. ">tsPlatform.h</a> provides low-level functions to access integer values of 8, 16, 24, 32 and 64 bits in any byte order.</p>
<p>The class <a class="el" href="classts_1_1_bit_stream.html" title="Class to analyze a bit-stream in memory. ">ts::BitStream</a> provides an abstraction layer over a memory area to parse bitstreams. It gives access to data of any bit-size at any bit position, either as a continuous stream or seeking at random bit positions.</p>
<h2><a class="anchor" id="memmgmt"></a>
Memory management</h2>
<p>The memory management is entirely based on the <em>smart pointer design pattern</em>. This is implemented by the template class <a class="el" href="classts_1_1_safe_ptr.html" title="Template safe pointer (reference-counted, auto-delete, thread-safe). ">ts::SafePtr</a>, using internal reference counters.</p>
<p>All dynamically allocated objected are managed using smart pointers. Thus, coding in C++ is as simple as in Java: simply allocate objects, always use smart pointers to reference them and forget about memory management. When an object is no longer referenced, it is automatically deallocated. Extensive testing using tools like <em>valgrind</em> have proven this to be true.</p>
<p>Be aware, however, that smart pointers are not completely as efficient as Java garbage collector. There are a few pathological cases where objects are never deallocated. This is the case when two objects reference each other but are no longer referenced anywhere else. A true garbage collector would detect this pair of objects as collectively inaccessible and will reclaim them. Smart pointers, on the contrary, will never deallocate them since their reference count is not zero. But such cases are rare and well know. So, just pay attention to them.</p>
<p>Smart pointers can be made thread-safe through a <em>mutex</em> class as template parameter.</p>
<p>The default mutex class is <a class="el" href="classts_1_1_null_mutex.html" title="Empty mutex implementation. ">ts::NullMutex</a> which does nothing. So, by default, smart pointers are not thread-safe. All usages of a given instantiation of <a class="el" href="classts_1_1_safe_ptr.html" title="Template safe pointer (reference-counted, auto-delete, thread-safe). ">ts::SafePtr</a> shall take place in the same thread (or must be explicitly synchronized). So, using smart pointers is fast by default, without synchronization overhead.</p>
<p>To make an instantiation of <a class="el" href="classts_1_1_safe_ptr.html" title="Template safe pointer (reference-counted, auto-delete, thread-safe). ">ts::SafePtr</a> thread-safe, use the class <a class="el" href="classts_1_1_mutex.html" title="A mutex implementation which is compatible with the ts::Thread class. ">ts::Mutex</a> as template parameter. Smart pointers from this instantiation can be used from different threads. Note, however, that the protection does not extend to the <em>pointed</em> object which must be properly synchronized.</p>
<p>A typical application of thread-safe smart pointers is inter-thread communication using message queues. If the messages are polymorph or too big to be copied in the message queue, use thread-safe smart pointers to these messages. The message queue copies smart pointers, not objects. To implement message queues, you may use the template class <a class="el" href="classts_1_1_message_queue.html" title="Template message queue for inter-thread communication. ">ts::MessageQueue</a>.</p>
<h2><a class="anchor" id="singletons"></a>
Variables, singletons and static data</h2>
<p>The template class <a class="el" href="classts_1_1_variable.html" title="A template class which defines a variable which can be either initialized or uninitialized. ">ts::Variable</a> implements an uninitialized variable of a given type (the template parameter). An instance of this type can be explicitly marked as uninitialized, set or cleared.</p>
<p>The <em>singleton</em> design pattern is simple in theory, but not so simple to implement correctly in practice. The TSDuck library encapsulates the implementation difficulties using the two macros <a class="el" href="ts_singleton_manager_8h.html#a526dbf8321e5c6cd67ff16b871a10718" title="Singleton class declaration. ">TS_DECLARE_SINGLETON()</a> and <a class="el" href="ts_singleton_manager_8h.html#aaf59eddceac20e0dfb3b4bab3e5e8025" title="Singleton class definition. ">TS_DEFINE_SINGLETON()</a>.</p>
<p>Similarly, using static data can be a nightmare because it is impossible to manage the initialization order of modules in C++. Again, the TSDuck library encapsulates these implementation difficulties using the macro <a class="el" href="ts_static_instance_8h.html#abc69775def67c588d36910aefd827b9e" title="Local declaration of a static object regardless of modules initialization order. ">TS_STATIC_INSTANCE()</a>.</p>
<h2><a class="anchor" id="errreport"></a>
Error reporting</h2>
<p>All TSDuck classes use a consistent error reporting mechanism through the <a class="el" href="classts_1_1_report.html" title="Abstract interface for event reporting and monitoring. ">ts::Report</a> abstract class.</p>
<p>This interface defines several levels of severity in the type <a class="el" href="structts_1_1_severity.html" title="Message severity. ">ts::Severity</a>, ranging from <a class="el" href="structts_1_1_severity.html#ac0f236bf85436043f080b4b4aaad9178" title="First debug level. ">ts::Severity::Debug</a> to <a class="el" href="structts_1_1_severity.html#a69c5602f643bc6626deac73466fbb962" title="Fatal error, typically aborts the application. ">ts::Severity::Fatal</a>. Each instance of <a class="el" href="classts_1_1_report.html" title="Abstract interface for event reporting and monitoring. ">ts::Report</a> defines which levels of message are reported to the user. This is usually triggered by command-line options such as <code>--verbose</code> or <code>--debug</code>.</p>
<p>Most classes or methods from the TSDuck library use a reference to an instance of <a class="el" href="classts_1_1_report.html" title="Abstract interface for event reporting and monitoring. ">ts::Report</a> to report messages and errors. The actual reporting object is often built at application level and then propagated to all layers of code.</p>
<p>Some interesting subclasses of <a class="el" href="classts_1_1_report.html" title="Abstract interface for event reporting and monitoring. ">ts::Report</a> are:</p><ul>
<li><a class="el" href="classts_1_1_cerr_report.html" title="A singleton implementing Report on std::cerr without synchronization. ">ts::CerrReport</a>, a singleton which reports errors to <code>std::cerr</code>. The macro <a class="el" href="ts_cerr_report_8h.html#a176c0577baa96c686397bca42f7ee6ff">CERR</a> can be used as a shortcut to the instance of the singleton.</li>
<li><a class="el" href="classts_1_1_null_report.html" title="A singleton implementing Report which drops all messages. ">ts::NullReport</a>, a singleton which drops all messages. The macro <a class="el" href="ts_null_report_8h.html#adeec374ad4628a07d93c1a0eb848ee00">NULLREP</a> can be used as a shortcut to the instance of the singleton.</li>
<li><a class="el" href="classts_1_1_report_file.html" title="A subclass of ts::Report which outputs messages in a text file. ">ts::ReportFile</a> which logs messages in a file. It can be made thread-safe using a mutex class as template argument.</li>
<li><a class="el" href="classts_1_1_report_buffer.html" title="A subclass of ts::Report which logs all messages in an internal buffer. ">ts::ReportBuffer</a> which logs messages in a memory buffer. It can be made thread-safe using a mutex class as template argument.</li>
<li><a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a> (see <a class="el" href="libtutorial.html#cmdargs">below</a>) which defines the syntax and handling of command line arguments. This is the typical instance of <a class="el" href="classts_1_1_report.html" title="Abstract interface for event reporting and monitoring. ">ts::Report</a> which is used at application-level.</li>
<li><a class="el" href="classts_1_1_t_s_p.html" title="TSP callback for plugins. ">ts::TSP</a>, a class which is used by tsp plugins to communicate with the top-level <em>tsp</em> application. Each tsp plugin executes in a separate thread. This class is used to asynchronously log messages from plugins without slowing down the plugin's thread.</li>
</ul>
<h2><a class="anchor" id="except"></a>
Exceptions</h2>
<p>As a general rule, TSDuck prefers the usage of error reporting interface and error status over exceptions. However, for a limited number of unrecoverable conditions which should never occur in practice, exceptions are used.</p>
<p>All TSDuck exceptions inherit from the superclass <a class="el" href="classts_1_1_exception.html" title="Base class for all exceptions in TSDuck. ">ts::Exception</a>. An instance of this exception is able to embed an error message and an optional system error code (type <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4" title="Integer type for operating system error codes. ">ts::ErrorCode</a>).</p>
<p>Each specific exception should be a subclass of <a class="el" href="classts_1_1_exception.html" title="Base class for all exceptions in TSDuck. ">ts::Exception</a>. Instead of rewriting the subclass code, applications should use the macro <a class="el" href="ts_exception_8h.html#a9a1d30844017c54dda8ee54cbd79feb9" title="This macro declares an exception as a subclass of ts::Exception. ">TS_DECLARE_EXCEPTION()</a>.</p>
<h2><a class="anchor" id="enums"></a>
Pseudo-enumeration data</h2>
<p>An instance of the class <a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">ts::Enumeration</a> associates a list of integer or <em>enum</em> values with strings. It can be used to display meaningful strings instead of integer values. But it is even more useful to decode command line arguments. When an option accepts a predefined list of values, the input string can be either an integer value or a name. When it is a name, it can even be abbreviated as long as it is not ambiguous in the corresponding <a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">ts::Enumeration</a>. This is transparent for the application which receives the corresponding integer value.</p>
<h2><a class="anchor" id="cmdargs"></a>
Command-line arguments</h2>
<p>The class <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a> implements a generic handling of command line arguments.</p>
<p>Each application or plugin typically defines its own subclass of <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a>. The subclass defines the command line syntax and the corresponding help text. The superclass <a class="el" href="classts_1_1_args.html" title="An encapsulation of command line syntax and analysis. ">ts::Args</a> automatically parses the command line, reports errors and common options such as <code>--help</code> or <code>--version</code>.</p>
<p>The value of command line options can be free strings, integer values or enumeration values. Integer values are recognized in decimal or hexadecimal form (prefix <code>0x</code>) and thousands separators ('<code>,</code>') which are present for clarity are ignored. Enumeration values are handled through <a class="el" href="classts_1_1_enumeration.html" title="Enumeration of int/string pairs. ">ts::Enumeration</a>.</p>
<h2><a class="anchor" id="xml"></a>
XML data</h2>
<p>The TSDuck library embeds an XML parser and several classes to handle a DOM structure. See the class <a class="el" href="classts_1_1xml_1_1_node.html" title="Base class for all XML objects in a document. ">ts::xml::Node</a>, the abstract base class of the DOM hierarchy.</p>
<h2><a class="anchor" id="json"></a>
JSON data</h2>
<p>The TSDuck library embeds a JSON parser and several classes to handle JSON values. See the class <a class="el" href="classts_1_1json_1_1_value.html" title="Abstract base class of a JSON value. ">ts::json::Value</a>, the abstract base class of the JSON hierarchy.</p>
<h1><a class="anchor" id="crypto"></a>
Cryptography</h1>
<p>The TSDuck library contains a few cryptographic classes. The TSDuck library is <em>not</em> a cryptographic library and will never be. Cryptography is a serious matter which should be left to cryptographers.</p>
<p>Some transport stream processing operations require some cryptography, essentially block ciphers and hash functions. To do that, the TSDuck library includes a few cryptographic functions which were originally copied from the <a href="http://www.libtom.net/LibTomCrypt/">LibTomCrypt library</a>.</p>
<p>This copy is allowed by the very liberal license of LibTomCrypt. Copying code from LibTomCrypt inside TSDuck instead of referencing it has the following advantages:</p>
<ul>
<li>Encapsulate the C API of LibTomCrypt into higher-level C++ classes.</li>
<li>Automatically manage the resources using C++ constructors and destructors.</li>
<li>Allow a portable usage of the cryptographic functions without rebuilding LibTomCrypt.</li>
<li>Remove a dependency to an external library.</li>
</ul>
<p>The abstract class <a class="el" href="classts_1_1_block_cipher.html" title="Abstract interface of block ciphers. ">ts::BlockCipher</a> is the root of a hierarchy of symmetric cryptography classes, including chaining modes. The main block cipher classes are <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">ts::AES</a>, <a class="el" href="classts_1_1_t_d_e_s.html" title="Triple-DES block cipher. ">ts::TDES</a> and <a class="el" href="classts_1_1_d_e_s.html" title="DES block cipher. ">ts::DES</a>.</p>
<p>Chaining modes are template classes which inherit from the abstract class <a class="el" href="classts_1_1_cipher_chaining.html" title="Base class of all cipher chaining modes. ">ts::CipherChaining</a>. The template parameter is a block cipher class. The main chaining modes are <a class="el" href="classts_1_1_e_c_b.html" title="Electronic Code Book (ECB) mode. ">ts::ECB</a>, <a class="el" href="classts_1_1_c_b_c.html" title="Cipher Block Chaining (CBC) mode. ">ts::CBC</a> or more exotic modes from the DTV world such as <a class="el" href="classts_1_1_d_v_s042.html" title="DVS 042 cipher block chaining mode. ">ts::DVS042</a>.</p>
<p>But <a class="el" href="classts_1_1_cipher_chaining.html" title="Base class of all cipher chaining modes. ">ts::CipherChaining</a> is also a subclass of <a class="el" href="classts_1_1_block_cipher.html" title="Abstract interface of block ciphers. ">ts::BlockCipher</a> because it remains a symmetric cipher. So, ciphers like <a class="el" href="classts_1_1_a_e_s.html" title="AES block cipher. ">ts::AES</a> or <b>ts::CBC&lt;ts::AES&gt;</b> can be used through the same <a class="el" href="classts_1_1_block_cipher.html" title="Abstract interface of block ciphers. ">ts::BlockCipher</a> interface.</p>
<p>The class <a class="el" href="classts_1_1_scrambling.html" title="DVB-CSA (Digital Video Broadcasting Common Scrambling Algorithm). ">ts::Scrambling</a> implements DVB-CSA-2, the Digital Video Broadcasting Common Scrambling Algorithm. This implementation is older than the open-source <a href="https://www.videolan.org/developers/libdvbcsa.html">libdvbcsa library</a> and is probably less efficient.</p>
<p>The abstract class <a class="el" href="classts_1_1_hash.html" title="Abstract interface of hash functions. ">ts::Hash</a> is the root of a hierarchy of hash functions classes. The main hash functions are <a class="el" href="classts_1_1_s_h_a1.html" title="SHA-1 hash. ">ts::SHA1</a>, <a class="el" href="classts_1_1_s_h_a256.html" title="SHA-256 hash. ">ts::SHA256</a> or <a class="el" href="classts_1_1_s_h_a512.html" title="SHA-512 hash. ">ts::SHA512</a>.</p>
<p>The abstract class <a class="el" href="classts_1_1_random_generator.html" title="Abstract base class for PRNG&#39;s (pseudo-random numbers generators). ">ts::RandomGenerator</a> if the root of pseudo-random generators. Currently, only one subclass exists: <a class="el" href="classts_1_1_system_random_generator.html" title="System-provided PRNG (pseudo-random numbers generator). ">ts::SystemRandomGenerator</a> which is a portable interface to the system-provided PRNG. Usually, this is not the best PRNG on earth, but it is fine for most usages in TSDuck applications. However, you should not use it for secure applications. If you need security, use a cryptographic library.</p>
<h1><a class="anchor" id="osfeatures"></a>
Operating system features</h1>
<h2><a class="anchor" id="sysutils"></a>
Miscelleaneous system utilities</h2>
<p>The file <a class="el" href="ts_sys_utils_8h.html" title="Various system utilities. ">tsSysUtils.h</a> declares utility functions on top of the operating system.</p>
<p>These functions manipulate:</p>
<ul>
<li>File paths.</li>
<li>File attributes.</li>
<li>Creating or deleting files and directories.</li>
<li>Environment variables.</li>
<li>Process identifiers.</li>
<li>System error codes.</li>
</ul>
<h2><a class="anchor" id="time"></a>
Time</h2>
<p>The class <a class="el" href="classts_1_1_time.html" title="The Time class implements a basic representation of time. ">ts::Time</a> is a portable implementation of time (both local and UTC time). Many operations are provided, such as:</p><ul>
<li>Getting system time in various forms.</li>
<li>Arithmetic operations on time.</li>
<li>Analysing and building time values.</li>
<li>Formatting time values as strings.</li>
</ul>
<p>The class <a class="el" href="classts_1_1_monotonic.html" title="Basic monotonic clock &amp; timer. ">ts::Monotonic</a> implements a monotonic clock and high-precision timer (to the best of the capabilities of the operating system). It is typically used by the plugin <em>regulate</em> for precise timing operations.</p>
<h2><a class="anchor" id="multithread"></a>
Multithreading</h2>
<p>TSDuck is heavily multi-threaded. Threading and synchronization are implemented through classes such as <a class="el" href="classts_1_1_thread.html" title="Base class for threads. ">ts::Thread</a>, <a class="el" href="classts_1_1_mutex.html" title="A mutex implementation which is compatible with the ts::Thread class. ">ts::Mutex</a>, <a class="el" href="classts_1_1_condition.html" title="Implementation of the synchronization condition design pattern. ">ts::Condition</a>, etc.</p>
<p>The abstract class <a class="el" href="classts_1_1_thread.html" title="Base class for threads. ">ts::Thread</a> manages a thread. To define an actual thread, derive this class and implement the virtual method <em>main()</em>.</p>
<p>The class <a class="el" href="classts_1_1_thread_attributes.html" title="Set of attributes for a thread object (ts::Thread). ">ts::ThreadAttributes</a> contains all mandatory or optional attributes of a thead. An application typically build a <a class="el" href="classts_1_1_thread_attributes.html" title="Set of attributes for a thread object (ts::Thread). ">ts::ThreadAttributes</a> object and then creates threads using these attributes.</p>
<p>The class <a class="el" href="classts_1_1_mutex.html" title="A mutex implementation which is compatible with the ts::Thread class. ">ts::Mutex</a> implements a recursive mutex to synchronize access to shared resources from concurrent threads.</p>
<p>The class <a class="el" href="classts_1_1_condition.html" title="Implementation of the synchronization condition design pattern. ">ts::Condition</a> implements a POSIX-like condition variable, using <em>signal()</em> and <em>wait()</em> primitives.</p>
<p>TSDuck relies on C++ mechanisms to track the usage of resources. The library provides mechanisms to ensure that no dangling lock is lost through the <em>guard design pattern</em>. It recommended to never explicitly use <em>acquire()</em> or <em>release()</em> primitives. Instead, use the classes <a class="el" href="classts_1_1_guard.html" title="Automatic guard class for mutex (ts::MutexInterface). ">ts::Guard</a> for mutexes and <a class="el" href="classts_1_1_guard_condition.html" title="Automatic guard class for synchronization condition (ts::Condition). ">ts::GuardCondition</a> for condition variables.</p>
<h2><a class="anchor" id="virtmem"></a>
Virtual memory</h2>
<p>The class <a class="el" href="classts_1_1_resident_buffer.html" title="Implementation of memory buffer locked in physical memory. ">ts::ResidentBuffer</a> implements a buffer which is locked in physical memory, preventing paging or swapping on this buffer. This is useful for large data buffers with high performance constraints.</p>
<p>This is a template class. The template parameter is the type of the elementary data in the buffer.</p>
<p>The core data of the <em>tsp</em> processor is a <b>ts::ResidentBuffer&lt;ts::TSPacket&gt;</b>. The incoming packets are directly written into this buffer by the input plugin. Each packet processing plugin directly reads and writes the packets here. And the output plugin reads the packet there, at the very same place they were written by the input plugin. Given that this global buffer is locked in physical memory, the best performances are guaranteed.</p>
<p>Note however that most operating systems require that the application has privileges to lock physical memory.</p>
<h2><a class="anchor" id="processes"></a>
Processes</h2>
<p>The class <a class="el" href="structts_1_1_process_metrics.html" title="This structure contains metrics about a process. ">ts::ProcessMetrics</a> and the function <a class="el" href="namespacets.html#a64cc0b0979e89bf83d62afa726e7d0e3" title="Get metrics for the current process. ">ts::GetProcessMetrics</a> are used to fetch CPU time and virtual memory usage of the current process. To track potential memory leaks and the impact of the application on the system, the class <a class="el" href="classts_1_1_system_monitor.html" title="Monitoring thread for system resources used by the application. ">ts::SystemMonitor</a> creates a background thread which reports the process metrics of the application at regular intervals.</p>
<p>The class <a class="el" href="classts_1_1_fork_pipe.html" title="Fork a process and create an optional pipe to its standard input. ">ts::ForkPipe</a> is a portable and convenient way to create a process running a specific command and creates an outgoing pipe from the calling application to the standard input of the created process. The pipe is open in binary mode (when it makes sense for the operating system) and can be used to pass an entire transport stream when necessary.</p>
<h2><a class="anchor" id="networking"></a>
Networking</h2>
<p>The classes <a class="el" href="classts_1_1_i_p_address.html" title="A basic representation of an IP v4 address. ">ts::IPAddress</a> and <a class="el" href="classts_1_1_socket_address.html" title="Socket address class (IP v4 address &amp; port). ">ts::SocketAddress</a> define an IPv4 address and a corresponding socket address (an IPv4 address and a port number). Host name resolution and multicast are supported.</p>
<p>The classes <a class="el" href="classts_1_1_t_c_p_socket.html" title="Base class for TCP/IP sockets. ">ts::TCPSocket</a> and <a class="el" href="classts_1_1_u_d_p_socket.html" title="UDP Socket. ">ts::UDPSocket</a> implement TCP/IP and UDP/IP endpoints.</p>
<p>The class <a class="el" href="classts_1_1_u_d_p_socket.html" title="UDP Socket. ">ts::UDPSocket</a> can be used directly to send and receive datagrams. Multicast is supported.</p>
<p>The class <a class="el" href="classts_1_1_t_c_p_socket.html" title="Base class for TCP/IP sockets. ">ts::TCPSocket</a> can be used only through two subclasses. The subclass <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">ts::TCPConnection</a> is a TCP/IP communication endpoint, either on client or server side. It is used to send or receive data streams. The subclass <a class="el" href="classts_1_1_t_c_p_server.html" title="Implementation of a TCP/IP server. ">ts::TCPServer</a> is used to implement a TCP server. It accepts incoming client connections and initiates a <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">ts::TCPConnection</a> for each new connection. On the client side, the class <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">ts::TCPConnection</a> is directly used to connect to the server.</p>
<p>Subclasses of <a class="el" href="classts_1_1_t_c_p_connection.html" title="Base class for a TCP/IP session. ">ts::TCPConnection</a> are used to implement specific protocols on top of TCP/IP. Currently, the available subclasses are <a class="el" href="classts_1_1_telnet_connection.html" title="Implementation of a half-duplex line oriented telnet connection. ">ts::TelnetConnection</a> and <a class="el" href="classts_1_1tlv_1_1_connection.html" title="TCP connection using TLV messages. ">ts::tlv::Connection</a>. The latter is used in <a class="el" href="libtutorial.html#dvbprotocols">DVB SimulCrypt head-end protocols</a>.</p>
<p>The class <a class="el" href="classts_1_1_web_request.html" title="Perform a simple Web request (HTTP, HTTPS, FTP). ">ts::WebRequest</a> performs simple Web requests using HTTP, HTTPS or FTP. Using a URL, the result can be downloaded in memory or in a file. Multiple redirections and SSL/TLS are automatically handled. This class is built on top of native system libraries (<em>libcurl</em> on UNIX systems, <em>Wininet</em> on Windows).</p>
<h2><a class="anchor" id="sharelibs"></a>
Shared libraries</h2>
<p>The TSDuck library contains classes to load shared libraries (<code></code>.dll on Windows, <code></code>.so on Linux) and lookup symbols inside them in a portable way. These classes are typically used to load TSP plugins but can be used in any application.</p>
<p>The class <a class="el" href="classts_1_1_shared_library.html" title="Shared library handling (.so on UNIX, DLL on Windows). ">ts::SharedLibrary</a> manipulates any type of shared library.</p>
<p>The subclass <a class="el" href="classts_1_1_application_shared_library.html" title="Representation of an application shared library. ">ts::ApplicationSharedLibrary</a> searches a shared library using TSDuck rules: if the file is not found "as it is", an optional prefix and a list of directories are used. This is how, for instance, searching the shared library named <em>"ip"</em> will end up loading the file <em>tsplugin_ip.dll</em> in the same directory as the application executable file.</p>
<p>Finally, the subclass <a class="el" href="classts_1_1_plugin_shared_library.html" title="Representation of a TSP plugin shared library. ">ts::PluginSharedLibrary</a> adds the resolution of the <em>tsp</em> plugin interface for input, output and packet processor plugins. This class is probably useless for third-party application, unless they want to use <em>tsp</em> plugins.</p>
<h2><a class="anchor" id="pcscinterface"></a>
Smart-card interface</h2>
<p>Applications which interact with smart-cards shall use the PC/SC interface. PC/SC is a standard interface which was originally developped for Windows but which is also available on Linux and macOS.</p>
<p>The TSDuck library does not embed or hide PC/SC but it provides a few utilities like transmitting an APDU and read the response in one single function or searching a smart-card with some characteristics in the ATR from all connected smart-cards.</p>
<p>All these utilities are grouped in the namespace <a class="el" href="namespacets_1_1pcsc.html" title="PC/SC smartcard API utilities. ">ts::pcsc</a>.</p>
<h2><a class="anchor" id="wincom"></a>
Windows specificities</h2>
<p>The class <a class="el" href="classts_1_1_c_o_m.html" title="A class to encapsulate the initialization of Windows COM. ">ts::COM</a> provides a portable and reliable way to make sure that the Common Object Model (COM) is properly initialized and terminated on Windows systems. This class is defined on all platforms but does nothing on non-Windows systems. It is consequently safe to use it everywhere without tedious conditional compilation directives.</p>
<p>Other classes manipulate Windows-specific objects and are not available on non-Windows systems.</p>
<p>The template class <a class="el" href="classts_1_1_com_ptr.html" title="Managed pointers for COM objects, auto-released (Windows-specific). ">ts::ComPtr</a> is the equivalent of a smart pointer for COM objects. The reference count of a COM object is properly incremented and decremented when the COM object is manipulated through a <a class="el" href="classts_1_1_com_ptr.html" title="Managed pointers for COM objects, auto-released (Windows-specific). ">ts::ComPtr</a>. The COM object is automatically released when no more reference exists.</p>
<h1><a class="anchor" id="mpegfeatures"></a>
MPEG/DVB features</h1>
<h2><a class="anchor" id="tsclasses"></a>
Transport streams</h2>
<p>The class <a class="el" href="structts_1_1_t_s_packet.html" title="Basic definition of an MPEG-2 transport packet. ">ts::TSPacket</a> defines a transport stream packet. It is in fact a flat structure which occupies exactly 188 bytes in memory. It is safe to use arrays or vectors of <a class="el" href="structts_1_1_t_s_packet.html" title="Basic definition of an MPEG-2 transport packet. ">ts::TSPacket</a>. The packets are guaranteed to be contiguous in memory.</p>
<p>But the class <a class="el" href="structts_1_1_t_s_packet.html" title="Basic definition of an MPEG-2 transport packet. ">ts::TSPacket</a> also adds many operations on the TS packet to read or modify properties like the PID (type <a class="el" href="namespacets.html#a90e2f5f7d7011d87cc23a8fef31958dc" title="PID value. ">ts::PID</a>), the continuity counters or deeper structures like PCR, DTS or PTS.</p>
<p>The class <a class="el" href="structts_1_1_transport_stream_id.html" title="Identification of a transport stream. ">ts::TransportStreamId</a> contains the identification of an MPEG/DVB transport stream.</p>
<p>The class <a class="el" href="classts_1_1_service.html" title="Describe a DVB service. ">ts::Service</a> contains all possible properties of a DVB service. Not all properties need to be set at the same time. Each property can be individually set, cleared or queried.</p>
<p>Transport stream files are implemented by classes <a class="el" href="classts_1_1_t_s_file_input.html" title="Transport Stream file input. ">ts::TSFileInput</a> and <a class="el" href="classts_1_1_t_s_file_output.html" title="Transport Stream file output. ">ts::TSFileOutput</a>. They respectively read and write transport stream files with specific features such as repeating the reading of a part of the file.</p>
<p>The subclass <a class="el" href="classts_1_1_t_s_file_input_buffered.html" title="Transport stream file input with a seekable buffer. ">ts::TSFileInputBuffered</a> provides additional, but limited, capabilities to seek forward and backward on non-seekable files such as pipes.</p>
<p>The subclass <a class="el" href="classts_1_1_t_s_file_output_resync.html" title="A specialized form of transport stream output file with resynchronized PID and continuity counters...">ts::TSFileOutputResync</a> adds resynchronization capabilities on continuity counters and PID's.</p>
<p>The class <a class="el" href="classts_1_1_t_s_analyzer.html" title="A class which analyzes a complete transport stream. ">ts::TSAnalyzer</a> consumes all TS packets from a transport stream and analyzes virtually everything from the stream. This is the class which is used by the command <em>tsanalyzer</em> to collect the vast amount of information it reports.</p>
<p>The class <a class="el" href="classts_1_1_p_c_r_analyzer.html" title="PCR statistics analysis. ">ts::PCRAnalyzer</a> is a useful tool to evaluate the bitrate of a transport stream. It performs the analysis of the Program Clock Reference (PCR) which are present in the transport stream in order to evaluate the bitrate of the stream. If PCR are not found, the class can also use Decoding Time Stamps (DTS) to evaluate the bitrate. This is less precise than PCR but can be used as a backup.</p>
<h2><a class="anchor" id="audiovideopes"></a>
Audio, video and PES packets</h2>
<p>The TSDuck library provides classes to manipulate PES packets and a few audio and video attributes. These features are limited to the analysis of a transport stream. There is no video or audio decoding features. Specialized libraries exist for this and are out of scope for TSDuck.</p>
<p>The class <a class="el" href="classts_1_1_p_e_s_packet.html" title="Representation of MPEG PES packets. ">ts::PESPacket</a> implements a PES packet and can manipulate its attributes, header and payload.</p>
<p>The class <a class="el" href="classts_1_1_p_e_s_demux.html" title="This class extracts PES packets from TS packets. ">ts::PESDemux</a> extracts PES packets from a transport stream. It can also notify the application of the changes in audio or video attributes.</p>
<p>The abstract class <a class="el" href="classts_1_1_abstract_audio_video_attributes.html" title="Abstract base class for MPEG audio and video attributes. ">ts::AbstractAudioVideoAttributes</a> is the root of a hierarchy of classes which contains attributes for audio or video streams. Currently, specialized classes exist for MPEG-2 video, AVC/H.264 video, MPEG-2 audio and AC-3 audio.</p>
<p>The class <a class="el" href="classts_1_1_a_v_c_parser.html" title="Parser for Advanced Video Coding data. ">ts::AVCParser</a> performs the parsing of an AVC/H.264 bitstream.</p>
<h2><a class="anchor" id="siclasses"></a>
Signalization</h2>
<p>The MPEG/DVB signalization is built from sections, tables and descriptors. All these concepts are implemented in the TSDuck library.</p>
<h3><a class="anchor" id="sigformats"></a>
Binary, specialized and XML formats</h3>
<p>Signalization objects, sections, tables and descriptors, can be manipulated in several formats: binary objects, specialized classes and XML.</p>
<p>The classes <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">ts::Section</a>, <a class="el" href="classts_1_1_binary_table.html" title="Representation of MPEG PSI/SI tables in binary form (ie. ">ts::BinaryTable</a> and <a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">ts::Descriptor</a> implement binary forms of the signalization objects.</p>
<p>A binary table are made of a collection of sections. A binary table is valid when all binary sections are present. Each section contains its section number in the table and the total expected number of sections inside the table.</p>
<p>All sections and descriptors can be represented by the classes <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">ts::Section</a> and <a class="el" href="classts_1_1_descriptor.html" title="Representation of a MPEG PSI/SI descriptors in binary format. ">ts::Descriptor</a>. They simply contain the complete binary content of the object and can manipulate the various components. An instance of <a class="el" href="classts_1_1_section.html" title="Representation of MPEG PSI/SI sections. ">ts::Section</a> stores the <em>table_id</em> and manipulates the various components of the section header. For long sections, the final CRC32 can be checked for consistency or recomputed after modification of the section content.</p>
<p>Tables can be stored in binary files. The format of the files is quite simple. They just contain raw binary sections, without any encapsulation. Tables can also be stored in XML files (see below). The class <a class="el" href="classts_1_1_section_file.html" title="A binary or XML file containing PSI/SI sections and tables. ">ts::SectionFile</a> reads and writes tables or section from files, independently of the format, either a binary section file or an XML file.</p>
<p>Tables and descriptors can also be manipulated using specialized classes such as <a class="el" href="classts_1_1_p_a_t.html" title="Representation of a Program Association Table (PAT) ">ts::PAT</a> or <a class="el" href="classts_1_1_p_m_t.html" title="Representation of a Program Map Table (PMT) ">ts::PMT</a> for tables and <a class="el" href="classts_1_1_content_descriptor.html" title="Representation of a content_descriptor. ">ts::ContentDescriptor</a> or <a class="el" href="classts_1_1_short_event_descriptor.html" title="Representation of an short_event_descriptor. ">ts::ShortEventDescriptor</a> for descriptors.</p>
<p>All specialized classes inherit from a common abstract root named <a class="el" href="classts_1_1_abstract_signalization.html" title="Abstract base class for MPEG PSI/SI tables and descriptors. ">ts::AbstractSignalization</a>. All descriptors inherit from <a class="el" href="classts_1_1_abstract_descriptor.html" title="Abstract base class for MPEG PSI/SI descriptors. ">ts::AbstractDescriptor</a>. All tables inherit from <a class="el" href="classts_1_1_abstract_table.html" title="Abstract base class for MPEG PSI/SI tables. ">ts::AbstractTable</a>. Tables with long sections inherit from <a class="el" href="classts_1_1_abstract_long_table.html" title="Abstract base class for MPEG PSI/SI tables with long sections. ">ts::AbstractLongTable</a>.</p>
<p>All MPEG-defined and DVB-defined tables are implemented. Most MPEG-defined and DVB-defined descriptors are implemented but not all of them. Unimplemented descriptors shall be manipulated in binary form (or be implemented...)</p>
<p>Binary tables or descriptors are converted from or to specialized classes using <em>serialize()</em> and <em>deserialize()</em> methods. The validity of a binary or specialized object can be checked using the <em>isValid()</em> method.</p>
<p>Sample deserialization: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> <a class="code" href="classts_1_1_binary_table.html">ts::BinaryTable</a>&amp; table)</div><div class="line">{</div><div class="line">    <a class="code" href="classts_1_1_p_m_t.html">ts::PMT</a> pmt;</div><div class="line">    <span class="keywordflow">if</span> (table.<a class="code" href="classts_1_1_binary_table.html#a00976cf2d7d939d1990747bcf1fd3564">isValid</a>() &amp;&amp; table.<a class="code" href="classts_1_1_binary_table.html#a5dbd5bd844b2e7ac12dea13ba243556b">tableId</a>() == <a class="code" href="namespacets.html#aec593563f4639a8a861a3d0018722c06a2b77f31e0fd86def5354eecae304e8b1">ts::TID_PMT</a>) {</div><div class="line">        pmt.<a class="code" href="classts_1_1_p_m_t.html#a44fff0acba6c5ba4fa7cd96bc9533092">deserialize</a>(table);</div><div class="line">        <span class="keywordflow">if</span> (pmt.<a class="code" href="classts_1_1_abstract_signalization.html#af7aa8ceb8b698ab219c05a36b0e97291">isValid</a>()) {</div><div class="line">            processPMT(pmt);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The deserialization can also be done in the constructor. And the validity and <em>table_id</em> checking is done anyway in the deserialization. So, the previous code can be simplified as: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> <a class="code" href="classts_1_1_binary_table.html">ts::BinaryTable</a>&amp; table)</div><div class="line">{</div><div class="line">    <a class="code" href="classts_1_1_p_m_t.html">ts::PMT</a> pmt(table);</div><div class="line">    <span class="keywordflow">if</span> (pmt.<a class="code" href="classts_1_1_abstract_signalization.html#af7aa8ceb8b698ab219c05a36b0e97291">isValid</a>()) {</div><div class="line">        processPMT(pmt);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Sample serialization: </p><div class="fragment"><div class="line"><a class="code" href="classts_1_1_p_m_t.html">ts::PMT</a> pmt;</div><div class="line">pmt.<a class="code" href="classts_1_1_abstract_long_table.html#a60a7651ae92e479f9cf7a06e4cb6aa0e">version</a> = 12;</div><div class="line">pmt.<a class="code" href="classts_1_1_p_m_t.html#a756517f870e764d3519fc5c93cdb0f16">service_id</a> = 0x1234;</div><div class="line"><span class="comment">// Declare one component, PID 0x345, carrying H.264/AVC video.</span></div><div class="line">pmt.<a class="code" href="classts_1_1_p_m_t.html#a23390084d5a59677574ab1dba6b2d286">streams</a>[0x345].stream_type = ts::ST_AVC_AUDIO;</div><div class="line"></div><div class="line"><a class="code" href="classts_1_1_binary_table.html">ts::BinaryTable</a> table;</div><div class="line">pmt.<a class="code" href="classts_1_1_p_m_t.html#adec8937866243f3a744f95e6c319e793">serialize</a>(table);</div></div><!-- fragment --><p>Finally, specialized classes for tables and descriptors can be converted to and from XML using the methods <em>toXML()</em> and <em>fromXML()</em>.</p>
<p>These methods are typically used by the class <a class="el" href="classts_1_1_section_file.html" title="A binary or XML file containing PSI/SI sections and tables. ">ts::SectionFile</a> which represents a file containing sections and tables in binary or XML format. The class can be used to load a set of tables in XML format or to store table objects in XML format.</p>
<p>The class <a class="el" href="classts_1_1_section_file.html" title="A binary or XML file containing PSI/SI sections and tables. ">ts::SectionFile</a> is the core of the <em>tstabcomp</em> utility, the tables compiler (or decompiler).</p>
<h3><a class="anchor" id="demux"></a>
Demux and packetization</h3>
<p>Signalization objects can be extracted from transport streams using the class <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">ts::SectionDemux</a> and inserted back into transport streams using the class <a class="el" href="classts_1_1_packetizer.html" title="Packetization of MPEG sections into Transport Stream packets. ">ts::Packetizer</a>. These two classes also have specialized subclasses.</p>
<p>An instance of <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">ts::SectionDemux</a> can extract sections or complete tables in binary form. Tables with long sections are usually cycled. A given table with a given version number and a given "TID extension" is reported only once, after collecting all its sections. The same table will be reported again only when its version number changes.</p>
<p>On the contrary, short tables are all reported since they do not implement versioning.</p>
<p>It is also possible to use a <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">ts::SectionDemux</a> to be notified of all individual sections.</p>
<h2><a class="anchor" id="dvbprotocols"></a>
DVB SimulCrypt protocols</h2>
<p>The communications inside a DVB SimulCrypt head-end is defined by the standard ETSI TS 103 197, "Head-end implementation of DVB SimulCrypt".</p>
<p>Most of these protocols use the same principles. They use binary TLV (Tag/Length/Value) messages, asynchronous communications, concepts of <em>channels</em>, <em>streams</em>, status and error messages.</p>
<p>The generic handling of these messages is implemented by classes in the namespace <a class="el" href="namespacets_1_1tlv.html" title="Namespace for TLV protocols (Tag / Length / Value) ">ts::tlv</a>. All TLV messages inherit from <a class="el" href="classts_1_1tlv_1_1_message.html" title="Abstract base class for TLV messages. ">ts::tlv::Message</a>. channel-level messages inherit from <a class="el" href="classts_1_1tlv_1_1_channel_message.html" title="Base class for DVB SimulCrypt TLV messages operating on channels. ">ts::tlv::ChannelMessage</a> and stream-level messages inherit from <a class="el" href="classts_1_1tlv_1_1_stream_message.html" title="Base class for DVB SimulCrypt TLV messages operating on streams. ">ts::tlv::StreamMessage</a>.</p>
<p>The syntax of a given protocol is defined by subclassing <a class="el" href="classts_1_1tlv_1_1_protocol.html" title="The class ts::tlv::Protocol defines the syntax of a TLV protocol. ">ts::tlv::Protocol</a>.</p>
<p>Currently, the TSDuck library implements the following protocols:</p><ul>
<li>ECMG &lt;=&gt; SCS in namespace <a class="el" href="namespacets_1_1ecmgscs.html" title="Definitions of the DVB SimulCrypt ECMG &lt;=&gt; SCS protocol. ">ts::ecmgscs</a>.</li>
<li>EMMG/PDG &lt;=&gt; MUX in namespace <a class="el" href="namespacets_1_1emmgmux.html" title="Definitions of the DVB SimulCrypt EMMG &lt;=&gt; MUX protocol. ">ts::emmgmux</a>.</li>
</ul>
<h2><a class="anchor" id="cassupport"></a>
Conditional access systems</h2>
<p>The class <a class="el" href="classts_1_1_c_a_s_mapper.html" title="This class maps PID&#39;s with CA system ids. ">ts::CASMapper</a> analyzes the signalization of a transport stream, locates ECM and EMM stream and associates each of them with a <em>CA_System_Id</em>. An instance of <a class="el" href="classts_1_1_c_a_s_mapper.html" title="This class maps PID&#39;s with CA system ids. ">ts::CASMapper</a> can be queried for ECM, EMM streams or CAS vendors.</p>
<h2><a class="anchor" id="otherdemux"></a>
Other forms of demux</h2>
<p>We have already mentioned the classes <a class="el" href="classts_1_1_section_demux.html" title="This class rebuilds MPEG tables and sections from TS packets. ">ts::SectionDemux</a> and <a class="el" href="classts_1_1_p_e_s_demux.html" title="This class extracts PES packets from TS packets. ">ts::PESDemux</a>. Other specialized forms of demux can be implemented. The class <a class="el" href="classts_1_1_t2_m_i_demux.html" title="This class analyzes T2-MI (DVB-T2 Modulator Interface) from TS packets. ">ts::T2MIDemux</a> demuxes T2-MI (DVB-T2 Modulator Interface) packets and extracts encapsulated transport streams. Similarly, the class <a class="el" href="classts_1_1_teletext_demux.html" title="This class extracts Teletext subtitles from TS packets. ">ts::TeletextDemux</a> extracts Teletext subtitles from TS packets.</p>
<p>Since all forms of demux share a number of properties, they all inherit from a root abstract class named <a class="el" href="classts_1_1_abstract_demux.html" title="Abstract base class for all sorts of demux from TS packets. ">ts::AbstractDemux</a>.</p>
<h2><a class="anchor" id="dvbtuners"></a>
DVB tuners</h2>
<p>The class <a class="el" href="classts_1_1_tuner.html" title="Implementation of a DVB tuner. ">ts::Tuner</a> interfaces DVB tuner devices in a portable ways. This is quite a challenge since Linux and Windows use very different DVB frameworks. Some very-specific features are available either only on Linux or Windows.</p>
<p>The abstract class <a class="el" href="classts_1_1_tuner_parameters.html" title="Abstract base class for DVB tuners parameters. ">ts::TunerParameters</a> is the root of a hierarchy of classes containing tuning parameters. Subclasses exist for DVB-S, DVB-T, DVB-C and ATSC. ISDB-S and ISDB-T are currently unsupported.</p>
<p>The class <a class="el" href="classts_1_1_t_s_scanner.html" title="A class which scans the services of a transport stream. ">ts::TSScanner</a> reads a TS from a <a class="el" href="classts_1_1_tuner.html" title="Implementation of a DVB tuner. ">ts::Tuner</a> until all scanning information is found, typically until the PAT, NIT and SDT are received. This is the basis for scanning a DVB network.</p>
<p>Note that DVB tuner devices are supported on Linux and Windows only. On macOS, the above classes are defined but return "unimplemented" errors when used.</p>
<h2><a class="anchor" id="dektecops"></a>
Interface to Dektec devices</h2>
<p>TSDuck can manipulate ASI and modulator boards from Dektec. The TSDuck library includes the DTAPI library, a proprietary C++ interface which is provided by Dektec. The DTAPI is not available in source form and not part of the TSDuck source repository. However, when TSDuck is built, the DTAPI is downloaded in binary from Dektec and included in the TSDuck library. Such a packaging is authorized by the DTAPI license (see the file <em>LICENSE.txt</em> in the TSDuck source repository or installation tree).</p>
<p>An application should not directly call the DTAPI. In practice, this works on Linux but not on Windows. So if you want portability, do not do this. The reason is that the structure of Windows DLL's is such that exported code from a DLL must be compiled using specific attributes. But the DTAPI, as provided by Dektec, was not compiled with these attributes. So, when the DTAPI is included in <em>tsduck.dll</em>, the DTAPI can be called from inside <em>tsduck.dll</em> but is not accessible from the application.</p>
<p>This is why accessing the DTAPI from the application must be done through some TSDuck proxy class. The classes <a class="el" href="classts_1_1_dektec_control.html" title="A class implementing the tsdektec control utility. ">ts::DektecControl</a>, <a class="el" href="classts_1_1_dektec_input_plugin.html" title="Dektec input plugin for tsp. ">ts::DektecInputPlugin</a> and <a class="el" href="classts_1_1_dektec_output_plugin.html" title="Dektec output plugin for tsp. ">ts::DektecOutputPlugin</a> provide the features which are required by the utility <em>tsdektec</em> and the plugin <em>dektec</em> and can be used by third-party applications.</p>
<p>Note that Dektec devices are supported on Linux and Windows only. On macOS, the above classes are defined but return "unimplemented" errors when used. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
