<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSDuck: tsPlatform.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img src="tsduck-32.png"/></td>
   <td id="projectalign"><span id="projectname">TSDuck</span>
    <span id="projectnumber">Version 3.2</span>
    <span id="projectbrief">(TSDuck - The MPEG Transport Stream Toolkit)</span>
   </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ts_platform_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tsPlatform.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cross-platforms portable base definitions for the TSDuck project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html">ts</a></td></tr>
<tr class="memdesc:namespacets"><td class="mdescLeft">&#160;</td><td class="mdescRight">TSDuck namespace, containing all TSDuck classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae0668136398cec91fac1ca87dc32fb9a"><td class="memItemLeft" align="right" valign="top"><a id="ae0668136398cec91fac1ca87dc32fb9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ae0668136398cec91fac1ca87dc32fb9a">__aix</a></td></tr>
<tr class="memdesc:ae0668136398cec91fac1ca87dc32fb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for an IBM AIX target platform. <br /></td></tr>
<tr class="separator:ae0668136398cec91fac1ca87dc32fb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc6525a0d11c8a10c40fb54327b5cce"><td class="memItemLeft" align="right" valign="top"><a id="acbc6525a0d11c8a10c40fb54327b5cce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#acbc6525a0d11c8a10c40fb54327b5cce">__alpha</a></td></tr>
<tr class="memdesc:acbc6525a0d11c8a10c40fb54327b5cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is Digital Alpha architecture. <br /></td></tr>
<tr class="separator:acbc6525a0d11c8a10c40fb54327b5cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf819e1a22d77b80dcc979bd26d5d53"><td class="memItemLeft" align="right" valign="top"><a id="a3bf819e1a22d77b80dcc979bd26d5d53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a3bf819e1a22d77b80dcc979bd26d5d53">__arm</a></td></tr>
<tr class="memdesc:a3bf819e1a22d77b80dcc979bd26d5d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is ARM. <br /></td></tr>
<tr class="separator:a3bf819e1a22d77b80dcc979bd26d5d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e1bfb8a6aeba6fdd0dc0e6e09a95f"><td class="memItemLeft" align="right" valign="top"><a id="ae41e1bfb8a6aeba6fdd0dc0e6e09a95f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ae41e1bfb8a6aeba6fdd0dc0e6e09a95f">__big_endian</a></td></tr>
<tr class="memdesc:ae41e1bfb8a6aeba6fdd0dc0e6e09a95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a big-endian or MSB-first target platform. <br /></td></tr>
<tr class="separator:ae41e1bfb8a6aeba6fdd0dc0e6e09a95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8747a48a87b4a7ebd6ee913bf278838"><td class="memItemLeft" align="right" valign="top"><a id="ab8747a48a87b4a7ebd6ee913bf278838"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ab8747a48a87b4a7ebd6ee913bf278838">__cygwin</a></td></tr>
<tr class="memdesc:ab8747a48a87b4a7ebd6ee913bf278838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a Cygwin target platform. <br /></td></tr>
<tr class="separator:ab8747a48a87b4a7ebd6ee913bf278838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaac508cee6f534643968e2b6cee17c"><td class="memItemLeft" align="right" valign="top"><a id="addaac508cee6f534643968e2b6cee17c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#addaac508cee6f534643968e2b6cee17c">__gcc</a></td></tr>
<tr class="memdesc:addaac508cee6f534643968e2b6cee17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the compiler is GCC, also known as "GNU C". <br /></td></tr>
<tr class="separator:addaac508cee6f534643968e2b6cee17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c94af7fb8637b1b7ea09bf081ac8bc"><td class="memItemLeft" align="right" valign="top"><a id="a47c94af7fb8637b1b7ea09bf081ac8bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a47c94af7fb8637b1b7ea09bf081ac8bc">__i386</a></td></tr>
<tr class="memdesc:a47c94af7fb8637b1b7ea09bf081ac8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is Intel IA-32, also known as x86. <br /></td></tr>
<tr class="separator:a47c94af7fb8637b1b7ea09bf081ac8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a4e3485179245bc1fe5ef7a1904bfc"><td class="memItemLeft" align="right" valign="top"><a id="ad9a4e3485179245bc1fe5ef7a1904bfc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ad9a4e3485179245bc1fe5ef7a1904bfc">__ia64</a></td></tr>
<tr class="memdesc:ad9a4e3485179245bc1fe5ef7a1904bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is Intel IA-64 architecture, also known as Itanium. <br /></td></tr>
<tr class="separator:ad9a4e3485179245bc1fe5ef7a1904bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6342c53a7213211680dc5caae14491"><td class="memItemLeft" align="right" valign="top"><a id="a6c6342c53a7213211680dc5caae14491"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a6c6342c53a7213211680dc5caae14491">__linux</a></td></tr>
<tr class="memdesc:a6c6342c53a7213211680dc5caae14491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a Linux target platform. <br /></td></tr>
<tr class="separator:a6c6342c53a7213211680dc5caae14491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ddc4d88d0ecde53e8fc0ddfaa713a7"><td class="memItemLeft" align="right" valign="top"><a id="ad6ddc4d88d0ecde53e8fc0ddfaa713a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ad6ddc4d88d0ecde53e8fc0ddfaa713a7">__little_endian</a></td></tr>
<tr class="memdesc:ad6ddc4d88d0ecde53e8fc0ddfaa713a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a little-endian or LSB-first target platform. <br /></td></tr>
<tr class="separator:ad6ddc4d88d0ecde53e8fc0ddfaa713a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2bd295cc1e1e97dbf806ba0c42515e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a0d2bd295cc1e1e97dbf806ba0c42515e">__llvm</a></td></tr>
<tr class="memdesc:a0d2bd295cc1e1e97dbf806ba0c42515e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the compiler is LLVM (clang).  <a href="#a0d2bd295cc1e1e97dbf806ba0c42515e">More...</a><br /></td></tr>
<tr class="separator:a0d2bd295cc1e1e97dbf806ba0c42515e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fff5f5fcc538f5ea3af33ecbc434cd"><td class="memItemLeft" align="right" valign="top"><a id="a33fff5f5fcc538f5ea3af33ecbc434cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a33fff5f5fcc538f5ea3af33ecbc434cd">__mac</a></td></tr>
<tr class="memdesc:a33fff5f5fcc538f5ea3af33ecbc434cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a MacOS target platform. <br /></td></tr>
<tr class="separator:a33fff5f5fcc538f5ea3af33ecbc434cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f7e8bf8ffb2c0575e58571680bda82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ad9f7e8bf8ffb2c0575e58571680bda82">__msc</a></td></tr>
<tr class="memdesc:ad9f7e8bf8ffb2c0575e58571680bda82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the compiler is Microsoft C/C++, the default compiler in the Microsoft Visual Studio environment.  <a href="#ad9f7e8bf8ffb2c0575e58571680bda82">More...</a><br /></td></tr>
<tr class="separator:ad9f7e8bf8ffb2c0575e58571680bda82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91a22e783f7e55e3c97525f5ed65dd"><td class="memItemLeft" align="right" valign="top"><a id="abd91a22e783f7e55e3c97525f5ed65dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#abd91a22e783f7e55e3c97525f5ed65dd">__powerpc</a></td></tr>
<tr class="memdesc:abd91a22e783f7e55e3c97525f5ed65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is 32-bit Power PC. <br /></td></tr>
<tr class="separator:abd91a22e783f7e55e3c97525f5ed65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13888afd30cfa7888fa256449f198057"><td class="memItemLeft" align="right" valign="top"><a id="a13888afd30cfa7888fa256449f198057"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a13888afd30cfa7888fa256449f198057">__powerpc64</a></td></tr>
<tr class="memdesc:a13888afd30cfa7888fa256449f198057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is 64-bit Power PC. <br /></td></tr>
<tr class="separator:a13888afd30cfa7888fa256449f198057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56071e0484561d70fc72613ddfd286f"><td class="memItemLeft" align="right" valign="top"><a id="ab56071e0484561d70fc72613ddfd286f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ab56071e0484561d70fc72613ddfd286f">__solaris</a></td></tr>
<tr class="memdesc:ab56071e0484561d70fc72613ddfd286f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a Sun Solaris target platform. <br /></td></tr>
<tr class="separator:ab56071e0484561d70fc72613ddfd286f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6f1a5d9433e82f11aee23d02832d4f"><td class="memItemLeft" align="right" valign="top"><a id="a8b6f1a5d9433e82f11aee23d02832d4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a8b6f1a5d9433e82f11aee23d02832d4f">__sparc</a></td></tr>
<tr class="memdesc:a8b6f1a5d9433e82f11aee23d02832d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is Sun SPARC architecture. <br /></td></tr>
<tr class="separator:a8b6f1a5d9433e82f11aee23d02832d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa346d1a3e7fde5d8c0d63dd7a8d619ac"><td class="memItemLeft" align="right" valign="top"><a id="aa346d1a3e7fde5d8c0d63dd7a8d619ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#aa346d1a3e7fde5d8c0d63dd7a8d619ac">__stxp70</a></td></tr>
<tr class="memdesc:aa346d1a3e7fde5d8c0d63dd7a8d619ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is STxP70. <br /></td></tr>
<tr class="separator:aa346d1a3e7fde5d8c0d63dd7a8d619ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cd8b035cfb8a68f6d1119ace36f1cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ac3cd8b035cfb8a68f6d1119ace36f1cc">__unix</a></td></tr>
<tr class="memdesc:ac3cd8b035cfb8a68f6d1119ace36f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for any flavor of UNIX target platforms.  <a href="#ac3cd8b035cfb8a68f6d1119ace36f1cc">More...</a><br /></td></tr>
<tr class="separator:ac3cd8b035cfb8a68f6d1119ace36f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea774d39288ab9e84383613da2afb6d"><td class="memItemLeft" align="right" valign="top"><a id="a1ea774d39288ab9e84383613da2afb6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a1ea774d39288ab9e84383613da2afb6d">__windows</a></td></tr>
<tr class="memdesc:a1ea774d39288ab9e84383613da2afb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when compiled for a Microsoft Windows target platform. <br /></td></tr>
<tr class="separator:a1ea774d39288ab9e84383613da2afb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b6ba77bbc2cb5db2a19f32e954fcc3"><td class="memItemLeft" align="right" valign="top"><a id="a64b6ba77bbc2cb5db2a19f32e954fcc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a64b6ba77bbc2cb5db2a19f32e954fcc3">__x86_64</a></td></tr>
<tr class="memdesc:a64b6ba77bbc2cb5db2a19f32e954fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when the target processor architecture is the 64-bit extension of the IA-32 architecture, also known as AMD-64 or Intel x86-64. <br /></td></tr>
<tr class="separator:a64b6ba77bbc2cb5db2a19f32e954fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad88cf9252037fc1b4e5cfbec0f02b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#aad88cf9252037fc1b4e5cfbec0f02b75">FMT_INT64</a>&#160;&#160;&#160;&quot;platform-specific&quot;</td></tr>
<tr class="memdesc:aad88cf9252037fc1b4e5cfbec0f02b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string value to specify a 64-bit integer argument in <code>printf</code> <em>format</em> strings.  <a href="#aad88cf9252037fc1b4e5cfbec0f02b75">More...</a><br /></td></tr>
<tr class="separator:aad88cf9252037fc1b4e5cfbec0f02b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ad63eb5d0c912c5910090ba05967d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a69ad63eb5d0c912c5910090ba05967d8">FMT_SIZE_T</a>&#160;&#160;&#160;&quot;platform-specific&quot;</td></tr>
<tr class="memdesc:a69ad63eb5d0c912c5910090ba05967d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string value to specify a <code>size_t</code> argument in <code>printf</code> <em>format</em> strings.  <a href="#a69ad63eb5d0c912c5910090ba05967d8">More...</a><br /></td></tr>
<tr class="separator:a69ad63eb5d0c912c5910090ba05967d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbedf570df77410fe4dc09385caf2216"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#acbedf570df77410fe4dc09385caf2216">TS_CONST64</a>(n)</td></tr>
<tr class="memdesc:acbedf570df77410fe4dc09385caf2216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable definition of a 64-bit signed literal.  <a href="#acbedf570df77410fe4dc09385caf2216">More...</a><br /></td></tr>
<tr class="separator:acbedf570df77410fe4dc09385caf2216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a070d3a641d0ac411cbb5e8db40b34"><td class="memItemLeft" align="right" valign="top"><a id="a77a070d3a641d0ac411cbb5e8db40b34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a77a070d3a641d0ac411cbb5e8db40b34">TS_DLL_EXPORT</a></td></tr>
<tr class="memdesc:a77a070d3a641d0ac411cbb5e8db40b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Windows, this attribute exports a symbol out of a DLL. <br /></td></tr>
<tr class="separator:a77a070d3a641d0ac411cbb5e8db40b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5271a0d21edb2a1886ed53173ba48e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ae5271a0d21edb2a1886ed53173ba48e8">TS_DVB_API_VERSION</a></td></tr>
<tr class="memdesc:ae5271a0d21edb2a1886ed53173ba48e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Linux systems, identify the Linux DVB API version in one value.  <a href="#ae5271a0d21edb2a1886ed53173ba48e8">More...</a><br /></td></tr>
<tr class="separator:ae5271a0d21edb2a1886ed53173ba48e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc375210e050482fdac6d6f60417a97f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#afc375210e050482fdac6d6f60417a97f">TS_FORMAT_STRING</a>(string_var,  format_arg)</td></tr>
<tr class="memdesc:afc375210e050482fdac6d6f60417a97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used in functions with a variable list of arguments to format a <code>std::string</code> from a printf-like format and its variable-length list of arguments.  <a href="#afc375210e050482fdac6d6f60417a97f">More...</a><br /></td></tr>
<tr class="separator:afc375210e050482fdac6d6f60417a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77031276ee5ec897860802390f028b7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a77031276ee5ec897860802390f028b7d">TS_FUNCTION</a></td></tr>
<tr class="memdesc:a77031276ee5ec897860802390f028b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the name of the current function.  <a href="#a77031276ee5ec897860802390f028b7d">More...</a><br /></td></tr>
<tr class="separator:a77031276ee5ec897860802390f028b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133bb38cbcd7785865b94b3bbbb8da4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a133bb38cbcd7785865b94b3bbbb8da4d">TS_GCC_VERSION</a></td></tr>
<tr class="memdesc:a133bb38cbcd7785865b94b3bbbb8da4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GCC version, encoded as an integer.  <a href="#a133bb38cbcd7785865b94b3bbbb8da4d">More...</a><br /></td></tr>
<tr class="separator:a133bb38cbcd7785865b94b3bbbb8da4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f5dfb0a0f2879ad295da2225e8a9f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#aa5f5dfb0a0f2879ad295da2225e8a9f9">TS_NEED_STATIC_CONST_DEFINITIONS</a></td></tr>
<tr class="memdesc:aa5f5dfb0a0f2879ad295da2225e8a9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation of definitions of C++ constants.  <a href="#aa5f5dfb0a0f2879ad295da2225e8a9f9">More...</a><br /></td></tr>
<tr class="separator:aa5f5dfb0a0f2879ad295da2225e8a9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed38bcf0ad48a35087967d279e15a0dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#aed38bcf0ad48a35087967d279e15a0dc">TS_NO_MEMORY_BARRIER</a></td></tr>
<tr class="memdesc:aed38bcf0ad48a35087967d279e15a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be defined to implement memory barrier as a no-operation.  <a href="#aed38bcf0ad48a35087967d279e15a0dc">More...</a><br /></td></tr>
<tr class="separator:aed38bcf0ad48a35087967d279e15a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923af0deea083081c539bed4e798ab67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a923af0deea083081c539bed4e798ab67">TS_NULL</a>&#160;&#160;&#160;(static_cast&lt;void*&gt;(0))</td></tr>
<tr class="memdesc:a923af0deea083081c539bed4e798ab67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a NULL pointer for C++.  <a href="#a923af0deea083081c539bed4e798ab67">More...</a><br /></td></tr>
<tr class="separator:a923af0deea083081c539bed4e798ab67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb17342788b99c194860e5b6707a82fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#abb17342788b99c194860e5b6707a82fa">TS_NULL_CHAR_PTR</a>&#160;&#160;&#160;(static_cast&lt;char*&gt;(0))</td></tr>
<tr class="memdesc:abb17342788b99c194860e5b6707a82fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a NULL pointer for C++ with an explicit char pointer.  <a href="#abb17342788b99c194860e5b6707a82fa">More...</a><br /></td></tr>
<tr class="separator:abb17342788b99c194860e5b6707a82fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c573be2d797a2b160e7417cce03980"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ac9c573be2d797a2b160e7417cce03980">TS_PRINTF_FORMAT</a>(formatIndex,  argIndex)</td></tr>
<tr class="memdesc:ac9c573be2d797a2b160e7417cce03980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax-checking attribute for functions with a printf-like format.  <a href="#ac9c573be2d797a2b160e7417cce03980">More...</a><br /></td></tr>
<tr class="separator:ac9c573be2d797a2b160e7417cce03980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab951cd7449abfd3aeed8a621301630"><td class="memItemLeft" align="right" valign="top"><a id="aeab951cd7449abfd3aeed8a621301630"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#aeab951cd7449abfd3aeed8a621301630">TS_SLINE</a>&#160;&#160;&#160;<a class="el" href="ts_platform_8h.html#a81ffc1445d4ad494ed54a5ab1e446073">TS_STRINGIFY</a>(__LINE__)</td></tr>
<tr class="memdesc:aeab951cd7449abfd3aeed8a621301630"><td class="mdescLeft">&#160;</td><td class="mdescRight">String version of <b>LINE</b> <br /></td></tr>
<tr class="separator:aeab951cd7449abfd3aeed8a621301630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ffc1445d4ad494ed54a5ab1e446073"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a81ffc1445d4ad494ed54a5ab1e446073">TS_STRINGIFY</a>(x)</td></tr>
<tr class="memdesc:a81ffc1445d4ad494ed54a5ab1e446073"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro transforms the <em>value</em> of a macro parameter into the equivalent string.  <a href="#a81ffc1445d4ad494ed54a5ab1e446073">More...</a><br /></td></tr>
<tr class="separator:a81ffc1445d4ad494ed54a5ab1e446073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c83fdc23352d2e7835cb9f691542e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a28c83fdc23352d2e7835cb9f691542e5">TS_UCONST64</a>(n)</td></tr>
<tr class="memdesc:a28c83fdc23352d2e7835cb9f691542e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable definition of a 64-bit unsigned literal.  <a href="#a28c83fdc23352d2e7835cb9f691542e5">More...</a><br /></td></tr>
<tr class="separator:a28c83fdc23352d2e7835cb9f691542e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e23355947fbaf69c05494a70eec929"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a93e23355947fbaf69c05494a70eec929">TS_UNUSED</a>&#160;&#160;&#160;platform_specific</td></tr>
<tr class="memdesc:a93e23355947fbaf69c05494a70eec929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute for explicitly unused variables.  <a href="#a93e23355947fbaf69c05494a70eec929">More...</a><br /></td></tr>
<tr class="separator:a93e23355947fbaf69c05494a70eec929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c8aa689b1d1828c9e6d307084e9b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#a018c8aa689b1d1828c9e6d307084e9b8">TSDUCK_SOURCE</a></td></tr>
<tr class="memdesc:a018c8aa689b1d1828c9e6d307084e9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro inserts a build mark in the source code, identifying it as part or TSDuck.  <a href="#a018c8aa689b1d1828c9e6d307084e9b8">More...</a><br /></td></tr>
<tr class="separator:a018c8aa689b1d1828c9e6d307084e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cda62454d23e62fb576be3783aec47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ts_platform_8h.html#ae1cda62454d23e62fb576be3783aec47">TSDUCKDLL</a></td></tr>
<tr class="memdesc:ae1cda62454d23e62fb576be3783aec47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute to declare a class or function from tsduck.dll on Windows.  <a href="#ae1cda62454d23e62fb576be3783aec47">More...</a><br /></td></tr>
<tr class="separator:ae1cda62454d23e62fb576be3783aec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="memItemLeft" align="right" valign="top"><a id="a1c5cb8c11b9201fea00bbc07569b1bc4"></a>
typedef platform_specific&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ts::ErrorCode</a></td></tr>
<tr class="memdesc:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type for operating system error codes. <br /></td></tr>
<tr class="separator:a1c5cb8c11b9201fea00bbc07569b1bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996c4337196115e063c7b91bf79510e"><td class="memItemLeft" align="right" valign="top">typedef SubSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae996c4337196115e063c7b91bf79510e">ts::MicroSecond</a></td></tr>
<tr class="memdesc:ae996c4337196115e063c7b91bf79510e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of microseconds.  <a href="namespacets.html#ae996c4337196115e063c7b91bf79510e">More...</a><br /></td></tr>
<tr class="separator:ae996c4337196115e063c7b91bf79510e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="memItemLeft" align="right" valign="top">typedef SubSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">ts::MilliSecond</a></td></tr>
<tr class="memdesc:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of milliseconds.  <a href="namespacets.html#a2c690abc5d90fe5ba7c3ec0237afc348">More...</a><br /></td></tr>
<tr class="separator:a2c690abc5d90fe5ba7c3ec0237afc348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd890ba84c12ced734201afae32a3e95"><td class="memItemLeft" align="right" valign="top">typedef SubSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acd890ba84c12ced734201afae32a3e95">ts::NanoSecond</a></td></tr>
<tr class="memdesc:acd890ba84c12ced734201afae32a3e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of nanoseconds.  <a href="namespacets.html#acd890ba84c12ced734201afae32a3e95">More...</a><br /></td></tr>
<tr class="separator:acd890ba84c12ced734201afae32a3e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38592708fbf21dafd004afa1136586c7"><td class="memItemLeft" align="right" valign="top">typedef SubSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a38592708fbf21dafd004afa1136586c7">ts::Second</a></td></tr>
<tr class="memdesc:a38592708fbf21dafd004afa1136586c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent a number of seconds.  <a href="namespacets.html#a38592708fbf21dafd004afa1136586c7">More...</a><br /></td></tr>
<tr class="separator:a38592708fbf21dafd004afa1136586c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">ts::SubSecond</a></td></tr>
<tr class="memdesc:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer type is used to represent any sub-quantity of seconds.  <a href="namespacets.html#ab310e3cadb18cb3e6e7d1e7bb403d4d8">More...</a><br /></td></tr>
<tr class="separator:ab310e3cadb18cb3e6e7d1e7bb403d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2d3fc0fa119551548f2550c83ca68e47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47">ts::CopyShare</a> { <br />
&#160;&#160;<a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47a5083b3f9b5f22506be23ec56cc217b7a">ts::COPY</a>, 
<br />
&#160;&#160;<a class="el" href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47a278c7050331579ffce6ee95b6157f5f9">ts::SHARE</a>
<br />
 }<tr class="memdesc:a2d3fc0fa119551548f2550c83ca68e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration type used to indicate if the data referenced by a pointer shall be copied or shared.  <a href="namespacets.html#a2d3fc0fa119551548f2550c83ca68e47">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2d3fc0fa119551548f2550c83ca68e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62efc57362e856920b2008d838583ea8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a62efc57362e856920b2008d838583ea8">ts::ByteSwap16</a> (uint16_t x)</td></tr>
<tr class="memdesc:a62efc57362e856920b2008d838583ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 16-bit integer data.  <a href="namespacets.html#a62efc57362e856920b2008d838583ea8">More...</a><br /></td></tr>
<tr class="separator:a62efc57362e856920b2008d838583ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9b4e88f0624d9fc9fb36d2b8dea9d99c">ts::ByteSwap24</a> (uint32_t x)</td></tr>
<tr class="memdesc:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 24-bit integer data.  <a href="namespacets.html#a9b4e88f0624d9fc9fb36d2b8dea9d99c">More...</a><br /></td></tr>
<tr class="separator:a9b4e88f0624d9fc9fb36d2b8dea9d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1516fddd435f2bd54085b3674ff6fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8c1516fddd435f2bd54085b3674ff6fd">ts::ByteSwap32</a> (uint32_t x)</td></tr>
<tr class="memdesc:a8c1516fddd435f2bd54085b3674ff6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 32-bit integer data.  <a href="namespacets.html#a8c1516fddd435f2bd54085b3674ff6fd">More...</a><br /></td></tr>
<tr class="separator:a8c1516fddd435f2bd54085b3674ff6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae133add30b41089dacbb1ffa4fc42656"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae133add30b41089dacbb1ffa4fc42656">ts::ByteSwap64</a> (uint64_t x)</td></tr>
<tr class="memdesc:ae133add30b41089dacbb1ffa4fc42656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing byte swap on 64-bit integer data.  <a href="namespacets.html#ae133add30b41089dacbb1ffa4fc42656">More...</a><br /></td></tr>
<tr class="separator:ae133add30b41089dacbb1ffa4fc42656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103d4008075d1c45ec21011f0c5b58df"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a103d4008075d1c45ec21011f0c5b58df"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a103d4008075d1c45ec21011f0c5b58df">ts::CondByteSwap</a> (INT x)</td></tr>
<tr class="memdesc:a103d4008075d1c45ec21011f0c5b58df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in big endian representation.  <a href="namespacets.html#a103d4008075d1c45ec21011f0c5b58df">More...</a><br /></td></tr>
<tr class="separator:a103d4008075d1c45ec21011f0c5b58df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9cec3aee4ec20d0fea7c12d0d0e8347e">ts::CondByteSwap16</a> (uint16_t x)</td></tr>
<tr class="memdesc:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a9cec3aee4ec20d0fea7c12d0d0e8347e">More...</a><br /></td></tr>
<tr class="separator:a9cec3aee4ec20d0fea7c12d0d0e8347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8b72cb6e05cd166c8346ee6bbbb6b4d8">ts::CondByteSwap16BE</a> (uint16_t x)</td></tr>
<tr class="memdesc:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a8b72cb6e05cd166c8346ee6bbbb6b4d8">More...</a><br /></td></tr>
<tr class="separator:a8b72cb6e05cd166c8346ee6bbbb6b4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baec140b94d96b53eed46b5461081e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3baec140b94d96b53eed46b5461081e0">ts::CondByteSwap16LE</a> (uint16_t x)</td></tr>
<tr class="memdesc:a3baec140b94d96b53eed46b5461081e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 16-bit integer data to obtain the data in little endian representation.  <a href="namespacets.html#a3baec140b94d96b53eed46b5461081e0">More...</a><br /></td></tr>
<tr class="separator:a3baec140b94d96b53eed46b5461081e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b2fbe7a2ee13195f725e96d51310cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a98b2fbe7a2ee13195f725e96d51310cb">ts::CondByteSwap24</a> (uint32_t x)</td></tr>
<tr class="memdesc:a98b2fbe7a2ee13195f725e96d51310cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a98b2fbe7a2ee13195f725e96d51310cb">More...</a><br /></td></tr>
<tr class="separator:a98b2fbe7a2ee13195f725e96d51310cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1daad980866e973aa0bcdd3991d47f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5b1daad980866e973aa0bcdd3991d47f">ts::CondByteSwap24BE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a5b1daad980866e973aa0bcdd3991d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a5b1daad980866e973aa0bcdd3991d47f">More...</a><br /></td></tr>
<tr class="separator:a5b1daad980866e973aa0bcdd3991d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d035c03d139c7ca220cbb318089ab7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a55d035c03d139c7ca220cbb318089ab7">ts::CondByteSwap24LE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a55d035c03d139c7ca220cbb318089ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 24-bit integer data to obtain the data in little endian representation.  <a href="namespacets.html#a55d035c03d139c7ca220cbb318089ab7">More...</a><br /></td></tr>
<tr class="separator:a55d035c03d139c7ca220cbb318089ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf35fc29b505b8b31ae5f331e4e9979"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acaf35fc29b505b8b31ae5f331e4e9979">ts::CondByteSwap32</a> (uint32_t x)</td></tr>
<tr class="memdesc:acaf35fc29b505b8b31ae5f331e4e9979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#acaf35fc29b505b8b31ae5f331e4e9979">More...</a><br /></td></tr>
<tr class="separator:acaf35fc29b505b8b31ae5f331e4e9979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7d797ee241bdfa65935663268a8cf4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc7d797ee241bdfa65935663268a8cf4">ts::CondByteSwap32BE</a> (uint32_t x)</td></tr>
<tr class="memdesc:afc7d797ee241bdfa65935663268a8cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#afc7d797ee241bdfa65935663268a8cf4">More...</a><br /></td></tr>
<tr class="separator:afc7d797ee241bdfa65935663268a8cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d8873bb0120e283796079cdf3f5f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2d3d8873bb0120e283796079cdf3f5f9">ts::CondByteSwap32LE</a> (uint32_t x)</td></tr>
<tr class="memdesc:a2d3d8873bb0120e283796079cdf3f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 32-bit integer data to obtain the data in little endian representation.  <a href="namespacets.html#a2d3d8873bb0120e283796079cdf3f5f9">More...</a><br /></td></tr>
<tr class="separator:a2d3d8873bb0120e283796079cdf3f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c20d76fd476e16a318b1b8445b40c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b6c20d76fd476e16a318b1b8445b40c">ts::CondByteSwap64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3b6c20d76fd476e16a318b1b8445b40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a3b6c20d76fd476e16a318b1b8445b40c">More...</a><br /></td></tr>
<tr class="separator:a3b6c20d76fd476e16a318b1b8445b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4a858ba042ba9ff717978fee34209a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3d4a858ba042ba9ff717978fee34209a">ts::CondByteSwap64BE</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3d4a858ba042ba9ff717978fee34209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in big endian representation.  <a href="namespacets.html#a3d4a858ba042ba9ff717978fee34209a">More...</a><br /></td></tr>
<tr class="separator:a3d4a858ba042ba9ff717978fee34209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3ffa36c67fd7339fc5e0924c9f6b688e">ts::CondByteSwap64LE</a> (uint64_t x)</td></tr>
<tr class="memdesc:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing conditional byte swap on 64-bit integer data to obtain the data in little endian representation.  <a href="namespacets.html#a3ffa36c67fd7339fc5e0924c9f6b688e">More...</a><br /></td></tr>
<tr class="separator:a3ffa36c67fd7339fc5e0924c9f6b688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73790a97bab5af98d70d61ac940e812"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa73790a97bab5af98d70d61ac940e812"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa73790a97bab5af98d70d61ac940e812">ts::CondByteSwapBE</a> (INT x)</td></tr>
<tr class="memdesc:aa73790a97bab5af98d70d61ac940e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in big endian representation.  <a href="namespacets.html#aa73790a97bab5af98d70d61ac940e812">More...</a><br /></td></tr>
<tr class="separator:aa73790a97bab5af98d70d61ac940e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5727edb9849beae3829fb323b15585d6"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a5727edb9849beae3829fb323b15585d6"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a5727edb9849beae3829fb323b15585d6">ts::CondByteSwapLE</a> (INT x)</td></tr>
<tr class="memdesc:a5727edb9849beae3829fb323b15585d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function performing conditional byte swap on integer data to obtain the data in little endian representation.  <a href="namespacets.html#a5727edb9849beae3829fb323b15585d6">More...</a><br /></td></tr>
<tr class="separator:a5727edb9849beae3829fb323b15585d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17265d933a9beb229d001b26bbf021af"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a17265d933a9beb229d001b26bbf021af"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#a17265d933a9beb229d001b26bbf021af">ts::GetInt</a> (const void *p)</td></tr>
<tr class="memdesc:a17265d933a9beb229d001b26bbf021af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="namespacets.html#a17265d933a9beb229d001b26bbf021af">More...</a><br /></td></tr>
<tr class="separator:a17265d933a9beb229d001b26bbf021af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#afcc9d2fb4021b00dac5c7aa0cae59c6e">ts::GetInt</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="namespacets.html#afcc9d2fb4021b00dac5c7aa0cae59c6e">More...</a><br /></td></tr>
<tr class="separator:afcc9d2fb4021b00dac5c7aa0cae59c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b32ec99a2e227a7742865f27974b67"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae4b32ec99a2e227a7742865f27974b67">ts::GetInt16</a> (const void *p)</td></tr>
<tr class="memdesc:ae4b32ec99a2e227a7742865f27974b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#ae4b32ec99a2e227a7742865f27974b67">More...</a><br /></td></tr>
<tr class="separator:ae4b32ec99a2e227a7742865f27974b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabce47934b112b06aa1d0e034c0ab851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aabce47934b112b06aa1d0e034c0ab851">ts::GetInt16</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:aabce47934b112b06aa1d0e034c0ab851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#aabce47934b112b06aa1d0e034c0ab851">More...</a><br /></td></tr>
<tr class="separator:aabce47934b112b06aa1d0e034c0ab851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6e0c99c5cd7dff8ec394e5515eae6357">ts::GetInt16BE</a> (const void *p)</td></tr>
<tr class="memdesc:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a6e0c99c5cd7dff8ec394e5515eae6357">More...</a><br /></td></tr>
<tr class="separator:a6e0c99c5cd7dff8ec394e5515eae6357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d6bbd751c624abd11d5871edbb4f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a00d6bbd751c624abd11d5871edbb4f83">ts::GetInt16BE</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:a00d6bbd751c624abd11d5871edbb4f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a00d6bbd751c624abd11d5871edbb4f83">More...</a><br /></td></tr>
<tr class="separator:a00d6bbd751c624abd11d5871edbb4f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb588d1a13c75a5d5422ce40004b9c22"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abb588d1a13c75a5d5422ce40004b9c22">ts::GetInt16LE</a> (const void *p)</td></tr>
<tr class="memdesc:abb588d1a13c75a5d5422ce40004b9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#abb588d1a13c75a5d5422ce40004b9c22">More...</a><br /></td></tr>
<tr class="separator:abb588d1a13c75a5d5422ce40004b9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921a2b83853ab95d3a8071f9568f655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9921a2b83853ab95d3a8071f9568f655">ts::GetInt16LE</a> (const void *p, int16_t &amp;i)</td></tr>
<tr class="memdesc:a9921a2b83853ab95d3a8071f9568f655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#a9921a2b83853ab95d3a8071f9568f655">More...</a><br /></td></tr>
<tr class="separator:a9921a2b83853ab95d3a8071f9568f655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c27f13544400a9832dd9fe12425c2e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa6c27f13544400a9832dd9fe12425c2e">ts::GetInt24</a> (const void *p)</td></tr>
<tr class="memdesc:aa6c27f13544400a9832dd9fe12425c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#aa6c27f13544400a9832dd9fe12425c2e">More...</a><br /></td></tr>
<tr class="separator:aa6c27f13544400a9832dd9fe12425c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a88d4ec1b3fbdd3ff2d19f2c38b79499b">ts::GetInt24</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a88d4ec1b3fbdd3ff2d19f2c38b79499b">More...</a><br /></td></tr>
<tr class="separator:a88d4ec1b3fbdd3ff2d19f2c38b79499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea6588c8736c18a436c561227d007ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6ea6588c8736c18a436c561227d007ba">ts::GetInt24BE</a> (const void *p)</td></tr>
<tr class="memdesc:a6ea6588c8736c18a436c561227d007ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a6ea6588c8736c18a436c561227d007ba">More...</a><br /></td></tr>
<tr class="separator:a6ea6588c8736c18a436c561227d007ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74b54d502f2d4904300533e43d11a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afe74b54d502f2d4904300533e43d11a3">ts::GetInt24BE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:afe74b54d502f2d4904300533e43d11a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#afe74b54d502f2d4904300533e43d11a3">More...</a><br /></td></tr>
<tr class="separator:afe74b54d502f2d4904300533e43d11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a831c7bf60e2ae215cd33eb90f4ad644c">ts::GetInt24LE</a> (const void *p)</td></tr>
<tr class="memdesc:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#a831c7bf60e2ae215cd33eb90f4ad644c">More...</a><br /></td></tr>
<tr class="separator:a831c7bf60e2ae215cd33eb90f4ad644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271258a9dfdd04ccd315680f743e484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0271258a9dfdd04ccd315680f743e484">ts::GetInt24LE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a0271258a9dfdd04ccd315680f743e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#a0271258a9dfdd04ccd315680f743e484">More...</a><br /></td></tr>
<tr class="separator:a0271258a9dfdd04ccd315680f743e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b85f9ebc717a54509a44eb340b1352d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0b85f9ebc717a54509a44eb340b1352d">ts::GetInt32</a> (const void *p)</td></tr>
<tr class="memdesc:a0b85f9ebc717a54509a44eb340b1352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a0b85f9ebc717a54509a44eb340b1352d">More...</a><br /></td></tr>
<tr class="separator:a0b85f9ebc717a54509a44eb340b1352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2700410ea296c21f2bcddd7186e84c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad2700410ea296c21f2bcddd7186e84c4">ts::GetInt32</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:ad2700410ea296c21f2bcddd7186e84c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#ad2700410ea296c21f2bcddd7186e84c4">More...</a><br /></td></tr>
<tr class="separator:ad2700410ea296c21f2bcddd7186e84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9c67eafbbf4f7b06b2cba52a54359ab3">ts::GetInt32BE</a> (const void *p)</td></tr>
<tr class="memdesc:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a9c67eafbbf4f7b06b2cba52a54359ab3">More...</a><br /></td></tr>
<tr class="separator:a9c67eafbbf4f7b06b2cba52a54359ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a081c684a9d7f24ea32c62d021d2cf6a3">ts::GetInt32BE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a081c684a9d7f24ea32c62d021d2cf6a3">More...</a><br /></td></tr>
<tr class="separator:a081c684a9d7f24ea32c62d021d2cf6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa4e42b691d1b61264a6ac1ddc820eaa7">ts::GetInt32LE</a> (const void *p)</td></tr>
<tr class="memdesc:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#aa4e42b691d1b61264a6ac1ddc820eaa7">More...</a><br /></td></tr>
<tr class="separator:aa4e42b691d1b61264a6ac1ddc820eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbbe3883b9e2c35587a405593405876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8cbbe3883b9e2c35587a405593405876">ts::GetInt32LE</a> (const void *p, int32_t &amp;i)</td></tr>
<tr class="memdesc:a8cbbe3883b9e2c35587a405593405876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#a8cbbe3883b9e2c35587a405593405876">More...</a><br /></td></tr>
<tr class="separator:a8cbbe3883b9e2c35587a405593405876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56224321d92070fb07832659c23d553d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a56224321d92070fb07832659c23d553d">ts::GetInt64</a> (const void *p)</td></tr>
<tr class="memdesc:a56224321d92070fb07832659c23d553d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a56224321d92070fb07832659c23d553d">More...</a><br /></td></tr>
<tr class="separator:a56224321d92070fb07832659c23d553d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afc81f51b1795f2dae40bbb2eecb2f2e7">ts::GetInt64</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#afc81f51b1795f2dae40bbb2eecb2f2e7">More...</a><br /></td></tr>
<tr class="separator:afc81f51b1795f2dae40bbb2eecb2f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee51ebfe80183472394a82a099b050a9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aee51ebfe80183472394a82a099b050a9">ts::GetInt64BE</a> (const void *p)</td></tr>
<tr class="memdesc:aee51ebfe80183472394a82a099b050a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#aee51ebfe80183472394a82a099b050a9">More...</a><br /></td></tr>
<tr class="separator:aee51ebfe80183472394a82a099b050a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf0acc4d3952cf73398cb86dfedf935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4bf0acc4d3952cf73398cb86dfedf935">ts::GetInt64BE</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:a4bf0acc4d3952cf73398cb86dfedf935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in big endian representation.  <a href="namespacets.html#a4bf0acc4d3952cf73398cb86dfedf935">More...</a><br /></td></tr>
<tr class="separator:a4bf0acc4d3952cf73398cb86dfedf935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa827b7a0b2e9a76136cbffe4b6258a06">ts::GetInt64LE</a> (const void *p)</td></tr>
<tr class="memdesc:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#aa827b7a0b2e9a76136cbffe4b6258a06">More...</a><br /></td></tr>
<tr class="separator:aa827b7a0b2e9a76136cbffe4b6258a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395998cb5255d75c73aedbba83408c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a395998cb5255d75c73aedbba83408c03">ts::GetInt64LE</a> (const void *p, int64_t &amp;i)</td></tr>
<tr class="memdesc:a395998cb5255d75c73aedbba83408c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit signed integer from serialized data in little endian representation.  <a href="namespacets.html#a395998cb5255d75c73aedbba83408c03">More...</a><br /></td></tr>
<tr class="separator:a395998cb5255d75c73aedbba83408c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#af67f53a8fcbddf0e3b5195d63f469bf5">ts::GetInt8</a> (const void *p)</td></tr>
<tr class="memdesc:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit signed integer from serialized data.  <a href="namespacets.html#af67f53a8fcbddf0e3b5195d63f469bf5">More...</a><br /></td></tr>
<tr class="separator:af67f53a8fcbddf0e3b5195d63f469bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebbae738a51852399693a6cfe37d919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aeebbae738a51852399693a6cfe37d919">ts::GetInt8</a> (const void *p, int8_t &amp;i)</td></tr>
<tr class="memdesc:aeebbae738a51852399693a6cfe37d919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit signed integer from serialized data.  <a href="namespacets.html#aeebbae738a51852399693a6cfe37d919">More...</a><br /></td></tr>
<tr class="separator:aeebbae738a51852399693a6cfe37d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#afb3a7db5384f5070e45edfb58e92c3d2">ts::GetIntBE</a> (const void *p)</td></tr>
<tr class="memdesc:afb3a7db5384f5070e45edfb58e92c3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="namespacets.html#afb3a7db5384f5070e45edfb58e92c3d2">More...</a><br /></td></tr>
<tr class="separator:afb3a7db5384f5070e45edfb58e92c3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add89d5728c5affffa607ff9f52f7ca45"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:add89d5728c5affffa607ff9f52f7ca45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#add89d5728c5affffa607ff9f52f7ca45">ts::GetIntBE</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:add89d5728c5affffa607ff9f52f7ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in big endian representation.  <a href="namespacets.html#add89d5728c5affffa607ff9f52f7ca45">More...</a><br /></td></tr>
<tr class="separator:add89d5728c5affffa607ff9f52f7ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10732fdeb495c72480c06249aa9e270"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:ab10732fdeb495c72480c06249aa9e270"><td class="memTemplItemLeft" align="right" valign="top">INT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#ab10732fdeb495c72480c06249aa9e270">ts::GetIntLE</a> (const void *p)</td></tr>
<tr class="memdesc:ab10732fdeb495c72480c06249aa9e270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in little endian representation.  <a href="namespacets.html#ab10732fdeb495c72480c06249aa9e270">More...</a><br /></td></tr>
<tr class="separator:ab10732fdeb495c72480c06249aa9e270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa461b054bf380348f7db7f899840e382"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aa461b054bf380348f7db7f899840e382"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aa461b054bf380348f7db7f899840e382">ts::GetIntLE</a> (const void *p, INT &amp;i)</td></tr>
<tr class="memdesc:aa461b054bf380348f7db7f899840e382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function getting an integer from serialized data in little endian representation.  <a href="namespacets.html#aa461b054bf380348f7db7f899840e382">More...</a><br /></td></tr>
<tr class="separator:aa461b054bf380348f7db7f899840e382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac91ac45e9e2741fd64f495afb7dd5e61">ts::GetUInt16</a> (const void *p)</td></tr>
<tr class="memdesc:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ac91ac45e9e2741fd64f495afb7dd5e61">More...</a><br /></td></tr>
<tr class="separator:ac91ac45e9e2741fd64f495afb7dd5e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640588fb3bf230cc97292e011bc6386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a640588fb3bf230cc97292e011bc6386d">ts::GetUInt16</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:a640588fb3bf230cc97292e011bc6386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a640588fb3bf230cc97292e011bc6386d">More...</a><br /></td></tr>
<tr class="separator:a640588fb3bf230cc97292e011bc6386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ccc17acabae9276cea7a69fe85cfc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac90ccc17acabae9276cea7a69fe85cfc">ts::GetUInt16BE</a> (const void *p)</td></tr>
<tr class="memdesc:ac90ccc17acabae9276cea7a69fe85cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ac90ccc17acabae9276cea7a69fe85cfc">More...</a><br /></td></tr>
<tr class="separator:ac90ccc17acabae9276cea7a69fe85cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de659ceb502ea588e7b1d54beb326b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae6de659ceb502ea588e7b1d54beb326b">ts::GetUInt16BE</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:ae6de659ceb502ea588e7b1d54beb326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ae6de659ceb502ea588e7b1d54beb326b">More...</a><br /></td></tr>
<tr class="separator:ae6de659ceb502ea588e7b1d54beb326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4afd90bdfe6e1a70c534da4b2a0f1657">ts::GetUInt16LE</a> (const void *p)</td></tr>
<tr class="memdesc:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#a4afd90bdfe6e1a70c534da4b2a0f1657">More...</a><br /></td></tr>
<tr class="separator:a4afd90bdfe6e1a70c534da4b2a0f1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb655627968c393bc4847b1801e7ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#afdb655627968c393bc4847b1801e7ccc">ts::GetUInt16LE</a> (const void *p, uint16_t &amp;i)</td></tr>
<tr class="memdesc:afdb655627968c393bc4847b1801e7ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 16-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#afdb655627968c393bc4847b1801e7ccc">More...</a><br /></td></tr>
<tr class="separator:afdb655627968c393bc4847b1801e7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2c8afb0d642689f1ca2429d96e1eb9e7">ts::GetUInt24</a> (const void *p)</td></tr>
<tr class="memdesc:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a2c8afb0d642689f1ca2429d96e1eb9e7">More...</a><br /></td></tr>
<tr class="separator:a2c8afb0d642689f1ca2429d96e1eb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3509bd545f2ef43e00fff957d39b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6a3509bd545f2ef43e00fff957d39b6d">ts::GetUInt24</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a6a3509bd545f2ef43e00fff957d39b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a6a3509bd545f2ef43e00fff957d39b6d">More...</a><br /></td></tr>
<tr class="separator:a6a3509bd545f2ef43e00fff957d39b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70882b518121c43cd47d258bbe0e7f01"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a70882b518121c43cd47d258bbe0e7f01">ts::GetUInt24BE</a> (const void *p)</td></tr>
<tr class="memdesc:a70882b518121c43cd47d258bbe0e7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a70882b518121c43cd47d258bbe0e7f01">More...</a><br /></td></tr>
<tr class="separator:a70882b518121c43cd47d258bbe0e7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502006f7de222a7313790483bd219a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a502006f7de222a7313790483bd219a80">ts::GetUInt24BE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a502006f7de222a7313790483bd219a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a502006f7de222a7313790483bd219a80">More...</a><br /></td></tr>
<tr class="separator:a502006f7de222a7313790483bd219a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e63036518e36c9aade78a0672757b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a196e63036518e36c9aade78a0672757b">ts::GetUInt24LE</a> (const void *p)</td></tr>
<tr class="memdesc:a196e63036518e36c9aade78a0672757b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#a196e63036518e36c9aade78a0672757b">More...</a><br /></td></tr>
<tr class="separator:a196e63036518e36c9aade78a0672757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4344c054ebe6196445c629dccec90142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4344c054ebe6196445c629dccec90142">ts::GetUInt24LE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a4344c054ebe6196445c629dccec90142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 24-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#a4344c054ebe6196445c629dccec90142">More...</a><br /></td></tr>
<tr class="separator:a4344c054ebe6196445c629dccec90142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68fc76b965efdefafa9ec1742ffb834"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae68fc76b965efdefafa9ec1742ffb834">ts::GetUInt32</a> (const void *p)</td></tr>
<tr class="memdesc:ae68fc76b965efdefafa9ec1742ffb834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ae68fc76b965efdefafa9ec1742ffb834">More...</a><br /></td></tr>
<tr class="separator:ae68fc76b965efdefafa9ec1742ffb834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ac2d03f32b2cc3d180c0278cb528f2dd3">ts::GetUInt32</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ac2d03f32b2cc3d180c0278cb528f2dd3">More...</a><br /></td></tr>
<tr class="separator:ac2d03f32b2cc3d180c0278cb528f2dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11bde3bce4bc0cfae007433d280f239"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad11bde3bce4bc0cfae007433d280f239">ts::GetUInt32BE</a> (const void *p)</td></tr>
<tr class="memdesc:ad11bde3bce4bc0cfae007433d280f239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ad11bde3bce4bc0cfae007433d280f239">More...</a><br /></td></tr>
<tr class="separator:ad11bde3bce4bc0cfae007433d280f239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5307f92f2750b89a6c708e2aa089474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab5307f92f2750b89a6c708e2aa089474">ts::GetUInt32BE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:ab5307f92f2750b89a6c708e2aa089474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#ab5307f92f2750b89a6c708e2aa089474">More...</a><br /></td></tr>
<tr class="separator:ab5307f92f2750b89a6c708e2aa089474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad4a5525afda4d4444ec7fa91816f9cf9">ts::GetUInt32LE</a> (const void *p)</td></tr>
<tr class="memdesc:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#ad4a5525afda4d4444ec7fa91816f9cf9">More...</a><br /></td></tr>
<tr class="separator:ad4a5525afda4d4444ec7fa91816f9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4ec83efdcf4e64a1ede8fc6f2440e38a">ts::GetUInt32LE</a> (const void *p, uint32_t &amp;i)</td></tr>
<tr class="memdesc:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 32-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#a4ec83efdcf4e64a1ede8fc6f2440e38a">More...</a><br /></td></tr>
<tr class="separator:a4ec83efdcf4e64a1ede8fc6f2440e38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d8f836756fd5acb9ec38c0732fb15b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a34d8f836756fd5acb9ec38c0732fb15b">ts::GetUInt64</a> (const void *p)</td></tr>
<tr class="memdesc:a34d8f836756fd5acb9ec38c0732fb15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a34d8f836756fd5acb9ec38c0732fb15b">More...</a><br /></td></tr>
<tr class="separator:a34d8f836756fd5acb9ec38c0732fb15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818fee94510087611afa73a9d365c585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a818fee94510087611afa73a9d365c585">ts::GetUInt64</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:a818fee94510087611afa73a9d365c585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a818fee94510087611afa73a9d365c585">More...</a><br /></td></tr>
<tr class="separator:a818fee94510087611afa73a9d365c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1c9bc167b8cc7b75ac8acfcf475a655d">ts::GetUInt64BE</a> (const void *p)</td></tr>
<tr class="memdesc:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#a1c9bc167b8cc7b75ac8acfcf475a655d">More...</a><br /></td></tr>
<tr class="separator:a1c9bc167b8cc7b75ac8acfcf475a655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba89ecf66ba17985d47ee587027d14ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aba89ecf66ba17985d47ee587027d14ea">ts::GetUInt64BE</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:aba89ecf66ba17985d47ee587027d14ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in big endian representation.  <a href="namespacets.html#aba89ecf66ba17985d47ee587027d14ea">More...</a><br /></td></tr>
<tr class="separator:aba89ecf66ba17985d47ee587027d14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1ae6fc9b599b7a479b3b4c059e27e2b2">ts::GetUInt64LE</a> (const void *p)</td></tr>
<tr class="memdesc:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#a1ae6fc9b599b7a479b3b4c059e27e2b2">More...</a><br /></td></tr>
<tr class="separator:a1ae6fc9b599b7a479b3b4c059e27e2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9099fb920e9cd1ba4f0b80070556757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad9099fb920e9cd1ba4f0b80070556757">ts::GetUInt64LE</a> (const void *p, uint64_t &amp;i)</td></tr>
<tr class="memdesc:ad9099fb920e9cd1ba4f0b80070556757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting a 64-bit unsigned integer from serialized data in little endian representation.  <a href="namespacets.html#ad9099fb920e9cd1ba4f0b80070556757">More...</a><br /></td></tr>
<tr class="separator:ad9099fb920e9cd1ba4f0b80070556757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a36e4b522c105fa6ee6706cb14bc1c77a">ts::GetUInt8</a> (const void *p)</td></tr>
<tr class="memdesc:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit unsigned integer from serialized data.  <a href="namespacets.html#a36e4b522c105fa6ee6706cb14bc1c77a">More...</a><br /></td></tr>
<tr class="separator:a36e4b522c105fa6ee6706cb14bc1c77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6099795b2a30ac243a548217568231b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6099795b2a30ac243a548217568231b7">ts::GetUInt8</a> (const void *p, uint8_t &amp;i)</td></tr>
<tr class="memdesc:a6099795b2a30ac243a548217568231b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function getting an 8-bit unsigned integer from serialized data.  <a href="namespacets.html#a6099795b2a30ac243a548217568231b7">More...</a><br /></td></tr>
<tr class="separator:a6099795b2a30ac243a548217568231b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa816d1f04480538021fee6d480570238"><td class="memItemLeft" align="right" valign="top">ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa816d1f04480538021fee6d480570238">ts::LastErrorCode</a> ()</td></tr>
<tr class="memdesc:aa816d1f04480538021fee6d480570238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of the last operating system call.  <a href="namespacets.html#aa816d1f04480538021fee6d480570238">More...</a><br /></td></tr>
<tr class="separator:aa816d1f04480538021fee6d480570238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d47fa7b363d53756b3ee588ae06e0b"><td class="memItemLeft" align="right" valign="top"><a id="a10d47fa7b363d53756b3ee588ae06e0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a10d47fa7b363d53756b3ee588ae06e0b">ts::MemoryBarrier</a> (void)</td></tr>
<tr class="memdesc:a10d47fa7b363d53756b3ee588ae06e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined C function performing a CPU/compiler dependent memory barrier. <br /></td></tr>
<tr class="separator:a10d47fa7b363d53756b3ee588ae06e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#aeb825a99d11021d5b9fb46fd09d847ab">ts::PutInt</a> (void *p, INT i)</td></tr>
<tr class="memdesc:aeb825a99d11021d5b9fb46fd09d847ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in big endian representation.  <a href="namespacets.html#aeb825a99d11021d5b9fb46fd09d847ab">More...</a><br /></td></tr>
<tr class="separator:aeb825a99d11021d5b9fb46fd09d847ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a53cfe7ccf881f48abb903fad0ce5eba4">ts::PutInt16</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in big endian representation.  <a href="namespacets.html#a53cfe7ccf881f48abb903fad0ce5eba4">More...</a><br /></td></tr>
<tr class="separator:a53cfe7ccf881f48abb903fad0ce5eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a93ea4cfd4f900ead4b28b38c1b5c86c3">ts::PutInt16BE</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in big endian representation.  <a href="namespacets.html#a93ea4cfd4f900ead4b28b38c1b5c86c3">More...</a><br /></td></tr>
<tr class="separator:a93ea4cfd4f900ead4b28b38c1b5c86c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74ec8e23311e6160103e721af9b1d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae74ec8e23311e6160103e721af9b1d5b">ts::PutInt16LE</a> (void *p, int16_t i)</td></tr>
<tr class="memdesc:ae74ec8e23311e6160103e721af9b1d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit signed integer data in little endian representation.  <a href="namespacets.html#ae74ec8e23311e6160103e721af9b1d5b">More...</a><br /></td></tr>
<tr class="separator:ae74ec8e23311e6160103e721af9b1d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4dad66d4d0f6bd8b5b996a33078da03a">ts::PutInt24</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in big endian representation.  <a href="namespacets.html#a4dad66d4d0f6bd8b5b996a33078da03a">More...</a><br /></td></tr>
<tr class="separator:a4dad66d4d0f6bd8b5b996a33078da03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683c99580e91b2adff0b3097d0332d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0683c99580e91b2adff0b3097d0332d9">ts::PutInt24BE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a0683c99580e91b2adff0b3097d0332d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in big endian representation.  <a href="namespacets.html#a0683c99580e91b2adff0b3097d0332d9">More...</a><br /></td></tr>
<tr class="separator:a0683c99580e91b2adff0b3097d0332d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae07fa62ef736da28b1075a4a58dc6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aae07fa62ef736da28b1075a4a58dc6e6">ts::PutInt24LE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:aae07fa62ef736da28b1075a4a58dc6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit signed integer data in little endian representation.  <a href="namespacets.html#aae07fa62ef736da28b1075a4a58dc6e6">More...</a><br /></td></tr>
<tr class="separator:aae07fa62ef736da28b1075a4a58dc6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4420be5d849abb7c099a35f192a85b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a4420be5d849abb7c099a35f192a85b57">ts::PutInt32</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a4420be5d849abb7c099a35f192a85b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in big endian representation.  <a href="namespacets.html#a4420be5d849abb7c099a35f192a85b57">More...</a><br /></td></tr>
<tr class="separator:a4420be5d849abb7c099a35f192a85b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6dd0238df9158bc987a2df603ee8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ae4b6dd0238df9158bc987a2df603ee8f">ts::PutInt32BE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:ae4b6dd0238df9158bc987a2df603ee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in big endian representation.  <a href="namespacets.html#ae4b6dd0238df9158bc987a2df603ee8f">More...</a><br /></td></tr>
<tr class="separator:ae4b6dd0238df9158bc987a2df603ee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3a56ef6cccf4ad5fc2db2bdb9145b341">ts::PutInt32LE</a> (void *p, int32_t i)</td></tr>
<tr class="memdesc:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit signed integer data in little endian representation.  <a href="namespacets.html#a3a56ef6cccf4ad5fc2db2bdb9145b341">More...</a><br /></td></tr>
<tr class="separator:a3a56ef6cccf4ad5fc2db2bdb9145b341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0b07e8dadad2b6d5c1a32ccc6a9396ee">ts::PutInt64</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in big endian representation.  <a href="namespacets.html#a0b07e8dadad2b6d5c1a32ccc6a9396ee">More...</a><br /></td></tr>
<tr class="separator:a0b07e8dadad2b6d5c1a32ccc6a9396ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205bd79cdf6c8821774624c63f2c563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6205bd79cdf6c8821774624c63f2c563">ts::PutInt64BE</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a6205bd79cdf6c8821774624c63f2c563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in big endian representation.  <a href="namespacets.html#a6205bd79cdf6c8821774624c63f2c563">More...</a><br /></td></tr>
<tr class="separator:a6205bd79cdf6c8821774624c63f2c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9b487302b87e7419da6928a574107b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a2a9b487302b87e7419da6928a574107b">ts::PutInt64LE</a> (void *p, int64_t i)</td></tr>
<tr class="memdesc:a2a9b487302b87e7419da6928a574107b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit signed integer data in little endian representation.  <a href="namespacets.html#a2a9b487302b87e7419da6928a574107b">More...</a><br /></td></tr>
<tr class="separator:a2a9b487302b87e7419da6928a574107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609f2d6182dfbf69356a50b4840ad5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab609f2d6182dfbf69356a50b4840ad5a">ts::PutInt8</a> (void *p, int8_t i)</td></tr>
<tr class="memdesc:ab609f2d6182dfbf69356a50b4840ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing an 8-bit signed integer data.  <a href="namespacets.html#ab609f2d6182dfbf69356a50b4840ad5a">More...</a><br /></td></tr>
<tr class="separator:ab609f2d6182dfbf69356a50b4840ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c976028b433f728b45103ea1c331e6"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:af7c976028b433f728b45103ea1c331e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#af7c976028b433f728b45103ea1c331e6">ts::PutIntBE</a> (void *p, INT i)</td></tr>
<tr class="memdesc:af7c976028b433f728b45103ea1c331e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in big endian representation.  <a href="namespacets.html#af7c976028b433f728b45103ea1c331e6">More...</a><br /></td></tr>
<tr class="separator:af7c976028b433f728b45103ea1c331e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae1747799a404d1b992b36e4dad6f62"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:abae1747799a404d1b992b36e4dad6f62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacets.html#abae1747799a404d1b992b36e4dad6f62">ts::PutIntLE</a> (void *p, INT i)</td></tr>
<tr class="memdesc:abae1747799a404d1b992b36e4dad6f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function serializing an integer data in little endian representation.  <a href="namespacets.html#abae1747799a404d1b992b36e4dad6f62">More...</a><br /></td></tr>
<tr class="separator:abae1747799a404d1b992b36e4dad6f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a305fe98ef80b1759d8576b06f67c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8a305fe98ef80b1759d8576b06f67c59">ts::PutUInt16</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a8a305fe98ef80b1759d8576b06f67c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a8a305fe98ef80b1759d8576b06f67c59">More...</a><br /></td></tr>
<tr class="separator:a8a305fe98ef80b1759d8576b06f67c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a24f8f07a858bb7c998fd49e0ab5c2936">ts::PutUInt16BE</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a24f8f07a858bb7c998fd49e0ab5c2936">More...</a><br /></td></tr>
<tr class="separator:a24f8f07a858bb7c998fd49e0ab5c2936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bca47bda40cfd63c54acceafd8c9720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a0bca47bda40cfd63c54acceafd8c9720">ts::PutUInt16LE</a> (void *p, uint16_t i)</td></tr>
<tr class="memdesc:a0bca47bda40cfd63c54acceafd8c9720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 16-bit unsigned integer data in little endian representation.  <a href="namespacets.html#a0bca47bda40cfd63c54acceafd8c9720">More...</a><br /></td></tr>
<tr class="separator:a0bca47bda40cfd63c54acceafd8c9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3d9ddad30e3e50702cc7fcd19a6e8c97">ts::PutUInt24</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a3d9ddad30e3e50702cc7fcd19a6e8c97">More...</a><br /></td></tr>
<tr class="separator:a3d9ddad30e3e50702cc7fcd19a6e8c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a9edaf6a54326bf4a0ece6d642a81e1a6">ts::PutUInt24BE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a9edaf6a54326bf4a0ece6d642a81e1a6">More...</a><br /></td></tr>
<tr class="separator:a9edaf6a54326bf4a0ece6d642a81e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78420230afab2dda2251c77a64f0a42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a78420230afab2dda2251c77a64f0a42f">ts::PutUInt24LE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a78420230afab2dda2251c77a64f0a42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 24-bit unsigned integer data in little endian representation.  <a href="namespacets.html#a78420230afab2dda2251c77a64f0a42f">More...</a><br /></td></tr>
<tr class="separator:a78420230afab2dda2251c77a64f0a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ebe5e56895037b713f551b84b20d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab8ebe5e56895037b713f551b84b20d26">ts::PutUInt32</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:ab8ebe5e56895037b713f551b84b20d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in big endian representation.  <a href="namespacets.html#ab8ebe5e56895037b713f551b84b20d26">More...</a><br /></td></tr>
<tr class="separator:ab8ebe5e56895037b713f551b84b20d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706da0714b173a86e1d3453b296f809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1706da0714b173a86e1d3453b296f809">ts::PutUInt32BE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:a1706da0714b173a86e1d3453b296f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a1706da0714b173a86e1d3453b296f809">More...</a><br /></td></tr>
<tr class="separator:a1706da0714b173a86e1d3453b296f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecae3276848613afd48ca0e86fe0612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acecae3276848613afd48ca0e86fe0612">ts::PutUInt32LE</a> (void *p, uint32_t i)</td></tr>
<tr class="memdesc:acecae3276848613afd48ca0e86fe0612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 32-bit unsigned integer data in little endian representation.  <a href="namespacets.html#acecae3276848613afd48ca0e86fe0612">More...</a><br /></td></tr>
<tr class="separator:acecae3276848613afd48ca0e86fe0612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78a8326b8a5742aeec60b9f625149f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8d78a8326b8a5742aeec60b9f625149f">ts::PutUInt64</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a8d78a8326b8a5742aeec60b9f625149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a8d78a8326b8a5742aeec60b9f625149f">More...</a><br /></td></tr>
<tr class="separator:a8d78a8326b8a5742aeec60b9f625149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55984dfbb23eadbafe471c519bb141a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a55984dfbb23eadbafe471c519bb141a2">ts::PutUInt64BE</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a55984dfbb23eadbafe471c519bb141a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in big endian representation.  <a href="namespacets.html#a55984dfbb23eadbafe471c519bb141a2">More...</a><br /></td></tr>
<tr class="separator:a55984dfbb23eadbafe471c519bb141a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a256ffe0e0d15f20904ccc77b5b015e4c">ts::PutUInt64LE</a> (void *p, uint64_t i)</td></tr>
<tr class="memdesc:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing a 64-bit unsigned integer data in little endian representation.  <a href="namespacets.html#a256ffe0e0d15f20904ccc77b5b015e4c">More...</a><br /></td></tr>
<tr class="separator:a256ffe0e0d15f20904ccc77b5b015e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2da9f1234257162bc54cdc7f14577d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5d2da9f1234257162bc54cdc7f14577d">ts::PutUInt8</a> (void *p, uint8_t i)</td></tr>
<tr class="memdesc:a5d2da9f1234257162bc54cdc7f14577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function serializing an 8-bit unsigned integer data.  <a href="namespacets.html#a5d2da9f1234257162bc54cdc7f14577d">More...</a><br /></td></tr>
<tr class="separator:a5d2da9f1234257162bc54cdc7f14577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1511582799a25d3ca0889391ef6cdd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#acc1511582799a25d3ca0889391ef6cdd">ts::ROL</a> (uint32_t word, int i)</td></tr>
<tr class="memdesc:acc1511582799a25d3ca0889391ef6cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit left-rotate.  <a href="namespacets.html#acc1511582799a25d3ca0889391ef6cdd">More...</a><br /></td></tr>
<tr class="separator:acc1511582799a25d3ca0889391ef6cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57151094cdd98106fb52d244ab77512a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a57151094cdd98106fb52d244ab77512a">ts::ROL64</a> (uint64_t word, int i)</td></tr>
<tr class="memdesc:a57151094cdd98106fb52d244ab77512a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit left-rotate.  <a href="namespacets.html#a57151094cdd98106fb52d244ab77512a">More...</a><br /></td></tr>
<tr class="separator:a57151094cdd98106fb52d244ab77512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693f2485d1a42ed33214a7d04d4421d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ad693f2485d1a42ed33214a7d04d4421d">ts::ROL64c</a> (uint64_t word, const int i)</td></tr>
<tr class="memdesc:ad693f2485d1a42ed33214a7d04d4421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit left-rotate with a constant value in the range 0..63 for index.  <a href="namespacets.html#ad693f2485d1a42ed33214a7d04d4421d">More...</a><br /></td></tr>
<tr class="separator:ad693f2485d1a42ed33214a7d04d4421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aebdf2fed7c021b5f0ed05991aea8c9b2">ts::ROR</a> (uint32_t word, int i)</td></tr>
<tr class="memdesc:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit right-rotate.  <a href="namespacets.html#aebdf2fed7c021b5f0ed05991aea8c9b2">More...</a><br /></td></tr>
<tr class="separator:aebdf2fed7c021b5f0ed05991aea8c9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea56cdee827d08793a5f9b9c608ff787"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aea56cdee827d08793a5f9b9c608ff787">ts::ROR64</a> (uint64_t word, int i)</td></tr>
<tr class="memdesc:aea56cdee827d08793a5f9b9c608ff787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit right-rotate.  <a href="namespacets.html#aea56cdee827d08793a5f9b9c608ff787">More...</a><br /></td></tr>
<tr class="separator:aea56cdee827d08793a5f9b9c608ff787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6d0521f51487a0d59c3f36fc6f2d8cfe">ts::ROR64c</a> (uint64_t word, const int i)</td></tr>
<tr class="memdesc:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 64-bit right-rotate with a constant value in the range 0..63 for index.  <a href="namespacets.html#a6d0521f51487a0d59c3f36fc6f2d8cfe">More...</a><br /></td></tr>
<tr class="separator:a6d0521f51487a0d59c3f36fc6f2d8cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd41a7d2a6ef91744555d603accea06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1bd41a7d2a6ef91744555d603accea06">ts::RORc</a> (uint32_t word, const int i)</td></tr>
<tr class="memdesc:a1bd41a7d2a6ef91744555d603accea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined function performing 32-bit left-rotate with a constant value in the range 0..31 for index.  <a href="namespacets.html#a1bd41a7d2a6ef91744555d603accea06">More...</a><br /></td></tr>
<tr class="separator:a1bd41a7d2a6ef91744555d603accea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6eea3582f5368a84f08aa6512942a3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5d6eea3582f5368a84f08aa6512942a3">ts::SignExtend24</a> (int32_t x)</td></tr>
<tr class="memdesc:a5d6eea3582f5368a84f08aa6512942a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sign extension on 24 bit integers.  <a href="namespacets.html#a5d6eea3582f5368a84f08aa6512942a3">More...</a><br /></td></tr>
<tr class="separator:a5d6eea3582f5368a84f08aa6512942a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6b91ccf90475c62f610ea549f69d8544"><td class="memItemLeft" align="right" valign="top"><a id="a6b91ccf90475c62f610ea549f69d8544"></a>
const SubSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a6b91ccf90475c62f610ea549f69d8544">ts::Infinite</a> =</td></tr>
<tr class="memdesc:a6b91ccf90475c62f610ea549f69d8544"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant shall be used by convention to express an infinite number of sub-quantities of seconds. <br /></td></tr>
<tr class="separator:a6b91ccf90475c62f610ea549f69d8544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf3f54f6cf6cb9586933ff8399d674b"><td class="memItemLeft" align="right" valign="top"><a id="abcf3f54f6cf6cb9586933ff8399d674b"></a>
const MicroSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#abcf3f54f6cf6cb9586933ff8399d674b">ts::MicroSecPerMilliSec</a> = 1000</td></tr>
<tr class="memdesc:abcf3f54f6cf6cb9586933ff8399d674b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of microseconds per millisecond. <br /></td></tr>
<tr class="separator:abcf3f54f6cf6cb9586933ff8399d674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6679c4a9aba952879b7da520646198"><td class="memItemLeft" align="right" valign="top"><a id="ace6679c4a9aba952879b7da520646198"></a>
const MicroSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ace6679c4a9aba952879b7da520646198">ts::MicroSecPerSec</a> = 1000000</td></tr>
<tr class="memdesc:ace6679c4a9aba952879b7da520646198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of microseconds per second. <br /></td></tr>
<tr class="separator:ace6679c4a9aba952879b7da520646198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1261ea5ea24a0b939aad378855c9d5"><td class="memItemLeft" align="right" valign="top"><a id="a3b1261ea5ea24a0b939aad378855c9d5"></a>
const MilliSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a3b1261ea5ea24a0b939aad378855c9d5">ts::MilliSecPerDay</a> = 1000 * 60 * 60 * 24</td></tr>
<tr class="memdesc:a3b1261ea5ea24a0b939aad378855c9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per day. <br /></td></tr>
<tr class="separator:a3b1261ea5ea24a0b939aad378855c9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada065f3612eab8e440bf264dce8f0c41"><td class="memItemLeft" align="right" valign="top"><a id="ada065f3612eab8e440bf264dce8f0c41"></a>
const MilliSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ada065f3612eab8e440bf264dce8f0c41">ts::MilliSecPerHour</a> = 1000 * 60 * 60</td></tr>
<tr class="memdesc:ada065f3612eab8e440bf264dce8f0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per hour. <br /></td></tr>
<tr class="separator:ada065f3612eab8e440bf264dce8f0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550e2239393917c1e0f11aa6b5677e5"><td class="memItemLeft" align="right" valign="top"><a id="ab550e2239393917c1e0f11aa6b5677e5"></a>
const MilliSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#ab550e2239393917c1e0f11aa6b5677e5">ts::MilliSecPerMin</a> = 1000 * 60</td></tr>
<tr class="memdesc:ab550e2239393917c1e0f11aa6b5677e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per minute. <br /></td></tr>
<tr class="separator:ab550e2239393917c1e0f11aa6b5677e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527aa0a05bca6431521cf655a1edc8e"><td class="memItemLeft" align="right" valign="top"><a id="a8527aa0a05bca6431521cf655a1edc8e"></a>
const MilliSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a8527aa0a05bca6431521cf655a1edc8e">ts::MilliSecPerSec</a> = 1000</td></tr>
<tr class="memdesc:a8527aa0a05bca6431521cf655a1edc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of milliseconds per second. <br /></td></tr>
<tr class="separator:a8527aa0a05bca6431521cf655a1edc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5026fdf7e76abd5ddc916485aee90d3"><td class="memItemLeft" align="right" valign="top"><a id="aa5026fdf7e76abd5ddc916485aee90d3"></a>
const NanoSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#aa5026fdf7e76abd5ddc916485aee90d3">ts::NanoSecPerMicroSec</a> = 1000</td></tr>
<tr class="memdesc:aa5026fdf7e76abd5ddc916485aee90d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per microsecond. <br /></td></tr>
<tr class="separator:aa5026fdf7e76abd5ddc916485aee90d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6152f80180efe63539259baba67b6b"><td class="memItemLeft" align="right" valign="top"><a id="a1e6152f80180efe63539259baba67b6b"></a>
const NanoSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a1e6152f80180efe63539259baba67b6b">ts::NanoSecPerMilliSec</a> = 1000000</td></tr>
<tr class="memdesc:a1e6152f80180efe63539259baba67b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per millisecond. <br /></td></tr>
<tr class="separator:a1e6152f80180efe63539259baba67b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07088c08e01c6a37d53a9dda4d053560"><td class="memItemLeft" align="right" valign="top"><a id="a07088c08e01c6a37d53a9dda4d053560"></a>
const NanoSecond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a07088c08e01c6a37d53a9dda4d053560">ts::NanoSecPerSec</a> = 1000000000</td></tr>
<tr class="memdesc:a07088c08e01c6a37d53a9dda4d053560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nanoseconds per second. <br /></td></tr>
<tr class="separator:a07088c08e01c6a37d53a9dda4d053560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67013ae18c714713055aa25de3a24568"><td class="memItemLeft" align="right" valign="top">const ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a67013ae18c714713055aa25de3a24568">ts::SYS_DATA_ERROR</a> = platform_specific</td></tr>
<tr class="memdesc:a67013ae18c714713055aa25de3a24568"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating a generic data error.  <a href="namespacets.html#a67013ae18c714713055aa25de3a24568">More...</a><br /></td></tr>
<tr class="separator:a67013ae18c714713055aa25de3a24568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="memItemLeft" align="right" valign="top">const ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacets.html#a5c31a3d1b0122eb8863cc6feaef7df44">ts::SYS_SUCCESS</a> = platform_specific</td></tr>
<tr class="memdesc:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacets.html#a1c5cb8c11b9201fea00bbc07569b1bc4">ErrorCode</a> value indicating success.  <a href="namespacets.html#a5c31a3d1b0122eb8863cc6feaef7df44">More...</a><br /></td></tr>
<tr class="separator:a5c31a3d1b0122eb8863cc6feaef7df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cross-platforms portable base definitions for the TSDuck project. </p>
<p>This header file shall be included by all C++ compilation units in the TSDuck project. It provides common portable definitions. This file shall always be included first, before system headers and other TSDuck headers.</p>
<p><b>Important:</b> This file shall be updated each time a new platform is used (processor, compiler, operating system). When recompiling this header on a new platform, many errors are generated (explicit <code>#error</code> directives). These errors will guide you on the required additions for the new platform.</p>
<h1><a class="anchor" id="platforms"></a>
Platform definitions</h1>
<p>This header file conditionally defines several symbols (macros) which describe the platform (processor, compiler, operating system). These symbols can be used for conditional compilation.</p>
<p>The following environments are described:</p>
<ul>
<li>Compiler: See <a class="el" href="ts_platform_8h.html#addaac508cee6f534643968e2b6cee17c">__gcc</a>, <a class="el" href="ts_platform_8h.html#ad9f7e8bf8ffb2c0575e58571680bda82">__msc</a>, etc. </li>
<li>Operating system: See <a class="el" href="ts_platform_8h.html#a6c6342c53a7213211680dc5caae14491">__linux</a>, <a class="el" href="ts_platform_8h.html#a1ea774d39288ab9e84383613da2afb6d">__windows</a>, etc. </li>
<li>Byte ordering: See <a class="el" href="ts_platform_8h.html#ad6ddc4d88d0ecde53e8fc0ddfaa713a7">__little_endian</a> and <a class="el" href="ts_platform_8h.html#ae41e1bfb8a6aeba6fdd0dc0e6e09a95f">__big_endian</a>. </li>
<li>Processor architecture: See <a class="el" href="ts_platform_8h.html#a47c94af7fb8637b1b7ea09bf081ac8bc">__i386</a>, <a class="el" href="ts_platform_8h.html#a64b6ba77bbc2cb5db2a19f32e954fcc3">__x86_64</a>, etc.</li>
</ul>
<h1><a class="anchor" id="issues"></a>
Solving various compilation issues</h1>
<p>This header file defines some macros which can be used to solve various C/C++ compilation issues.</p>
<ul>
<li>Explicitly unused variables: See <a class="el" href="ts_platform_8h.html#a93e23355947fbaf69c05494a70eec929">TS_UNUSED</a>. </li>
<li>The null pointer and C++: See <a class="el" href="ts_platform_8h.html#a923af0deea083081c539bed4e798ab67">TS_NULL</a>. </li>
<li>Definitions of C++ constants: See <a class="el" href="ts_platform_8h.html#aa5f5dfb0a0f2879ad295da2225e8a9f9">TS_NEED_STATIC_CONST_DEFINITIONS</a>. </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0d2bd295cc1e1e97dbf806ba0c42515e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2bd295cc1e1e97dbf806ba0c42515e">&#9670;&nbsp;</a></span>__llvm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __llvm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined when the compiler is LLVM (clang). </p>
<p>In that case, __gcc is also defined since LLVM is reasonably compatible with GCC. </p>

</div>
</div>
<a id="ad9f7e8bf8ffb2c0575e58571680bda82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f7e8bf8ffb2c0575e58571680bda82">&#9670;&nbsp;</a></span>__msc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __msc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined when the compiler is Microsoft C/C++, the default compiler in the Microsoft Visual Studio environment. </p>
<p>Also used on command line and batch file as the <code>cl</code> command. </p>

</div>
</div>
<a id="a133bb38cbcd7785865b94b3bbbb8da4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133bb38cbcd7785865b94b3bbbb8da4d">&#9670;&nbsp;</a></span>TS_GCC_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_GCC_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GCC version, encoded as an integer. </p>
<p>Example: 40801 for GCC 4.8.1. Undefined when the compiler is not GCC or its version is unknown. </p>

</div>
</div>
<a id="ac3cd8b035cfb8a68f6d1119ace36f1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cd8b035cfb8a68f6d1119ace36f1cc">&#9670;&nbsp;</a></span>__unix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __unix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined when compiled for any flavor of UNIX target platforms. </p>
<p>This symbol comes in addition to the specific symbol for the target platform (<a class="el" href="ts_platform_8h.html#a6c6342c53a7213211680dc5caae14491">__linux</a>, etc.) </p>

</div>
</div>
<a id="ae5271a0d21edb2a1886ed53173ba48e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5271a0d21edb2a1886ed53173ba48e8">&#9670;&nbsp;</a></span>TS_DVB_API_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_DVB_API_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On Linux systems, identify the Linux DVB API version in one value. </p>
<p>Example: TS_DVB_API_VERSION is 503 for DVB API version 5.3. </p>

</div>
</div>
<a id="a81ffc1445d4ad494ed54a5ab1e446073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ffc1445d4ad494ed54a5ab1e446073">&#9670;&nbsp;</a></span>TS_STRINGIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_STRINGIFY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro transforms the <em>value</em> of a macro parameter into the equivalent string. </p>
<p>This is a very specific macro. It is typically used only inside the definition of another macro. It is similar to the # token in the preprocessor but has a slightly different effect. The # token transforms the <em>text</em> of a macro parameter into a string while TS_STRINGIFY transforms the <em>value</em> of a macro parameter into a string, after all preprocessing substitutions.</p>
<p>The following example illustrates the difference between the # token and TS_STRINGIFY:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define P1(v) printf(&quot;#parameter:     %s = %d\n&quot;, #v, v)</span></div><div class="line"><span class="preprocessor">#define P2(v) printf(&quot;TS_STRINGIFY: %s = %d\n&quot;, TS_STRINGIFY(v), v)</span></div><div class="line">....</div><div class="line"><span class="preprocessor">#define X 1</span></div><div class="line">P1(X);</div><div class="line">P2(X);</div></div><!-- fragment --><p>This will print:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#parameter:     X = 1</span></div><div class="line"><span class="preprocessor">TS_STRINGIFY: 1 = 1</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a93e23355947fbaf69c05494a70eec929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e23355947fbaf69c05494a70eec929">&#9670;&nbsp;</a></span>TS_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_UNUSED&#160;&#160;&#160;platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attribute for explicitly unused variables. </p>
<p>It is sometimes required to declare unused variables. This may be temporary, before completing the code and using the variable later, or for any other reason. When the compiler is used in "paranoid" warning mode, declaring unused variables may trigger a warning or an error.</p>
<p>When you know that you need to declare an unused variable, the special macro <code>TS_UNUSED</code> shall be used as an <em>attribute</em> of the variable. Using this attribute, the compiler will no longer complain that the variable is unused.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="ts_platform_8h.html#a93e23355947fbaf69c05494a70eec929">TS_UNUSED</a> <span class="keywordtype">int</span> i;</div></div><!-- fragment --> 
</div>
</div>
<a id="a923af0deea083081c539bed4e798ab67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923af0deea083081c539bed4e798ab67">&#9670;&nbsp;</a></span>TS_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_NULL&#160;&#160;&#160;(static_cast&lt;void*&gt;(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a NULL pointer for C++. </p>
<p>C++ normally does not use a <code>NULL</code> constant. Null pointers are simply <code>0</code>. However, in untyped context (typically, a variable list of arguments), <code>0</code> is interpreted as an zero of type <code>int</code> and not as a null pointer. On platforms such as x86_64 where <code>int</code> and pointers do not have the same size, using <code>0</code> in a variable list of arguments may produce incorrect results.</p>
<p>This header file ensure that <code>NULL</code> is defined for both C and C++ and has always the semantic of a null pointer, regardless of the context. </p>

</div>
</div>
<a id="abb17342788b99c194860e5b6707a82fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb17342788b99c194860e5b6707a82fa">&#9670;&nbsp;</a></span>TS_NULL_CHAR_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_NULL_CHAR_PTR&#160;&#160;&#160;(static_cast&lt;char*&gt;(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a NULL pointer for C++ with an explicit char pointer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ts_platform_8h.html#a923af0deea083081c539bed4e798ab67" title="Definition of a NULL pointer for C++. ">TS_NULL</a> </dd></dl>

</div>
</div>
<a id="a77031276ee5ec897860802390f028b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77031276ee5ec897860802390f028b7d">&#9670;&nbsp;</a></span>TS_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_FUNCTION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of the name of the current function. </p>
<p>This is typically <b>func</b> but recent compilers have "pretty" names for C++. </p>

</div>
</div>
<a id="ae1cda62454d23e62fb576be3783aec47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cda62454d23e62fb576be3783aec47">&#9670;&nbsp;</a></span>TSDUCKDLL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TSDUCKDLL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attribute to declare a class or function from tsduck.dll on Windows. </p>
<p>When building tsduck.dll on Windows, define _TSDUCKDLL_IMPL in the project options. When building a project which references tsduck.dll, define _TSDUCKDLL_USE. All API located inside tsduck.dll shall be prefixed by TSDUCKDLL in headers. This prefix exports the API when building the DLL and imports the API when used in an application. </p>

</div>
</div>
<a id="aa5f5dfb0a0f2879ad295da2225e8a9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f5dfb0a0f2879ad295da2225e8a9f9">&#9670;&nbsp;</a></span>TS_NEED_STATIC_CONST_DEFINITIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_NEED_STATIC_CONST_DEFINITIONS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation of definitions of C++ constants. </p>
<p>It is a well-known pattern in C++ to define constants in header files as <code>static const</code>. Example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> FOO = 1;</div></div><!-- fragment --><p> According to Stroustrup 10.4.6.2, this is only a declaration, which needs a definition somewhere else, without initialization. Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> classname::FOO;</div></div><!-- fragment --><p>This is a really stupid oddity of C++ which is handled differently by compilers:</p>
<ul>
<li>GCC, with optimization: The declaration alone is fine. The definition is accepted. </li>
<li>GCC, without optimization: Sometimes, depending on the way the constants are used, the definition is required. Without definition, the linker complains about an undefined symbol. </li>
<li>Microsoft C: The definition must not be used. Otherwise, the linker complains about a multiply defined symbol.</li>
</ul>
<p>As a consequence, there are situations where the definition is required and situations where the definition is forbidden. The presence of the definition shall be conditioned to the macro <code>TS_NEED_STATIC_CONST_DEFINITIONS</code>.</p>
<p>Example: In tsFoo.h, the constant is declared as: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacets.html">ts</a> {</div><div class="line">    <span class="keyword">class </span>Foo</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_ENTRIES = 10;</div><div class="line">        ...</div></div><!-- fragment --><p>In tsFoo.cpp, the definition of the constant shall be conditionally compiled since all compilers do not behave identically: </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined(TS_NEED_STATIC_CONST_DEFINITIONS)</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> ts::Foo::MAX_ENTRIES;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> 
</div>
</div>
<a id="acbedf570df77410fe4dc09385caf2216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbedf570df77410fe4dc09385caf2216">&#9670;&nbsp;</a></span>TS_CONST64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_CONST64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable definition of a 64-bit signed literal. </p>
<p>The C/C++ languages define the syntax for integer literals. An integer literal is always <em>typed</em>. Without suffix such as in <code>0</code>, the literal has type <code>int</code>. With an <code>L</code> suffix, such as in <code>0L</code>, the literal has type <code>long</code>. But there is no standard suffix or syntax for 64-bit literals; different compilers have different syntaxes.</p>
<p>This macro is a portable way to write 64-bit signed literals.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> int64_t aBigOne = <a class="code" href="ts_platform_8h.html#acbedf570df77410fe4dc09385caf2216">TS_CONST64</a>(0x7FFFFFFFFFFFFFFF);</div></div><!-- fragment --> 
</div>
</div>
<a id="a28c83fdc23352d2e7835cb9f691542e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c83fdc23352d2e7835cb9f691542e5">&#9670;&nbsp;</a></span>TS_UCONST64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_UCONST64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable definition of a 64-bit unsigned literal. </p>
<p>The C/C++ languages define the syntax for integer literals. An integer literal is always <em>typed</em>. Without suffix such as in <code>0</code>, the literal has type <code>int</code>. With an <code>L</code> suffix, such as in <code>0L</code>, the literal has type <code>long</code>. But there is no standard suffix or syntax for 64-bit literals; different compilers have different syntaxes.</p>
<p>This macro is a portable way to write 64-bit unsigned literals.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> uint64_t aBigOne = <a class="code" href="ts_platform_8h.html#a28c83fdc23352d2e7835cb9f691542e5">TS_UCONST64</a>(0xFFFFFFFFFFFFFFFF);</div></div><!-- fragment --> 
</div>
</div>
<a id="aed38bcf0ad48a35087967d279e15a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed38bcf0ad48a35087967d279e15a0dc">&#9670;&nbsp;</a></span>TS_NO_MEMORY_BARRIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_NO_MEMORY_BARRIER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be defined to implement memory barrier as a no-operation. </p>
<p>This symbol shall be defined by the developer on the command line to ensure that no specific memory barrier instruction is generated.</p>
<p>This can be useful in some environments (for instance using valgrind on the ARM architecture) when the memory barrier causes some trouble.</p>
<p>Note that not using memory barrier instructions can cause some extremely rare race conditions. </p>

</div>
</div>
<a id="ac9c573be2d797a2b160e7417cce03980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c573be2d797a2b160e7417cce03980">&#9670;&nbsp;</a></span>TS_PRINTF_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_PRINTF_FORMAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">formatIndex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">argIndex&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntax-checking attribute for functions with a printf-like format. </p>
<p>Functions like <code>printf</code> use a variable-length argument list. The number of arguments and their required types depend on the content of the <em>format</em> string. For each <em>format</em> content, there is a specific number of expected arguments and the type of each argument is perfectly defined. But most compilers cannot check the validity of the number of arguments and their types. If the number of arguments or any of their types is wrong, the results are unpredictable. This is very well-known pitfall for C programers.</p>
<p>However, some compilers such as GCC are able to analyze printf-like format strings and validate the variable list of arguments at compile time. This is performed using a specific non-portable function attribute.</p>
<p>This macro defines a portable way of specifying this attribute. With compilers such as GCC which are able to perform this check, the specific attribute is specified and the compile-time checks are performed. With all other compilers, the macro expands to nothing and no check is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatIndex</td><td>Specifies the index of the <em>format</em> argument in the function. </td></tr>
    <tr><td class="paramname">argIndex</td><td>Specifies the index of the first argument for the <em>format</em> string.</td></tr>
  </table>
  </dd>
</dl>
<p>Parameter indexes start at 1 for functions and at 2 for C++ member functions (the implicit parameter at index 1 is <code>this</code> in the case of C++ member functions).</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyPrint(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...) <a class="code" href="ts_platform_8h.html#ac9c573be2d797a2b160e7417cce03980">TS_PRINTF_FORMAT</a>(1, 2);</div></div><!-- fragment --> 
</div>
</div>
<a id="a69ad63eb5d0c912c5910090ba05967d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ad63eb5d0c912c5910090ba05967d8">&#9670;&nbsp;</a></span>FMT_SIZE_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FMT_SIZE_T&#160;&#160;&#160;&quot;platform-specific&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string value to specify a <code>size_t</code> argument in <code>printf</code> <em>format</em> strings. </p>
<p>The size of the predefined type <code>size_t</code> depends on the platform. It is typically 32 or 64 bits. When formatting a <code>size_t</code> value in printf-like functions, the required specifier is consequently unknown. It can be "%d" or "%ld" or instance. It is difficult to write portable code which formats a <code>size_t</code> value. Specifically, GCC/glibc and Microsoft C++ use different specifiers.</p>
<p>This macro translates to a string constant which contains the appropriate format specifier for <code>size_t</code> on the target platform.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> size = ...;</div><div class="line">printf(<span class="stringliteral">&quot;size_t value is %&quot;</span> <a class="code" href="ts_platform_8h.html#a69ad63eb5d0c912c5910090ba05967d8">FMT_SIZE_T</a> <span class="stringliteral">&quot;d&quot;</span>, size);</div></div><!-- fragment --> 
</div>
</div>
<a id="aad88cf9252037fc1b4e5cfbec0f02b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad88cf9252037fc1b4e5cfbec0f02b75">&#9670;&nbsp;</a></span>FMT_INT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FMT_INT64&#160;&#160;&#160;&quot;platform-specific&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string value to specify a 64-bit integer argument in <code>printf</code> <em>format</em> strings. </p>
<p>The C/C++ standards do not specify a format for integer types which are <em>longer than <code>long</em></code>, i.e. 64-bit integers on most platforms. When formatting a 64-bit integer value in printf-like functions, the required specifier is consequently unknown. Specifically, GCC/glibc and Microsoft C++ use different specifiers.</p>
<p>This macro translates to a string constant which contains the appropriate format specifier for a 64-bit integer on the target platform.</p>
<p>Example: </p><div class="fragment"><div class="line">uint64_t ui64 = ...;</div><div class="line">printf(<span class="stringliteral">&quot;64-bit value is %&quot;</span> <a class="code" href="ts_platform_8h.html#aad88cf9252037fc1b4e5cfbec0f02b75">FMT_INT64</a> <span class="stringliteral">&quot;d&quot;</span>, ui64);</div></div><!-- fragment --> 
</div>
</div>
<a id="afc375210e050482fdac6d6f60417a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc375210e050482fdac6d6f60417a97f">&#9670;&nbsp;</a></span>TS_FORMAT_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TS_FORMAT_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">string_var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format_arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is used in functions with a variable list of arguments to format a <code>std::string</code> from a printf-like format and its variable-length list of arguments. </p>
<p>This operation cannot be done using a function in a portable way. Consequently, a macro is required.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)</div><div class="line">{</div><div class="line">    std::string result;</div><div class="line">    <a class="code" href="ts_platform_8h.html#afc375210e050482fdac6d6f60417a97f">TS_FORMAT_STRING</a>(result, format);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string_var</td><td>The <code>std::string</code> into which the result is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format_arg</td><td>The printf-like format argument of the current function. The variable-length list of arguments for the format are assumed to immediately follow the format argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a018c8aa689b1d1828c9e6d307084e9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018c8aa689b1d1828c9e6d307084e9b8">&#9670;&nbsp;</a></span>TSDUCK_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TSDUCK_SOURCE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro inserts a build mark in the source code, identifying it as part or TSDuck. </p>
<p>The first field after the marker prefix is the compilation date. According to the C11 and C++11 standards, the value of the macro <b>DATE</b> is a character string literal of the form "Mmm dd yyyy", where the names of the months are the same as those generated by the asctime function, and the first character of dd is a space character if the value is less than 10.</p>
<p>The second field is the compilation time. According to the C11 and C++11 standards, the value of the macro <b>TIME</b> is a character string literal of the form "hh:mm:ss" as in the time generated by the asctime function.</p>
<p>The third field is the name of the source file which invokes the macro. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
</body>
</html>
